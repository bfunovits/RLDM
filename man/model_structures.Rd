% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/02_templates.R
\name{model structures}
\alias{model structures}
\alias{model2template}
\alias{tmpl_arma_pq}
\alias{tmpl_arma_echelon}
\alias{tmpl_rmfd_pq}
\alias{tmpl_rmfd_echelon}
\alias{tmpl_stsp_full}
\alias{tmpl_stsp_ar}
\alias{tmpl_stsp_echelon}
\title{Model Structures}
\usage{
model2template(
  model,
  sigma_L = c("as_given", "chol", "symm", "identity", "full_normalized")
)

tmpl_arma_pq(
  m,
  n,
  p,
  q,
  sigma_L = c("chol", "symm", "identity", "full_normalized")
)

tmpl_arma_echelon(
  nu,
  n = length(nu),
  sigma_L = c("chol", "symm", "identity", "full_normalized")
)

tmpl_rmfd_pq(
  m,
  n,
  p,
  q,
  sigma_L = c("chol", "symm", "identity", "full_normalized")
)

tmpl_rmfd_echelon(
  nu,
  m = length(nu),
  sigma_L = c("chol", "symm", "identity", "full_normalized")
)

tmpl_stsp_full(
  m,
  n,
  s,
  sigma_L = c("chol", "symm", "identity", "full_normalized")
)

tmpl_stsp_ar(m, p, sigma_L = c("chol", "symm", "identity", "full_normalized"))

tmpl_stsp_echelon(
  nu,
  n = length(nu),
  sigma_L = c("chol", "symm", "identity", "full_normalized")
)
}
\arguments{
\item{model}{\code{\link[=armamod]{armamod()}}, \code{\link[=rmfdmod]{rmfdmod()}} or \code{\link[=stspmod]{stspmod()}} object.}

\item{sigma_L}{(character string) determines the form of the (left) square root
of the noise covariance \eqn{\Sigma}. The choice \code{"chol"} gives a
lower triangular matrix, \code{"symm"} gives a symmetric matrix and
\code{"identity"} corresponds to a fixed (identity) matrix.
The  procedure \code{model2template} has an additional option \code{"as_given"}
which means that the structure of the square root \code{sigma_L} is
completely determined by the \code{sigma_L} slot of the given model.}

\item{m}{output dimension}

\item{n}{input dimension (= number of shocks = dimension of the noise process)}

\item{p}{order of the AR polynomial for ARMA models, respectively the order of the
right factor polynomial \eqn{c(z)} in an RMFD model.}

\item{q}{order of the MA polynomial for ARMA models, respectively the order of the
left factor polynomial \eqn{d(z)} in an RMFD model.}

\item{nu}{vector of Kronecker indices. For ARMA models the Kronecker indices
describe the basis rows and for RMFD models the basis columns
of the Hankel matrix of the impulse response coefficients.}

\item{s}{state dimension for state space models.}
}
\value{
The functions \code{model2template} and \verb{tmpl_***} return a model template.
}
\description{
These tools define and implement \strong{model structures} where the \strong{model parameters} are represented
by an affine function of some \strong{free} (\strong{deep}) parameters. As an example consider
multivariate ARMA models. The AR coefficients \eqn{a_k}{a[k]}, the MA coefficients \eqn{b_k}{b[k]}
and the (left) square root of the noise covariance matrix, \eqn{L} say, are vectorized and stacked
into a (long) parameter vector as
\deqn{\pi = (\mbox{vec}(a_1)',\ldots,\mbox{vec}(a_p)',
             \mbox{vec}(b_1)',\ldots,\mbox{vec}(b_q)',\mbox{vec}(L)')'}{\pi =
             (vec(a[1])',\ldots,vec(a[p])',
              vec(b[1])',\ldots,vec(b[q])',vec(L)')'}
This parameter vector then is written as
\deqn{\pi = h + H\theta}
where \eqn{\theta} represents the \strong{free} parameters. Of course the matrix \eqn{H} is assumed to have
full column rank. This parameterization scheme is quite flexible. In particular, ARMA and
state space models in \strong{echelon form} may be represented by this scheme.
\cr
Templates and the related tools are mainly used for estimation and for the generation of (random) models
for simulations and testing.
}
\details{
The functions \code{model2template} and \verb{tmpl_***} generate model "templates" which
represent certain model structures, where the model parameters are affine functions of some
\strong{free}, respectively \strong{deep}, parameters.

The template contains information about the model structure in the following slots
\enumerate{
\item \verb{h, H} represent the vector \eqn{h} and the marix \eqn{H} as described above.
(The vector \eqn{\pi} of stacked model parameters is represented as
\eqn{\pi = h +H \theta} where \eqn{\theta} is a vector of \emph{deep} parameters.)
\item \verb{class=["armamod"|"rmfdmod"|"stspmod"]}: determines whether the template parametrizes
ARMA, RMFD or state space models.
\item \code{order}: an integer vector which contains the dimensions and orders of the model.
For ARMA and RMFD models \code{order = c(m,n,p,q)} and
for state space models \code{order = c(m,n,s)}.
\item \code{n.par}: the number of \emph{free} parameters, i.e. the dimension of the
vector \eqn{\theta}.
\item \code{nu}: This optional slot contains the Kronecker indices \eqn{\nu}.
}

\strong{model2template:}

The function \code{\link[=model2template]{model2template()}} takes an \code{\link[=armamod]{armamod()}}, \code{\link[=rmfdmod]{rmfdmod()}}, or \code{\link[=stspmod]{stspmod()}} object
where the free parameters are coded as \code{NA}'s, \code{NaN}'s or \code{Inf}'s and
constructs a corresponding model template.

For the parametrization of the (left) square root, \eqn{L} say, of the noise covariance \eqn{\Sigma = LL'}
the following choices are possible: In the case \code{sigma_L = "as_given"} the
slot \code{model$sigma_L} of the given \code{model} is used to construct the template: \code{NA} entries
are considered as free and all other entries as fixed. For the choice \code{sigma_L = "chol"}
first all entries of \code{model$sigma_L} above the diagonal are set to zero and then
the template is constructed as above. In the case \code{sigma_L = "symm"}
the matrix  \code{model$sigma_L} is first replaced by a symmetric one and then the template
is constructed (according to the \code{NA}'s) such that the square root \code{L=sigma_L} is always
symmetric. The choice \code{sigma_L = "identity"} sets the matrix \code{L = sigma_L} to the
identity matrix.
Finally, the choice \code{sigma_L = "full_normalized"} sets the diagonal elements equal to ones and all other elements to NAs in \code{L = sigma_L}.

\strong{tmpl_}\emph{:}*

The functions \verb{tmpl_***} implement the following model structures:
\describe{
\item{tmpl_arma_pq}{ARMA models (\code{\link[=armamod]{armamod()}}) with prescribed orders \eqn{(p,q}).}
\item{tmpl_arma_echelon}{ARMA models (\code{\link[=armamod]{armamod()}}) in echelon form, with given
Kronecker indices \eqn{\nu}.}
\item{tmpl_rmfd_pq}{RMFD models (\code{\link[=rmfdmod]{rmfdmod()}}) with prescribed orders \eqn{(p,q}).}
\item{tmpl_rmfd_echelon}{RMFD models (\code{\link[=rmfdmod]{rmfdmod()}}) in echelon form, with
Kronecker indices \eqn{\nu}. Note that for RMFD models the
Kronecker indices refer to the basis of the \emph{column space}
of the Hankel matrix of the impulse response coefficients. }
\item{tmpl_stsp_full}{Fully parametrized state space models (\code{\link[=stspmod]{stspmod()}})
with given state space dimension \eqn{s},
i.e. a models where each entry in the matrices \eqn{A,B,C}
is considered non-fixed.}
\item{tmpl_stsp_echelon}{State space models (\code{\link[=stspmod]{stspmod()}}) in echelon form,
with given Kronecker indices \eqn{\nu}.}
\item{tmpl_state space_ar}{State space model representations (\code{\link[=stspmod]{stspmod()}})
of AR models with given order \eqn{p}.
Here only the "square" case \eqn{m=n} is implemented.}
}

For these model structures the impulse response (transfer function) is scaled such that the
\eqn{(m,n)}-dimensional lag zero coefficient, \eqn{k_0}{k[0]} say, is of the form
\describe{
\item{\eqn{m=n}}{\eqn{k_0}{k[0]} is the \eqn{m}-dimensional identity matrix.}
\item{\eqn{m<n}}{The first \eqn{m} columns of \eqn{k_0}{k[0]} form the
\eqn{m}-dimensional identity matrix and the remaining columns are zero.}
\item{\eqn{m>n}}{The first \eqn{n} rows of \eqn{k_0}{k[0]} form the
\eqn{n}-dimensional identity matrix and the remaining rows are \emph{free}.}
}
For the parametrization of the (left) square root \eqn{L} of the noise covariance \eqn{\Sigma = LL'}
the following choices are possible: For \code{sigma_L="chol"} the matrix \eqn{L} is lower triangular
(all entries on and below the main diagonal are considered as free and the entries above the diagonal are zero).
For \code{sigma_L="symm"} the matrix \eqn{L} is symmetric (all entries on and below the main diagonal are considered
as free and the entries above the diagonal are such that \eqn{L=L'} holds).
For \code{sigma_L="identity"} the matrix \eqn{L} is \emph{fixed} to the \eqn{n}-dimensional identity matrix.
For \code{sigma_L="full_normalized"} the diagonal elements of the matrix \eqn{L} are \emph{fixed} to ones and all other elements are free.
}
\examples{

# ######################################################
# construct a template from a model
# ######################################################

# Let us consider scalar ARMA(5,1) models
# for quarterly data with a strong seasonal component.
# In order to have parsimonious models we want a[2]=a[3]=0:
model = armamod(lmfd(a = c(1,NA,0,0,NA,NA), b = c(1,NA)))
tmpl = model2template(model)

# Let's see how the "free" parameters are mapped to the model parameters
print(cbind(tmpl$h, tmpl$H))
th = -(1:tmpl$n.par)
fill_template(th, tmpl)

# Generate a random model with this structure
th0 = rnorm(tmpl$n.par, sd = 0.1)
model = fill_template(th0, tmpl)

# Extract the "free" parameters from the model
th = extract_theta(model, tmpl)
all.equal(th, th0)

# This model structure fixes sigma_L = 1.
# If we change sigma_L = 2 then the model does not fit to the template.
model$sigma_L = 2
# the default choice on_error = 'ignore', tells
# extract_theta to ignore this misfit:
th = extract_theta(model, tmpl, on_error = 'ignore')
# with on_error = 'warn' we get a warning and
# with on_error = 'stop' would throw an error.
th = extract_theta(model, tmpl, on_error = 'warn')
# We may also "ignore" sigma_L
th = extract_theta(model, tmpl, on_error = 'stop', ignore_sigma_L=TRUE)

# If the orders/class of template and model does not fit
\dontrun{
model = armamod(lmfd(a = c(1,1), b = c(1,1)))
extract_theta(model, tmpl)
model = stspmod(stsp(D = 1))
extract_theta(model, tmpl)
}

# ######################################################
# the parameter "sigma_L"
# ######################################################

# consider a state space model (with 1 state) for a 3-dimensional process
model = stspmod(stsp(A = 1, B = c(1,0,0), C = c(1,1,1), D = diag(3)))

# We may specify an arbitrary structure for the left square root (L = sigma_L)
# of the noise covariance Sigma. Any NA entry is considered as a "free" parameter.
L = matrix(c(0, NA, 1, 0, 2, 3, NA, 1, 1), nrow = 3, ncol = 3)
L
# L has 2 NA entries and thus we get a model structure with 2 free parameters.
model$sigma_L = L

tmpl = model2template(model, sigma_L = 'as_given')
th = -(1:tmpl$n.par)
fill_template(th, tmpl)

# The choice sigma_L = 'chol' forces L to be lower triangular.
# In the case considered here, we get a model structure with 1 free parameter.
tmpl = model2template(model, sigma_L = 'chol')
th = -(1:tmpl$n.par)
fill_template(th, tmpl)

# The choice sigma_L = 'symm' forces L = sigma_L to be symmetric.
# In the case considered here we thus get a model structure with 2 free parameters.
tmpl = model2template(model, sigma_L = 'symm')
th = -(1:tmpl$n.par)
fill_template(th, tmpl)

# The choice sigma_L = 'identity' set L equal to the identity matrix,
# i.e. sigma_L is fixed.
tmpl = model2template(model, sigma_L = 'identity')
th = numeric(0)
fill_template(th, tmpl)
tmpl$n.par # there are no free parameters: tmpl$n.par = 0

# The choice sigma_L = 'full_normalized' sets the diagonal elements of L equal to ones,
# and leaves all other elements free.
tmpl = model2template(model, sigma_L = 'full_normalized')
th = -(1:tmpl$n.par)
fill_template(th, tmpl)


# ######################################################
# ARMA(p,q) models
# ######################################################

m = 2 # output dimension
p = 1 # AR order
q = 1 # MA order

# model structure with lower triangular sigma_L
tmpl = tmpl_arma_pq(m, n = m, p, q, sigma_L = "chol")
th = rnorm(tmpl$n.par)
th = -(1:tmpl$n.par)
fill_template(th, tmpl)

# model structure with symmetric sigma_L
tmpl = tmpl_arma_pq(m, n = m, p, q, sigma_L = "symm")
fill_template(th, tmpl)

# model structure with sigma_L = I
tmpl = tmpl_arma_pq(m, n = m, p, q, sigma_L = "identity")
# here the number of free paramaters is of course (by 3) smaller
# than for the above model structures!
fill_template(th[1:(length(th)-3)], tmpl)


# ######################################################
# RMFD(p,q) models y[t] = d(z) c(z)^-1 e[t]
# ######################################################

m = 2 # output dimension
p = 1 # order of c(z)
q = 1 # order of d(z)

# model structure with lower triangular sigma_L
tmpl = tmpl_rmfd_pq(m, n = m, p, q, sigma_L = "chol")
th = rnorm(tmpl$n.par)
th = -(1:tmpl$n.par)
fill_template(th, tmpl)

# model structure with symmetric sigma_L
tmpl = tmpl_rmfd_pq(m, n = m, p, q, sigma_L = "symm")
fill_template(th, tmpl)

# model structure with sigma_L = I
tmpl = tmpl_rmfd_pq(m, n = m, p, q, sigma_L = "identity")
# here the number of free paramaters is of course (by 3) smaller
# than for the above model structures!
fill_template(th[1:(length(th)-3)], tmpl)


# ######################################################
# state space models in echelon form
# ######################################################
nu = c(3,2,4)   # Kronecker indices
m = length(nu)  # number of outputs/inputs
tmpl = tmpl_stsp_echelon(nu = nu)

# generate a random vector of parameters.
# Note that "tmpl$n.par" contains the number free parameters.
th = rnorm(tmpl$n.par)

# generate a model according to this structure with the parameters th
model = fill_template(th, tmpl)
print(model)

# we can extract the free parameters from this given model
all.equal(th, extract_theta(model, tmpl, on_error = 'stop'))

# check the impulse response
k = impresp(model, lag.max = 2*sum(nu) + 1)

# the lag zero coeffcient k[0] is equal to the identity
all.equal(unclass(k$irf)[,,1], diag(m))

# check the Kronecker indices
all.equal(rationalmatrices::pseries2nu(k$irf), nu)

}
\seealso{
\code{\link[=r_model]{r_model()}}, \code{\link[=fill_template]{fill_template()}}, \code{\link[=ll]{ll()}}, \code{\link[=ll_theta]{ll_theta()}} and other estimation procedures
}
