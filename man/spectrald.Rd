% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/acd_spectrald_methods.R
\name{spectrald}
\alias{spectrald}
\alias{spectrald.armamod}
\alias{spectrald.stspmod}
\alias{spectrald.autocov}
\alias{spectrald.impresp}
\alias{spectrald.default}
\title{Spectral Density}
\usage{
spectrald(obj, n.f, ...)

\method{spectrald}{armamod}(obj, n.f = 128, ...)

\method{spectrald}{stspmod}(obj, n.f = 128, ...)

\method{spectrald}{autocov}(obj, n.f = 128, ...)

\method{spectrald}{impresp}(obj, n.f = 128, ...)

\method{spectrald}{default}(obj, n.f = NULL, demean = TRUE, ...)
}
\arguments{
\item{obj}{\code{\link[=armamod]{armamod()}}, \code{\link[=stspmod]{stspmod()}}, \code{\link[=autocov]{autocov()}},
\code{\link[=impresp]{impresp()}} object or a "time series" object, i.e. an
object which may be coerced to a data matrix by \code{y = as.matrix(obj)}.}

\item{n.f}{number of frequencies.}

\item{...}{not used.}

\item{demean}{(logical) should the data be demeaned before computing the periodogram?}
}
\value{
\code{freqresp} object, i.e. a list with slots
\item{spd}{\code{\link[rationalmatrices:zvalues]{rationalmatrices::zvalues()}} object.}
\item{names}{(m)-dimensional character vector or NULL. This optional slot stores the names
for the components of the time series/process.}
\item{label}{character string or NULL.}
\item{n.obs}{(optional) integer or NULL.}
}
\description{
Compute the spectral density of an ARMA process or a process defined by a state space model.
}
\details{
The spectral density of a stationary process with an absolutely summable
autocovariance function \eqn{(\gamma_j)}{(\gamma[j])} is given by
\deqn{
\Gamma(\lambda) = \frac{1}{2\pi}\sum_{j=-\infty}^{\infty} \gamma_j e^{-i\lambda j}.
}{
\Gamma(\lambda) = (1/2\pi) sum_{j=-\infty}^{\infty} \gamma[j] exp(-i\lambda j).
}

For an ARMA process, or process defined by a state space model the
spectral density is equal to
\deqn{
\Gamma(\lambda) = \frac{1}{2\pi} K(\lambda) \Sigma K^*(\lambda)
}{
\Gamma(\lambda) = (1/2\pi) K(\lambda) \Sigma K^*(\lambda)
}
where \eqn{\Sigma} is the noise covariance, \eqn{K()} is the
frequency response of the model and \eqn{K^*(\lambda)} is the
Hermitean transpose of \eqn{K(\lambda)}.
See also \code{\link[=autocov]{autocov()}} and \code{\link[=freqresp]{freqresp()}}.

Note that \eqn{\Gamma()} is (up to a factor \eqn{2\pi}) the discrete-time Fourier
transform (DTFT) of the autocovariance function and therefore the ACF \eqn{\gamma_j}{\gamma[j]}
may be reconstructed from the spectral density via the inverse DTFT
\deqn{
\gamma_j = \int_{-\pi}^{\pi} \Gamma(\lambda) e^{i\lambda j} d\lambda
}{
\gamma[j] = int_{-\pi}^{\pi} \Gamma(\lambda) e^{i\lambda j} d\lambda
}

The S3 methods \verb{spectrald.*} evaluate the spectral density function
on a grid of angular frequencies \eqn{\lambda_j = 2\pi j/N}{\lambda[j] = 2\pi j/N},
\eqn{j=0,\ldots,N-1}{j=0,\dots,N-1} and store the result
in a \strong{spectrald} object.

There are several possible ways to specify the process. One may provide the ARMA (\code{armamod})
respectively the state space model (\code{stspmod}), the autocovariance function (\code{autocov}) or
the impulse response function (\code{impresp}) which maps the noise to the outputs.
Note however, that if we have only given an \code{autocov} or \code{impresp} object then
the computed spectral density is only an approximation of the true spectral density since
only a finite number of covariances respectively impulse response coefficients are given.
The type of the autocovariance function ("covariances", "correlations" or "partial correlations")
is irrelevenat since the procedure alwayas uses the slot "\code{gamma}" which contains the
covariances.

The default method \code{spectrald.default} assumes that \code{obj} is a "time series" object and
tries to coerce this object to a data matrix via \code{y = as.matrix(obj)}. In this case the
procedure computes the \emph{periodogram} which is a simple estimate of the spectral density.
The periodgram may also be computed by the call \code{spectrald(autocov(obj, max.lag = n.obs-1))},
i.e. by first computing the sample auto covariance function and then computing the corresponding
spectral density.

Note that we use a different scaling than the \verb{stats::[spectrum][stats::spectrum]} routine.
}
\examples{
#' ### generate random 3-dimensional ARMA(1,1) model
# "bpoles = 1.1" implies that the poles have moduli larger than 1.1
# and therefore the impulse response coefficients decay with a rate (1.1)^k
arma_model = test_armamod(dim = c(3,3), degrees = c(1,1), bpoles = 1.1)

# spectral density
spd = spectrald(arma_model)

# compute the spectral density via the impulse response
spd1 = spectrald(impresp(arma_model, lag.max = 100))

# since the impulse response quickly decays
# the "truncated" spectral density should be close to the true one
all.equal(spd, spd1)

# compute the spectral density via the autocovariance function
spd1 = spectrald(autocov(arma_model, lag.max = 100))

# since the ACF quickly decays
# the "truncated" spectral density should be close to the true one
all.equal(spd, spd1)

# create an equivalent state space model
stsp_model = as.stspmod(arma_model)

# of course the state space model gives the same spectrum
# as the original ARMA model
spd1 = spectrald(stsp_model)
all.equal(spd, spd1)

}
