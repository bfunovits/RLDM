% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/04_timeseries_solve.R
\name{solve_de}
\alias{solve_de}
\alias{solve_de.stsp}
\alias{solve_de.lmfd}
\alias{solve_de.rmfd}
\alias{solve_inverse_de}
\alias{solve_inverse_de.stsp}
\alias{solve_inverse_de.lmfd}
\alias{solve_inverse_de.rmfd}
\title{Solve (linear) Difference Equations}
\usage{
solve_de(sys, u, ...)

\method{solve_de}{stsp}(sys, u, a1 = NULL, ...)

\method{solve_de}{lmfd}(sys, u, u0 = NULL, y0 = NULL, ...)

\method{solve_de}{rmfd}(sys, u, u0 = NULL, y0 = NULL, ...)

solve_inverse_de(sys, y, ...)

\method{solve_inverse_de}{stsp}(sys, y, a1 = NULL, ...)

\method{solve_inverse_de}{lmfd}(sys, y, u0 = NULL, y0 = NULL, ...)

\method{solve_inverse_de}{rmfd}(sys, y, u0 = NULL, y0 = NULL, ...)
}
\arguments{
\item{sys}{\code{\link[rationalmatrices:lmfd]{rationalmatrices::lmfd()}} or \code{\link[rationalmatrices:stsp]{rationalmatrices::stsp()}} object
which describes the difference equation.}

\item{u}{\eqn{(N,n)} matrix with the noise (\eqn{u_t}{u[t]}, \eqn{t=1,...,N}).}

\item{...}{not used.}

\item{a1}{\eqn{m} dimensional vector with the initial state \eqn{a_1}{a[1]}.
If \code{a1=NULL} then a zero vector is used.}

\item{u0}{\eqn{(h,n)} dimensional matrix with starting values
for the disturbances \eqn{(u_{1-h}, \ldots, u_{-1}, u_0)}{(u[1-h], ..., u[-1], u[0])}.
Note that the last row corresponds to \eqn{u_0}{u[0]}, the last but one row
to \eqn{u_{-1}}{u[-1]} and so on. If \eqn{h>q} then only the last \eqn{q} rows of
\code{u0} are used. In the case \eqn{h<q} the "missing" initial values are set
to zero vectors. \cr
The default value \code{u0=NULL} sets all initial values \eqn{u_t}{u[t]}, \eqn{t \leq 0}{t \le 0}
equal to zero vectors.}

\item{y0}{\eqn{(h,m)} dimensional matrix with starting values
for the outputs \eqn{(y_{1-h}, \ldots, y_{-1}, y_0)}{(y[1-h], ..., y[-1], y[0])}.
This (optional) parameter is interpreted analogously to \code{u0}.}

\item{y}{\eqn{(N,m)} matrix with the outputs (\eqn{y_t}{y[t]}, \eqn{t=1,...,N}).}
}
\value{
List with slots
\item{y}{\eqn{(N,n)} matrix with the (computed) outputs.}
\item{u}{\eqn{(N,n)} matrix with the (computed) noise.}
\item{a}{\eqn{(N+1,n)} matrix with the (computed) states (\eqn{a_t}{a[t]}, \eqn{t=1,...,N+1}).
Note that this matrix has (\eqn{N+1}) rows! This slot is only present for state space models.}
}
\description{
The procedure \code{solve_de()} solves the difference equations associated to (V)ARMA models
\deqn{a_0 y_t + a_1 y_{t-1} + \cdots + a_p y_{t-p} = b_0 u_t  + b_1 u_{t-1} + ... b_1 u_{t-q}}{
      a[0] y[t] + a[1] y[t-1] + ... + a[p] y[t-p] = b[0] u[t]  + b[1] u[t-1] + ... b[q] u[t-q]}
or state space models
\deqn{a_{t+1} = A a_t + B u_t \mbox{ and } y_t = C a_t + D u_t.}{
      a[t+1] = A a[t] + B u[t] and y[t] = C a[t] + D u[t].}
}
\details{
\code{solve_de()} computes the outputs \eqn{y_t}{y[t]} for \eqn{t=1,\ldots,N}{t=1,...,N} for
given disturbances \eqn{u_t}{u[t]} \eqn{t=1,\ldots,N}{t=1,...,N}.
The starting values  (\eqn{u_t}{u[t]} and \eqn{y_t}{y[t]} for \eqn{t\leq 0}{t \le 0} for VARMA models
and \eqn{a_1}{a[1]} for state space models) may be given as optional arguments.
The default is to use zero vectors.

For the reverse direction, i.e. to reconstruct the disturbances if the outputs are given,
the function \code{solve_inverse_de} may be used. In this case the system must be square and
the matrix \eqn{D} respectively \eqn{b_0}{b[0]} must be invertible.

These functions are mainly intended for internal use and hence only some basic checks
on the input parameters are performed.
}
\examples{

### generate a random ARMA(2,1) model (with two outputs) #########
model = test_armamod(dim = c(2,2), degrees = c(2,1),
                     digits = 2, bpoles = 1, bzeroes = 1)

# generate random noise sequence (sample size N = 100)
u = matrix(rnorm(100*2), nrow = 100, ncol = 2)

# generate random initial values
u0 = matrix(rnorm(2), nrow = 1, ncol = 2) # u[0]
y0 = matrix(rnorm(2), nrow = 1, ncol = 2) # y[0]

# compute outputs "y[t]"
# note that y0 has only one row, thus y[-1] is set to zero!
data = solve_de(model$sys, u = u, y0 = y0, u0 = u0)

# we can reconstruct the noise "u" from given outputs "y"
data1 = solve_inverse_de(model$sys, y = data$y, u0 = u0, y0 = y0)
all.equal(data$u, data1$u)

### generate a random state space model (3 outputs and 4 states) ##
model = test_stspmod(dim = c(3,3), s = 4,
                     digits = 2, bpoles = 1, bzeroes = 1)

# generate random noise sequence (sample size N = 100)
u = matrix(rnorm(100*3), nrow = 100, ncol = 3)

# generate random initial state a[1]
a1 = rnorm(4)

# compute outputs "y[t]"
data = solve_de(model$sys, u = u, a1 = a1)

# we can reconstruct the noise "u" from given outputs "y"
data1 = solve_inverse_de(model$sys, y = data$y, a1 = data$a[1,])
all.equal(data$u, data1$u)

}
