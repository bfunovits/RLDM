% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{cll_theta_ARMA_cpp}
\alias{cll_theta_ARMA_cpp}
\title{Compute the (concentrated) conditional log likelihood for ARMA models
described by a model template.}
\usage{
cll_theta_ARMA_cpp(
  th,
  y,
  skip,
  concentrated,
  ib0,
  H_b,
  h_b,
  B1,
  H_B,
  h_B,
  a0,
  A,
  H_A,
  h_A,
  L,
  H_L,
  h_L,
  u,
  dU
)
}
\arguments{
\item{th}{\eqn{(K)} dimensional vector of "deep" parameters.}

\item{y}{\eqn{(m,N)} matrix with the observed outputs:
\eqn{(y_1,y_2,\ldots,y_N)}{(y[1],y[2],...,y[N])}.}

\item{skip}{(integer), omit the first "skip" residuals, when computing the likelihood.}

\item{concentrated}{(bool), if TRUE then the \emph{concentrated}, conditional log Likelihood is computed}

\item{ib0}{\eqn{(m, m)} matrix, is \strong{overwritten} with the matrix \eqn{b_0^{-1}a_0}{b[0]^(-1)a[0]}.}

\item{H_b}{\eqn{(m^2, K)} matrix.}

\item{h_b}{\eqn{((m^2)}-dimensional vector. Note that
\code{vec(b[0]) = H_b*th + h_b}.}

\item{B1}{\eqn{(m, mq)} matrix, is \strong{overwritten} with
\eqn{-b_0^{-1}(b_q,...,b_1)}{-b[0]^(-1)(b[q],...,b[1])}.}

\item{H_B}{\eqn{((m^2)*q, K)} matrix.}

\item{h_B}{\eqn{((m^2)*q)}-dimensional vector. Note that
\code{vec(-(b[q],...,b[1])) = H_B*th + h_B}.}

\item{a0}{\eqn{(m, m)} matrix, is \strong{overwritten} with
\eqn{a_0}{a[0]}.}

\item{A}{\eqn{(m, m(q+1))} matrix, is \strong{overwritten} with
\eqn{b_0^{-1}(a_0,...,a_p}{b[0]^(-1)(a[0],...,a[p])}.}

\item{H_A}{\eqn{((m^2)*(p+1), K)} matrix.}

\item{h_A}{\eqn{((m^2)*(p+1))}-dimensional vector. Note that
\code{vec((a[0],a[1],...,a[p])) = H_A*th + h_A}.}

\item{L}{\eqn{(m,m)} matrix. If (concentrated==FALSE) then \code{L} is \strong{overwritten} with
the left square \eqn{L} of the noise covariance matrix \eqn{\Sigma=LL'} corresponding
to the deep parameters th. However, if (concentrated==TRUE) then
L is \strong{overwritten} with sample covariance matrix of the computed residuals!}

\item{H_L}{\eqn{(m^2, K)} matrix.}

\item{h_L}{\eqn{(m^2)}-dimensional vector. Note that
\code{vec(L) = H_L*th + h_L}.}

\item{u}{\eqn{(m,N)} matrix. This matrix is \strong{overwritten} with (computed) residuals:
\eqn{(u_1,u_2,\ldots,u_N)}{(u[1],u[2],...,u[N])}.}

\item{dU}{\eqn{(mN,(m^2)(p+q+2))} matrix or \eqn{(0,0)} matrix. If non empty this
matrix is \strong{overwritten} with the
directional derivatives of the residuals. However, if
the matrix is empty then no derivatives are computed.}
}
\value{
(double) log Likelihood
}
\description{
This internal helper function computes the (concentrated) conditional log Likelihood
of ARMA systems of the form
\deqn{a_0 y_t + a_1 y_{t-1} + \cdots + a_p y_{t-p} = b_0 u_t + \cdots + b_q u_{t-q}}{
      a[0] y[t] + a[1] y[t-1] + ... + a[p] y[t-p] = b[0] u[t] + ... + b[q] u[t-q]}
The conditional likelihood is computed for \strong{zero} initial values \eqn{u_s=y_s=0}{u[s]=y[s]=0} for
\eqn{s\leq 0}{s\le 0}.
}
\details{
This function is mainly used by the function factory \code{\link{ll_FUN}}. For a more detailed
documentation of the (concentrated) conditional log Likelihood, see \code{\link{ll}}.

The procedure first constructs the ARMA parameter matrices from the given vector
\code{th} of "deep" parameters.

\itemize{
\item  AR parameters \code{vec((a[0],a[1],...,a[p])) = h_A + H_A * th}.
\item  MA parameters \code{vec(b[0]) = h_b + H_b * th} and
\code{vec(-(b[q],...,b[1])) = h_B + H_B * th}
\item  Left square root of noise covariance matrix
\eqn{\Sigma = LL'} and \code{vec(L) = h_L + H_L * th}.
}

The residuals (and their directional derivatives) are computed with
\code{\link{residuals_ARMA_cpp}}.
}
\note{
Use this procedure with care!
\itemize{
\item The procedure does \bold{not} check the input arguments.
\item The procedure \bold{overwrites} some of the input arguments
\item The data matrices are organized columnwise (to avoid memory shuffling)!
\item Note also the non standard representation of the coefficient matrices.
}
}
\seealso{
\code{\link{outputs_ARMA_cpp}}, \code{\link{residuals_ARMA_cpp}},  \code{\link{cll_theta_ARMA_cpp}},
\code{\link{outputs_STSP_cpp}}, \code{\link{residuals_STSP_cpp}},  \code{\link{cll_theta_STSP_cpp}} and
\code{\link{solve_de}}, \code{\link{solve_inverse_de}} and \code{\link{ll}}.
}
