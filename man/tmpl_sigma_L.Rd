% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ab_templates.R
\name{tmpl_sigma_L}
\alias{tmpl_sigma_L}
\title{sigma_L Structure}
\usage{
tmpl_sigma_L(
  sigma_L,
  structure = c("as_given", "chol", "symm", "identity", "full_normalized")
)
}
\arguments{
\item{sigma_L}{numeric (n x n) matrix, where the free entries are coded with NAs}

\item{structure}{character string, determines the "structure" of sigma_L, see the examples.}
}
\value{
List with slots
\itemize{
\item \code{h} (\eqn{n^2}-dimensional vector),
\item \code{H} (\eqn{(n^2, k)}-dimensional matrix, where \eqn{k} denotes the number of  free/deep parameters) and
\item \code{n.par} (integer) is the number of free/deep parameters (\eqn{=k}).
}
}
\description{
Create templates for the left square root \eqn{L} of the noise covariance
matrix \eqn{\Sigma = LL'}. This means that \eqn{L} is parametrized as
\deqn{\mbox{vec}(L) = h + H \theta}{vec(L) = h + H \theta} with a
(\eqn{k}-dimensional) parameter vector \eqn{\theta}.
}
\details{
The parameter \code{structure} has the following meaning
\describe{
\item{as_given}{Use the given parameter \code{sigma_L} to construct the template:
\code{NA} entries are considered as free and all other entries as fixed.}
\item{chol}{Set all entries of \code{sigma_L} above the diagonal to zero and then proceed as above.}
\item{symm}{First make \code{sigma_L} symmetric (\code{sigma_L = (sigma_L + t(sigma_L))/2}) and then use this \code{sigma_L} as template.
However, \code{h}, \code{H} are constructed such that \eqn{h + H\theta} gives a symmetric matrix!
Note that NAs overwrite fixed values, see examples.}
\item{identity}{Use the identity matrix as template. In this case there are no free parameters, i.e. \eqn{\theta} is an empty vector (vector with zero length).}
\item{full_normalized}{Ones on the diagonal, otherwise all parameters are free.} }
}
\examples{
sigma_L = matrix(c(0, NA, 1, 0, 2, 3, NA, 1, 1), nrow = 3, ncol = 3)
sigma_L

tmpl = tmpl_sigma_L(sigma_L, structure = 'as_given')
th = -(1:tmpl$n.par)
matrix(tmpl$h + tmpl$H \%*\% th, nrow = 3, ncol = 3)

tmpl = tmpl_sigma_L(sigma_L, structure = 'chol')
th = -(1:tmpl$n.par)
matrix(tmpl$h + tmpl$H \%*\% th, nrow = 3, ncol = 3)

tmpl = tmpl_sigma_L(sigma_L, structure = 'symm')
th = -(1:tmpl$n.par)
matrix(tmpl$h + tmpl$H \%*\% th, nrow = 3, ncol = 3)

tmpl = tmpl_sigma_L(sigma_L, structure = 'identity')
tmpl$n.par # = 0
matrix(tmpl$h, nrow = 3, ncol = 3)

tmpl = tmpl_sigma_L(sigma_L, structure = 'full_normalized')
th = -(1:tmpl$n.par)
matrix(tmpl$h + tmpl$H \%*\% th, nrow = 3, ncol = 3)

}
