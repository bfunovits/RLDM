% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/afac_estimate_mom_ststp_subspace.R
\name{subspace helpers}
\alias{subspace helpers}
\alias{est_stsp_aoki}
\alias{est_stsp_cca}
\alias{est_stsp_cca_sample}
\title{Subspace Helper Methods}
\usage{
est_stsp_aoki(
  gamma,
  s.max,
  p,
  estorder = estorder_SVC,
  keep_models = FALSE,
  n.obs = NULL,
  ...
)

est_stsp_cca(
  gamma,
  s.max,
  p,
  estorder = estorder_SVC,
  keep_models = FALSE,
  n.obs = NULL,
  ...
)

est_stsp_cca_sample(
  y,
  s.max,
  p,
  estorder = estorder_SVC,
  keep_models = FALSE,
  mean_estimate = c("sample.mean", "zero"),
  ...
)
}
\arguments{
\item{gamma}{\eqn{(m,m,L+1)}-dimensional array with the (sample) autocovariance function.}

\item{s.max}{(integer) maximum possible order.}

\item{p}{(integer) number of block columns of the Hankel matrix (size of the "past")}

\item{estorder}{function, to estimate the order of the system.}

\item{keep_models}{(boolean) should the function return a list with estimated system of
order \code{0:s.max}?}

\item{n.obs}{sample size \eqn{N}.}

\item{...}{additional parameters, passed on to the order estimation routine.}

\item{y}{\eqn{(N,m)}-dimensional matrix or an object, which may be coerced to
a matrix with \code{as.matrix{y}}.}

\item{mean_estimate}{Character string giving the method used to estimate
the mean \eqn{\mu = E y_t}{\mu = E y[t]}.
Default is to use the sample mean.}
}
\value{
List with slots:
\item{model}{a \code{\link[=stsp]{stsp()}} object, which represents the estimated state space model.}
\item{models}{either \code{NULL} (if \code{!keep_models}) or a list with the parameters
of the estimated models with orders (\code{s=0:s.max+1}). This slot may e.g. be
used to estimate the model order by some user defined model selection procedure.}
\item{s}{(integer) the estimate of the model order.}
\item{info}{list with information about the data and the design parameters of the estimation procedure.}
\item{stats}{((s.max+1)-by-5)-dimensional matrix with statistics of the (estimated) state space models.}
}
\description{
These procedure implement two subspace algorithms for the estimation of state space models,
the \emph{AOKI} method, as described in \insertCite{Aoki90}{RLDM} and the \emph{CCA} algorithm
(see e.g. \insertCite{DahlenScherrer2004}{RLDM} or \insertCite{Bauer2001}{RLDM}).
These subspace algorithms center on the weighted Hankel matrix
\deqn{(R_f')^{-T} H_{fp} R_p^{-1}}{(Rf')^{-1} H Rp^{-1}}
where the block \emph{Hankel} matrix \eqn{H_{fp}}{H} is the covariance between the
"past" \eqn{(y_{t-1}',\cdots,y_{t-p}')'}{(y[t-1]',...,y[t-p]')'} and the
"future" \eqn{(y_{t}',\cdots,y_{t+f-1}')'}{(y[t]',...,y[t+f-1]')'} and
\eqn{R_f}{Rf} and \eqn{R_p}{Rp} are the cholesky factors of the covariance matrices
of the "future" and the "past" respectively. The singular values of this weighted Hankel matrix
are the canonical correlation coefficients between the past and the future.
Note that the implementation here always sets \eqn{f = p+1}.
}
\details{
AOKIs method is a \emph{realization} algorithm, i.e. it reconstructs the underlying state space
model from the (population) autocovariance function. To this end a Riccati equation has to be solved,
see \code{\link[=riccati]{riccati()}}.
If an estimated ACF is fed into this algorithm one obtains an estimate for the
state space model. However note that this may fail (in particular the Riccati
equation may have no positive definite solution) if the estimate of the ACF is \emph{not} positive
definite, if the Hankel matrix is too small or if state dimension is not correct.

The CCA method estimates the state space model by first constructing an estimate of the states.
Then the parameter matrices are estimated via simple LS regressions. This procedure does
not give the "true" model, even in the case when the population ACF is used. However,
the "distance" between the true model
and the estimated model converges to zero,
if the estimate of the ACF converges to the population ACF and
the size \eqn{p} of the Hankel matrix converges to infinity.

There are two implementations of the CCA method:
\enumerate{
\item The routine \code{\link[=est_stsp_cca_sample]{est_stsp_cca_sample()}}
operates directly on the supplied data.
\item The routine \code{\link[=est_stsp_cca]{est_stsp_cca()}} uses an (estimated) autocovariance function.
}

These algorithms may also be used as simple "model reduction algorithms". If we want to
approximate a high dimensional state space model by a model of lower order, we may proceed
as follows. First we compute the ACF of the high dimensional model and then fed
this ACF into the subspace routines \code{est_stsp_cca} or \code{est_stsp_aoki},
however setting the maximum order \code{s.max} to some value less than the true order.

\strong{Order Estimation}

The order estimation is based on the Hankel singular values \eqn{\sigma_s}{\sigma[s]} and/or the
log det values of the estimated noise covariance matrices \eqn{\ln\det \hat{\Sigma}_s}{ln det \Sigma[s]}.
Using only the Hankel singular values has the advantage that only \emph{one} model has to be estimated,
whereas otherwise estimates for \emph{all} models with orders \eqn{s=0,\ldots,s_{\max}}{s=0,dots,s[max]}
have to be computed.

In order to exploit this (small) advantage of singular values based criteria the
order estimation runs as follows:
First the procedures call
\cr
\code{ estorder(s.max, Hsv, n.par, m, n.obs, Hsize=c(f,p), ...)}
\cr
Here \code{Hsv} is an \eqn{pm} dimensional vector with the Hankel singular values and
\code{n.par} is an \eqn{(s_{\max}+1)}{(s[max]+1)} dimensional vector with the respective number of
parameters of the models with orders \eqn{s=0,\ldots,s_{\max}}{s=0,dots,s[max]}.
If this call returns an estimate of the order then the procedures estimate a
corresonding state space model.

If this call fails (i.e returns \code{NULL}) then the procedures estimate
all models with orders up to \eqn{s_{\max}}{s[max]} and the corresponding
noise covariance matrices. The order then is estimated by calling
\cr
\code{ estorder(s.max = s.max, Hsv, lndetSigma, n.par, m, n.obs, Hsize, ...)}
\cr
where \code{lndetSigma} is the vector with the log det values of the estimated
noise covariance matrices (\eqn{\ln\det \hat{\Sigma}_s}{ln det \Sigma[s]}).

The package offers some predefined order selection procedures
(see also \link{subspace order estimates}):

\code{estorder_max(s.max, ...)} simply returns the maximum order \code{s.max} considered.

\code{estorder_rkH(s.max, Hsv, tol, ...)} estimates the order by an estimate
of the rank of the Hankel matrix.

\code{estorder_MOE(s.max, Hsv, ...)} estimates the order by searching
for a "gap" in the singular values.

\code{estorder_SVC(s.max, Hsv, n.par, n.obs, Hsize, penalty, ...)}
implements the so called \emph{Singular Value Criteria}, see \insertCite{Bauer2001}{RLDM}:
\deqn{svc(s) = \sigma_{s+1}^2 + c(N)d(s)/N}{svc(s)=\sigma[s+1]^2 + c(N)d(s)/N}
Here \eqn{\sigma_s}{\sigma[s]} is the \eqn{s}-th
singular value of the weighted Hankel marix, \eqn{N} is the sample size,
\eqn{d(s) = 2ms} denotes the number of parameters for a state space
model with \eqn{s} states (and \eqn{m} outputs) and \eqn{c(N)}) is a "penalty"
(depending on the sample size).

The above order estimation procedures only use the Hankel singular values, whereas
the following procedure is based on the estimated noise covariances.

\code{estorder_IVC(s.max, lndetSigma, n.par, n.obs, penalty, ...)} estimates the order
via an information criterion of the form
\deqn{ivc(s) = \ln\det\hat\Sigma_{s} + c(N)d(s)/N}{ivc(s)=ln det \Sigma[s] + c(N)d(s)/N}
where \eqn{\hat\Sigma_s}{\Sigma[s]} is the estimate of the noise covariace matrix
obtained from a model with order \eqn{s}, \eqn{d(s)} denotes the number of parameters
and \eqn{c(N)} is a "penalty" (depending on the sample size).

For both \code{estorder_SVC} and \code{estorder_IVC} the (optional) parameter
\code{penalty} controls the penalty term \eqn{c(N)}.

Note also that for  \code{keep_models==TRUE} the estimation procedures compute \emph{all}
models even in the case of a Hankel singular value based selection criterion.
}
\references{
\insertRef{Bauer2001}{RLDM}
}
