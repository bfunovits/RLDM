% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/03_properties_frequency.R
\name{freqresp}
\alias{freqresp}
\alias{freqresp.armamod}
\alias{freqresp.stspmod}
\alias{freqresp.impresp}
\title{Frequency Response Function}
\usage{
freqresp(obj, n.f, ...)

\method{freqresp}{armamod}(obj, n.f = 128, ...)

\method{freqresp}{stspmod}(obj, n.f = 128, ...)

\method{freqresp}{impresp}(obj, n.f = 128, ...)
}
\arguments{
\item{obj}{\code{\link[=armamod]{armamod()}}, \code{\link[=stspmod]{stspmod()}} or \code{\link[=impresp]{impresp()}} object. Note that
for an impulse response object the result is only an approximation
of the "true" frequency response due to the finite number of coefficients.}

\item{n.f}{number of frequencies.}

\item{...}{not used.}
}
\value{
\code{freqresp} object, i.e. a list with slots
\item{frr}{\code{\link[rationalmatrices:zvalues]{rationalmatrices::zvalues()}} object.}
\item{sigma_L}{(n,n)-dimensional matrix which contains a left square root
of the noise covariance matrix \eqn{\Sigma}.}
\item{names}{(m)-dimensional character vector or NULL. This optional slot stores the names
for the components of the time series/process.}
\item{label}{character string or NULL.}
}
\description{
Compute the \emph{frequency response function} (also called \emph{transfer function}) associated
to a VARMA or state space model.
}
\details{
The frequency response function (or transfer function) associated
to an ARMA or state space model is
\deqn{
K(\lambda) = \sum_{j=0}^{\infty} k_j e^{-i\lambda j}
}{
K(\lambda) = sum_{j=0}^{\infty} k[j] exp(-i\lambda j)
}
where \eqn{(k_j \,|\, j\geq 0)}{(k[j], j \ge 0)} is the \emph{impulse response} of the model.
See also \code{\link[=impresp]{impresp()}}.

For an ARMA model the frequency response is equal to
\deqn{
K(\lambda) =
(a_0 + a_1 e^{-i\lambda} + \cdots + a_p e^{-i\lambda p})^{-1}
(b_0 + b_1 e^{-i\lambda} + \cdots + b_q e^{-i\lambda q})
}{
K(\lambda) =
(a[0] + a[1] exp(-i\lambda) + \dots + a[p] exp(-i\lambda p))^{-1}
(b[0] + b[1] exp(-i\lambda) + \dots + b[q] exp(-i\lambda q))
}
and for a state space model we have
\deqn{
K(\lambda) = C(e^{i\lambda}I_s - A)^{-1}B+D
}{
K(\lambda) = C(exp(i\lambda) I - A)^{-1} B + D
}
Note that \eqn{K()} is the discrete-time Fourier transform (DTFT) of the impulse response.
If the impulse response is absolutely summable then the coefficents \eqn{k_j}{k[j]}
may be reconstructed from the frequency response via the inverse DTFT
\deqn{
k_j = \frac{1}{2\pi} \int_{-\pi}^{\pi} K(\lambda) e^{i\lambda j} d\lambda
}{
k[j] = (1/2\pi) int_{-\pi}^{\pi} K(\lambda) e^{i\lambda j} d\lambda
}

The S3 methods \verb{freqresp.*} evaluate the function on a grid of angular
frequencies \eqn{\lambda_j = 2\pi j/N}{\lambda[j] = 2\pi j/N}, \eqn{j=0,\ldots,N-1}{j=0,\dots,N-1}
and store the result (together with \code{sigma_L}) in a \strong{freqresp} object.
}
\examples{
set.seed(3451) # set seed in order to get reproducible results

### generate random bivariate ARMA(1,1) model
# "bpoles = 1.1" implies that the poles have moduli larger than 1.1
# and therefore the impulse response coefficients decay with a rate (1.1)^k
arma_model = test_armamod(dim = c(2,2), degrees = c(1,1), bpoles = 1.1)
# frequency response
frr = freqresp(arma_model)
# compute the frequency response via the impulse response
irf = impresp(arma_model, lag.max = 100)
frr1 = freqresp(irf)
# since the impulse response quickly decays
# the "truncated" frequency response should be close to the true frequency response
all.equal(frr, frr1)
# create an equivalent state space model
stsp_model = as.stspmod(arma_model)
# of course the state space model has the same frequency response
# as the original ARMA model
frr1 = freqresp(stsp_model)
all.equal(frr, frr1)

# we can also reconstruct the impulse response from the
# frequency response, provided the frequency grid is "fine enough"
n.f = 2^6
frr = freqresp(arma_model, n.f = n.f)
# compute the impulse response via the inverse DTFT
K = unclass(frr$frr)
k1 = Re(apply(K, MARGIN = c(1,2), FUN = fft, inverse = TRUE)) / n.f
k1 = aperm(k1, c(2,3,1))
# impulse response
irf = impresp(arma_model, lag.max = n.f-1)
k = unclass(irf$irf)
# compare
all.equal(k, k1)

set.seed(NULL) # reset seed
}
