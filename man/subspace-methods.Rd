% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/05_estimation_subspace.R
\name{subspace methods}
\alias{subspace methods}
\alias{est_stsp_ss}
\alias{CCA}
\alias{MEST}
\alias{AOKI}
\title{Estimate State Space Models with Subspace Methods}
\usage{
est_stsp_ss(
  obj,
  method = c("cca", "aoki"),
  s.max = NULL,
  p = NULL,
  p.ar.max = NULL,
  p.factor = 2,
  extend_acf = FALSE,
  sample2acf = TRUE,
  estorder = estorder_SVC,
  keep_models = FALSE,
  mean_estimate = c("sample.mean", "zero"),
  n.obs = NULL,
  ...
)
}
\arguments{
\item{obj}{Either a "time series" object (i.e \code{as.matrix(obj)}
returns an \eqn{(N,m)}-dimensional numeric matrix)
or an \code{\link[=autocov]{autocov()}} object (with \eqn{L} lags)
which represents an (estimated) autocovariance function.
The type of the \code{autocov} object is irrelevant since \code{est_stsp_ss} always uses the
slot \code{obj$gamma} which contains the autocovariance function.}

\item{method}{Character string giving the method used to fit the model.}

\item{s.max}{(integer) maximum order of the state space model. If \code{NULL} a default value
is chosen based on the sample size \eqn{N}, respectively based on the number of lags
\eqn{L} of the ACF.}

\item{p}{(integer) number of block columns of the Hankel matrix (size of the "past"). If \code{NULL}
then \code{p} is chosen by fitting a "long" AR model.}

\item{p.ar.max}{(integer) maximum order of the "long" AR model. If \code{NULL} a default choice is made.
This parameter is only needed in the case \code{p=NULL}.}

\item{p.factor}{(integer) If \code{p=NULL}, then the number of block columns of the
Hankel matrix is set to \eqn{p = p_f\hat{p}_{AIC}}{p = p[f]phat} where
\eqn{p_f}{p[f]} is this parameter \code{p.factor} and
\eqn{\hat{p}_{AIC}}{phat} is
the (AIC) estimate of the order of the "long" AR model. See also \code{\link[=est_ar]{est_ar()}}.}

\item{extend_acf}{(boolean) If TRUE then the ACF is extended via an AR(p) model (MEST).}

\item{sample2acf}{(boolean) If \code{obj} is a data object and \code{sample2acf} is TRUE,
then first the sample autocovariance function is computed and then used for the actual computations.}

\item{estorder}{function, used to select the order of the state space model.}

\item{keep_models}{(boolean) should the function return a list with estimated system of order 0:s.max?}

\item{mean_estimate}{Character string giving the method used to estimate the mean
\eqn{\mu = E y_t}{\mu = E y[t]}.
Default is to use the sample mean. See the details below.}

\item{n.obs}{Optional integer which gives the sample size \eqn{N}. This parameter is only used,
when \code{obj} is an \code{\link[=autocov]{autocov()}} object. If \code{n.obs=NULL} then the
slot \code{obj$n.obs} is used. Note that \code{obj$n.obs=NULL} or \code{obj$n.obs=Inf}
refers to the case of a population autocovariance function,
i.e. \eqn{N=\infty}. For a "time series" object the sample size is of course set to
the number of observations, i.e. \code{n.obs = nrow(as.matrix(obj))}.
The sample size \eqn{N} controls the computation of the default (maximum) orders
and the estimation of the order of the state space model.}

\item{...}{additional parameters, passed on to the order estimation routine.}
}
\value{
list with slots
\item{model}{a \code{\link[=stsp]{stsp()}} object, which represents the estimated state space model.}
\item{models}{either \code{NULL} (if \code{!keep_models}) or a list with the parameters
of the estimated models with orders (\code{s=0:s.max+1}). This slot may e.g. be
used to estimate the model order by some user defined model selection procedure.}
\item{s}{(integer) the estimate of the model order.}
\item{info}{list with information about the data and the design parameters of the estimation procedure.}
\item{stats}{((s.max+1)-by-5)-dimensional matrix with statistics of the (estimated) state space models.}
\item{y.mean}{estimate of the mean \eqn{\mu}.}
}
\description{
Estimate (respectively construct) a state space model from a given sample or a given
(sample) autocovariance function.
}
\details{
The procedure implements three subspace algorithms for the estimation of state space models,
the \emph{AOKI} method, as described in \insertCite{Aoki90}{RLDM} and the \emph{CCA}
and \emph{MEST} algorithms
(see e.g. \insertCite{DahlenScherrer2004}{RLDM}). All three algorithms center on the
weighted Hankel matrix
\deqn{(R_f')^{-T} H_{fp} R_p^{-1}}{(Rf')^{-1} H Rp^{-1}}
where the block \emph{Hankel} matrix \eqn{H_{fp}}{H} is the covariance between the
"past" \eqn{(y_{t-1}',\cdots,y_{t-p}')'}{(y[t-1]',...,y[t-p]')'} and the
"future" \eqn{(y_{t}',\cdots,y_{t+f-1}')'}{(y[t]',...,y[t+f-1]')'} and
\eqn{R_f}{Rf} and \eqn{R_p}{Rp} are the cholesky factors of the covariance matrices
of the "future" and the "past" respectively. The singular values of this weighted Hankel matrix
are the canonical correlation coefficients between the past and the future.
Note that the implementation here always sets \eqn{f = p+1}.

AOKIs method is a \emph{realization} algorithm, i.e. it reconstructs the underlying state space
model from the (population) autocovariance function. To this end a Riccati equation has to be solved,
see \code{\link[=riccati]{riccati()}}.
If an estimated ACF is fed into this algorithm one obtains an estimate for the
state space model. However note that this may fail (in particular the Riccati
equation may have no positive definite solution) if the estimate of the ACF is \emph{not} positive
definite, if the Hankel matrix is too small or if state dimension is not correct.

The CCA method estimates the state space model by first constructing an estimate of the states.
Then the parameter matrices are estimated via simple LS regressions. This procedure does
not give the "true" model, even in the case when the population ACF is used. However,
the "distance" between the true model
and the estimated model converges to zero,
if the estimate of the ACF converges to the population ACF and
the size \eqn{p} of the Hankel matrix converges to infinity.

There are two implementations of the CCA method:
\enumerate{
\item If \code{obj} is a "time series" object and
\code{sample2acf==FALSE} then the helper function
\code{\link[=est_stsp_cca_sample]{est_stsp_cca_sample()}} is called. This implementation
of CCA operates directly on the supplied data.
\item If \code{obj} is an \code{\link[=autocov]{autocov()}} object or
when \code{obj} is a "time series" object and
\code{sample2acf==TRUE} then the helper function \code{\link[=est_stsp_cca]{est_stsp_cca()}}
is called. This implementation uses an (estimated) autocovariance function.
For a time series object, first the sample
autocovariance function is computed and then fed into the helper function.
}

The key idea of the MEST algorithm is to first estimate a "long" AR model, convert this
AR model to a state space model and then to use a "balancing and truncation" method to obtain the
final estimate of the state space model. This scheme may be obtained by
calling \code{est_stsp_ss} with the option \code{extend_acf=TRUE}: This option
instructs the procedure to first estimate an AR(p) model and then to use this model
to "extend" the ACF, i.e.
to compute the values of the ACF for lags \eqn{p+1,\ldots,2p}{p+1,\dots,2p}.
Then this extended ACF is fed into the helper function  \code{\link[=est_stsp_cca]{est_stsp_cca()}}.

Note that MEST uses the autocovariance function. So for a "time series" object one has
to set \code{sample2acf=TRUE}.

These algorithms may be used for model reduction (i.e. to find a model with a
smaller state space dimension than the true model) and for estimation (by feeding a sample autocovariance function in).

These algorithms may also be used as simple "model reduction algorithms". If we want to
approximate a high dimensional state space model by a model of lower order, we may proceed
as follows. First we compute the ACF of the high dimensional model and then fed
this ACF into the subspace routine \code{est_stsp_ss}, however setting the maximum order
\code{s.max} to some value less than the true order.
Note thet the AOKI procedure however, may break down, since it is not guaranteed that
the Riccati equation, which needs to be solved, has a positive semidefinite solution.

\strong{Size of the Hankel matrix}

If the input parameter \code{p=NULL} then \eqn{p} is chosen as follows. The procedure
estimates the order of a "long" AR model with the AIC criterion. The size of
the "past" \eqn{p} then is set to \eqn{p = p_f\hat{p}_{AIC}}{p = p[f]phat}
where \eqn{p_f}{p[f]} is a factor (defaults to \eqn{2}) and
\eqn{\hat{p}_{AIC}}{phat} is the (AIC) estimate of the order of the "long"
AR model. See also \code{\link[=est_ar]{est_ar()}}.

\strong{Estimation of the Mean}

If the input parameter \code{obj} is an \code{\link[=autocov]{autocov()}} object (which contains no info
about the mean \eqn{\mu=E y_t}{\mu=E y[t]}) the "estimate" of the mean is simply set to
a vector of \code{NA}'s.

If the input parameter \code{obj} is a "time series" object, then there are two options.
For \code{mean_estimate == 'zero'} the procedure assumes that the process is centered
(\eqn{\mu=E y_t=0}{\mu=E y[t]=0}) and thus sets the estimate to a zero vector.
In the case \code{mean_estimate == 'sample.mean'}  the sample mean of the data is used.

\strong{Order Estimation}

The input parameter \code{s.max} defines the maximum order considered.

The order estimation is based on the Hankel singular values \eqn{\sigma_s}{\sigma[s]} and/or the
log det values of the estimated noise covariance matrices \eqn{\ln\det \hat{\Sigma}_s}{ln det \Sigma[s]}.
Using only the Hankel singular values has the advantage that only \emph{one} model has to be estimated,
whereas otherwise estimates for \emph{all} models with orders \eqn{s=0,\ldots,s_{\max}}{s=0,dots,s[max]}
have to be computed.

In order to exploit this (small) advantage of singular values based criteria the
order estimation runs as follows:
First the procedures call
\cr
\code{ estorder(s.max, Hsv, n.par, m, n.obs, Hsize=c(f,p), ...)}
\cr
Here \code{Hsv} is an \eqn{pm} dimensional vector with the Hankel singular values and
\code{n.par} is an \eqn{(s_{\max}+1)}{(s[max]+1)} dimensional vector with the respective number of
parameters of the models with orders \eqn{s=0,\ldots,s_{\max}}{s=0,dots,s[max]}.
If this call returns an estimate of the order then the procedures estimate a
corresonding state space model.

If this call fails (i.e returns \code{NULL}) then the procedures estimate
all models with orders up to \eqn{s_{\max}}{s[max]} and the corresponding
noise covariance matrices. The order then is estimated by calling
\cr
\code{ estorder(s.max = s.max, Hsv, lndetSigma, n.par, m, n.obs, Hsize, ...)}
\cr
where \code{lndetSigma} is the vector with the log det values of the estimated
noise covariance matrices (\eqn{\ln\det \hat{\Sigma}_s}{ln det \Sigma[s]}).

The package offers some predefined order selection procedures
(see also \link{subspace order estimates}):
\itemize{
\item \code{estorder_max(s.max, ...)} simply returns
the maximum order \code{s.max} considered.
\item \code{estorder_rkH(s.max, Hsv, tol, ...)} estimates
the order by an estimate of the rank of the Hankel matrix.
\item \code{estorder_MOE(s.max, Hsv, ...)} estimates the order by searching
for a "gap" in the singular values.
\item \code{estorder_SVC(s.max, Hsv, n.par, n.obs, Hsize, penalty, ...)}
implements the so called \emph{Singular Value Criteria}, see
\insertCite{Bauer2001}{RLDM}:
\deqn{svc(s) = \sigma_{s+1}^2 + c(N)d(s)/N}{svc(s)=\sigma[s+1]^2 + c(N)d(s)/N}
Here \eqn{\sigma_s}{\sigma[s]} is the \eqn{s}-th
singular value of the weighted Hankel marix, \eqn{N} is the sample size,
\eqn{d(s) = 2ms} denotes the number of parameters for a state space
model with \eqn{s} states (and \eqn{m} outputs) and \eqn{c(N)}) is a "penalty"
(depending on the sample size).
\cr
The above order estimation procedures only use the Hankel singular values, whereas
the following procedure is based on the estimated noise covariances.
\item \code{estorder_IVC(s.max, lndetSigma, n.par, n.obs, penalty, ...)} estimates the order
via an information criterion of the form
\deqn{ivc(s) = \ln\det\hat\Sigma_{s} + c(N)d(s)/N}{ivc(s)=ln det \Sigma[s] + c(N)d(s)/N}
where \eqn{\hat\Sigma_s}{\Sigma[s]} is the estimate of the noise covariace matrix
obtained from a model with order \eqn{s}, \eqn{d(s)} denotes the number of parameters
and \eqn{c(N)} is a "penalty" (depending on the sample size).
}

For both \code{estorder_SVC} and \code{estorder_IVC} the (optional) parameter
\code{penalty} controls the penalty term \eqn{c(N)}.
}
\section{Further Notes}{


The actual computations are done by the helper routines detailed in \link{subspace helpers}.

The type of the \code{\link[=autocov]{autocov()}} object is irrelevenat
since the function always uses the slot \code{obj$gamma}.

For  \code{keep_models==TRUE} the estimation procedure compute \emph{all}
models even in the case of a Hankel singular value based selection criterion.
}

\examples{
set.seed(3421) # in order to get reproducible results

# create a "random", stable and miniphase state space model
m = 2 # number of outputs
s = 3 # number of states
s.max = 2*s
lag.max = max(4*s, 25)
n.obs = 1000

model = r_model(tmpl_stsp_full(m, m, s),
                bpoles = 1, bzeroes = 1,  sd = 0.5)
# scale sigma_L
diag(model$sigma_L) = 1

# compute ACF
gam = autocov(model, lag.max = lag.max)

# simulate data
data = sim(model, n.obs)

# sample ACF
gam.sample = autocov(data$y, lag.max = lag.max, demean = FALSE)

# AOKIs method ##############################################################
# reconstruct the true model from the population ACF
# "estimate" the order by the rank of the Hankel matrix
out = est_stsp_ss(gam, method = 'aoki', s.max = 2*s, estorder = estorder_rkH)

# compute the ACF of the constructed model.
gam.hat = autocov(out$model, lag.max = lag.max)

# check that the constructed model is equivalent to the original model
all.equal(dim(model$sys), dim(out$model$sys))
all.equal(gam, gam.hat)


# CCA based on the sample ###################################################
# estimate the order by a "singular value criterion"
out = est_stsp_ss(data$y, method = 'cca', sample2acf = FALSE, s.max = 2*s,
                  estorder = estorder_SVC)

# compute the ACF of the constructed model.
gam.hat = autocov(out$model, lag.max = lag.max)

all.equal(dim(model$sys), dim(out$model$sys)) # the estimated order is correct
all.equal(gam$gamma, gam.hat$gamma)           # but of course the estimated model is not perfect

# CCA based on the sample ACF ###############################################
# estimate the order by an "information criterion"
out = est_stsp_ss(gam.sample, method = 'cca', s.max = 2*s,
                  estorder = estorder_IVC)

# compute the ACF of the constructed model.
gam.hat = autocov(out$model, lag.max = lag.max)

cat('s.hat=', dim(out$model$sys)[3], '\n') # the estimated order is s.hat=2, the true order is s=3!
all.equal(gam$gamma, gam.hat$gamma)        # relative error of the TRUE and the estimated ACF

# alternatively, we may also use
out2 = est_stsp_ss(data$y, sample2acf = TRUE, mean_estimate = 'zero',
                   method = 'cca', s.max = 2*s, estorder = estorder_IVC)
all.equal(out$model, out2$model)

# MEST algorithm #############################################################
# estimate the order by an "information criterion"
out = est_stsp_ss(gam.sample, method = 'cca', extend_acf = TRUE, s.max = 2*s,
                  estorder = estorder_IVC)

# compute the ACF of the constructed model.
gam.hat = autocov(out$model, lag.max = lag.max)

cat('s.hat=', dim(out$model$sys)[3], '\n') # the estimated order is s.hat=2, the true order is s=3!
all.equal(gam$gamma, gam.hat$gamma)        # relative error of the TRUE and the estimated ACF

# make a plot of the ACFs
plot(gam, list(gam.sample, gam.hat), legend = c('TRUE', 'sample', 'subspace'))

# reset seed
set.seed(NULL)
}
\references{
\insertRef{Aoki90}{RLDM}

\insertRef{Bauer2001}{RLDM}

\insertRef{DahlenScherrer2004}{RLDM}
}
