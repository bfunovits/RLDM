% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/afb_estimate_logLikelihood.R
\name{ll_FUN}
\alias{ll_FUN}
\title{Log Likelihood Function Factory}
\usage{
ll_FUN(
  template,
  y,
  which = c("concentrated", "conditional", "kf", "gr_concentrated"),
  skip = 0L,
  tol = 1e-08,
  err = NA_real_
)
}
\arguments{
\item{template}{A model template, see \link{model structures}.}

\item{y}{sample, i.e. an \eqn{(N,m)} dimensional matrix, or a "time series"
object (i.e. \code{as.matrix(y)} should return an \eqn{(N,m)}-dimensional
numeric matrix). Missing values (\code{NA}, \code{NaN} and \code{Inf}) are
\strong{not} supported.}

\item{which}{(string) Determines the type of ll function.}

\item{skip}{(integer) skip initial observations. If \code{NULL} then
\code{skip} is set to \eqn{0} for state space models and to
\eqn{\max(p,q)}{max(p,q)} for ARMA models. This parameter
is only used for the cases "concentrated", "conditional" and "gr_concentrated"}

\item{tol}{(double) tolerance used by \code{\link[=ll_kf_cpp]{ll_kf_cpp()}}.}

\item{err}{(double) return value for the case "kf", if the computation
of the initial state covariance fails.}
}
\value{
A function, \code{llfun(th)} say, which computes the log-likelihood for given
\emph{deep} parameters \code{th}. This function may be used for ML estimation of the model.

Function \code{fn(th)}
}
\description{
Creates a function similar to \code{\link[=ll_theta]{ll_theta()}} but faster and more memory efficient.
The model structure (\code{template}) and the data (\code{y}) are encoded within the
generated closure (a function plus its enclosing environment).
The generated function calls compiled C/C++ code (see \link[RcppArmadillo:RcppArmadillo-package]{RcppArmadillo-package}) and
hence is much faster than calling \code{ll_theta(th, template, y, ...)}.
}
\examples{
# Generate a random model in echelon form model (m = 3)
tmpl = tmpl_stsp_echelon(nu = c(2,1,1))
model = r_model(template = tmpl, bpoles = 1, bzeroes = 1, sd = 0.25)
diag(model$sigma_L) = 1 # scale the diagonal entries of sigma_L
print(model)
# extract the corresponding free/deep parameters
th = extract_theta(model, tmpl)

# generate a sample with 50 observations
y = sim(model, n.obs = 50)$y

# conditional log likelihood
# the following statements return the same ll value!
ll(model, y, 'conditional')
ll_theta(th, tmpl, y, 'conditional')
fn = ll_FUN(tmpl, y, 'conditional')
fn(th)

# concentrated conditional log likelihood
# the following statements return the same ll value!
ll(model, y, 'concentrated')
ll_theta(th, tmpl, y, 'concentrated')
fn = ll_FUN(tmpl, y, 'concentrated')
fn(th)
# for this case, we may also compute the (analytic) gradient
gr = ll_FUN(tmpl, y, 'gr_concentrated')
gr(th)

# log likelihood (via Kalman filter)
# the following statements return the same ll value!
ll(model, y, 'kf2')
ll_theta(th, tmpl, y, 'kf2')
ll(model, y, 'kf')
ll_theta(th, tmpl, y, 'kf')
fn = ll_FUN(tmpl, y, 'kf')
fn(th)
}
