% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/02_templates.R
\name{local model structures}
\alias{local model structures}
\alias{tmpl_DDLC}
\alias{tmpl_GRAM}
\title{Local Model Structures}
\usage{
tmpl_DDLC(
  model,
  balance = c("none", "lyapunov", "minimum phase"),
  sigma_L = c("chol", "symm", "identity")
)

tmpl_GRAM(
  model,
  balance = c("lyapunov", "minimum phase"),
  sigma_L = c("chol", "symm", "identity")
)
}
\arguments{
\item{model}{\code{\link[=stspmod]{stspmod()}} object, which represents a state space model. Only the case
\eqn{m = n > 0} is implemented, i.e. the output process and the noise process must
be of the same dimension.}

\item{balance}{(character string) For \code{balance = "lyapunov"} or
\code{balance = "minimum phase"} the reference model is first balanced by
the respective scheme.}

\item{sigma_L}{(character string) determines the form of the (left) square root
of the noise covariance \eqn{\Sigma}. The choice \code{"chol"} gives a
lower triangular matrix, \code{"symm"} gives a symmetric matrix and
\code{"identity"} corresponds to the (fixed) identity matrix.}
}
\value{
Model template, i.e. a list with slots
\item{\code{h}}{\eqn{((m+s)^2 + m^2)}-dimensional vector,}
\item{\code{H}}{\eqn{((m+s)^2 + m^2, k)}-dimensional matrix,}
\item{\code{class = "stspmod"}}{}
\item{\code{order = c(m,m,s)}}{ and }
\item{\code{n.par}}{number of free parameters \eqn{=k}.}

See also \code{\link[=model structures]{model structures()}} for more details.
}
\description{
Parametrization for "local" model classes, in particular, "Data Driven Local Coordinates"
as detailed in \insertCite{McKelveyHelmerssonRibarits2004}{RLDM} and
\insertCite{RibaritsDeistlerHanzon2005}{RLDM}.
}
\details{
The function \code{tmpl_DDLC} and \code{tmpl_GRAM} construct model templates which describe
models in a neighborhood of a given reference model.
In a first step the reference state space model is transformed to \eqn{D=I} and eventually
(depending on the parameter \code{"balance"}) balanced.

state space models are described by a quadruple \eqn{(A,B,C,D=I)} of matrices which may be
embedded into an \eqn{(s^2+2ms)}-dimensional euclidean space. Note that the parameter matrices
are not uniqely determined from the ACF or the spectral density of the process, i.e. there
is an inherent non identifiablity problem. For minimal models the "equivalence class"
of models, which represent the same ACF is given by the set of all models which
may be obtained by a state transformation
\eqn{(A,B,C,D) \rightarrow (TAT^{-1}, TB, CT^{-1}, D)}{(A,B,C,D) -> (TAT^{-1}, TB, CT^{-1}, D)}.

The \emph{DDLC} parametrization now considers models, \eqn{(A,B,C,D=I)}, which
are contained in the \eqn{2ms}-dimensional subspace, which is \emph{orthogonal} to
the \eqn{s^2}-dimensional tangent space of the set of equivalent models.

The routine \code{tmpl_GRAM} considers the \eqn{2ms}-dimensional subspace, where
models close to the reference models are "approximately" balanced.

Both schemes may fail for "non-generic" models. \code{tmpl_DDLC} issues a
warning message and \code{tmpl_GRAM} throws an error, in cases where the
\eqn{2ms}-dimensional subspace is not well defined.

Note that also the parametrization of the left square root \code{L=sigma_L} of the
noise covariance is "local", i.e. \code{th = 0} corresponds to the (balanced) reference model.
}
\examples{
# create a random state space model with m outputs and s states
m = 3
s = 6
tmpl = tmpl_stsp_full(m, n = m, s, sigma_L = 'symm')
model = r_model(tmpl, bpoles = 1.1, bzeroes = 1.1, sd = 1/s)
model                              # note that sigma_L is symmetric
model$sigma_L \%*\% t(model$sigma_L) # noise covariance Sigma

# tmpl_DDLC #############################################

# create a DDLC parametrization of a neighborhood of this model
tmpl = tmpl_DDLC(model, balance = 'lyapunov', sigma_L = 'chol')
# for th = 0, we get the original model (in balanced form)
model = fill_template(numeric(tmpl$n.par), tmpl)
model                                # note that sigma_L is lower triangular
model$sigma_L \%*\% t(model$sigma_L)  # however Sigma is the same as above

#' apply a "small" state transformation T = (diag(s)+eps*X)
eps = sqrt(.Machine$double.eps)
sys = model$sys
d_sys = state_trafo(sys, diag(s) + matrix(rnorm(s^2, sd = eps), nrow = s, ncol = s))
d_pi = (as.vector(unclass(d_sys) - unclass(sys)))/eps
# The vector d_pi is (close to) an element of the tangent space
# of the set of models, which are generated by a state transformation
# of the reference model

# by construction d_pi is (close to) orthogonal to tmpl$H
max(abs(d_pi \%*\% tmpl$H[1:((m+s)^2), , drop = FALSE]))

# the tmpl_DDLC routine may fail in some exceptional cases
m = 1
s = 3
model = stspmod(sys = stsp(A = matrix(0, nrow = s, ncol = s),
                           B = matrix(rnorm(m*s), nrow = s, ncol = m),
                           C = matrix(rnorm(m*s), nrow = m, ncol = s),
                           D = diag(m)),
                sigma_L = diag(m))

# For this model "tmpl_DLLC" issues a warning.
junk = tmpl_DDLC(model, sigma_L = 'chol', balance = 'none')

# tmpl_GRAM #############################################
model = fill_template(numeric(tmpl$n.par), tmpl)

tmpl = tmpl_GRAM(model, sigma_L = 'chol')
model = fill_template(numeric(tmpl$n.par), tmpl)

# check grammians
gr = grammians(model$sys, 'lyapunov')
P = gr$P
Q = gr$Q
# P=Q=diag() should hold!
print(round(cbind(P, P-Q), 6))

# now consider a model close to the reference model
d_th = rnorm(tmpl$n.par, sd = eps)
d_model = fill_template(d_th, tmpl)
d_sys = d_model$sys
gr = grammians(d_sys, 'lyapunov')
d_P = gr$P - P
d_Q = gr$Q - Q

# the "disturbed" system should still be approximately balanced!
print(round(cbind(d_P, d_P - d_Q)/eps, 6) )
# Create a template
tmpl <- tmpl_GRAM()
tmpl

# Use the template with fill_template()
# filled <- fill_template(tmpl, theta = rnorm(tmpl$n.par))
}
\references{
\insertRef{McKelveyHelmerssonRibarits2004}{RLDM}

\insertRef{RibaritsDeistlerHanzon2005}{RLDM}.
}
\seealso{
For the computation of Grammians and for balancing of state space models,
see \code{\link[rationalmatrices:balance]{rationalmatrices::balance()}}.
}
