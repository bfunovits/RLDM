% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{residuals_ARMA_cpp}
\alias{residuals_ARMA_cpp}
\title{Residuals of an ARMA system}
\usage{
residuals_ARMA_cpp(ib0, B1, A, t0, y, u, dU)
}
\arguments{
\item{ib0}{\eqn{(m, m)} matrix, \strong{inverse} of the coefficient matrix \eqn{b[0]}{b[0]}.}

\item{B1}{\eqn{(m, mq)} matrix, \eqn{-b_0^{-1}(b_q,...,b_1)}{-b[0]^(-1)(b[q],...,b[1])}.}

\item{A}{\eqn{(m, n(q+1))} matrix \eqn{b_0^{-1}(a_0,...,a_p}{b[0]^(-1)(a[0],...,a[p])}.}

\item{t0}{integer, start iteration at t = t0.}

\item{y}{\eqn{(m, N)} matrix with the observed outputs \eqn{(y_1,...,y_N}{(y[1],...,y[N])}.}

\item{u}{\eqn{(m, N)} matrix. This matrix is \strong{overwritten} with the computed
residuals \eqn{(u_1,...,u_N}{(u[1],...,u[N])}.}

\item{dU}{\eqn{(mN, m^2(p+q+2))} matrix or an empty matrix. If non empty then this
matrix is \strong{overwritten} with the directional derivatives of the vectorized residuals.
The \eqn{j}-th column of \code{dU} is the derivative of \eqn{vec(u)} with respect
to the \eqn{j}-th entry of
\eqn{\mathrm{vec}(a_0,a_1,\ldots,a_p,b_0,\ldots,b_q)}{vec(a[0],a[1],...,a[p],b[0],...,b[q])}}
}
\value{
This RcppArmadillo routine returns \code{NULL} but \bold{overwrites}
the input arguments \code{u} (and \code{dU})!
}
\description{
\ifelse{html}{\figure{internal_Rcpp.svg}{options: alt='Internal (Rcpp) function'}}{\strong{Internal (Rcpp)} function}

This internal helper function computes the residuals and the directional derivatives of the
residuals of an ARMA system of the form
\deqn{a_0 y_t + a_1 y_{t-1} + \cdots + a_p y_{t-p} = b_0 u_t + \cdots + b_q u_{t-q}}{
      a[0] y[t] + a[1] y[t-1] + ... + a[p] y[t-p] = b[0] u[t] + ... + b[q] u[t-q]}

Values \eqn{y_t}{y[t]}, \eqn{u_t}{u[t]} for \eqn{t\leq 0}{t\le 0} are implicitly set to be zero.
However, by starting the iteration with some \eqn{t_0>1}{t0>1} we can enforce non-zero
initial values.
}
\note{
Use this procedure with care!
\itemize{
\item The procedure does \bold{not} check the input arguments. We require \eqn{m = n > 0},
\eqn{p,q \geq 0}{p,q \ge 0} and \eqn{1 \leq t_0 \leq N}{1 \le t0  \le N}.
\item The procedure \bold{overwrites} the input argument \code{u} (and \code{dU}).
\item The data matrices are organized columnwise (to avoid memory shuffling)!
\item Note also the non standard representation of the coefficient matrices.
}
}
\examples{
# generate a random ARMA(2,1) model (3 outputs, 2 inputs)
p = 2
q = 1
m = 2
model = test_armamod(dim = c(m, m), degrees = c(p,q), digits = 2)

# prepare parameters for "outputs_ARMA_cpp"
A = unclass(model$sys$a)
a0 = A[,,1]
A1 = -A[,,(p+1):2]
dim(A1) = c(m, m*p)
A1 = solve(a0, A1)

B = unclass(model$sys$b)
dim(B) = c(m, m*(q+1))
B = solve(a0, B)

# generate random noise sequence (sample size N = 10)
n.obs = 10
u = matrix(rnorm(n.obs*m), nrow = m, ncol = n.obs)

# generate matrix for the outputs
y = matrix(0, nrow = m, ncol = n.obs)

# compute outputs
t0 = 2   # start iterations from t>=t0=2
outputs_ARMA_cpp(A1, B, t0, u, y)

# recompute the disturbances/residuals from the given outputs:
B = unclass(model$sys$b)
ib0 = B[,,1]
B1 = -B[,,(q+1):2]
dim(B1) = c(m, m*q)
B1 = solve(ib0, B1)

A = unclass(model$sys$a)
dim(A) = c(m, m*(p+1))
A = solve(ib0, A)

ib0 = solve(ib0)

uu = u + 0 # "deep copy" of the disturbances
uu[, t0:(n.obs)] = 0 # clear values for t >= t0
residuals_ARMA_cpp(ib0, B1, A, t0 = 2, y, uu, diag(0))
all.equal(u, uu) # check

# compute directional derivatives of residuals
dU = matrix(0, nrow = n.obs*m, ncol = (m^2)*(p+q+2))
residuals_ARMA_cpp(ib0, B1, A, t0 = 2, y, uu, dU)

}
\seealso{
\code{\link{outputs_ARMA_cpp}}, \code{\link{residuals_ARMA_cpp}},  \code{\link{cll_theta_ARMA_cpp}},
\code{\link{outputs_STSP_cpp}}, \code{\link{residuals_STSP_cpp}},  \code{\link{cll_theta_STSP_cpp}} and
\code{\link{solve_de}}, \code{\link{solve_inverse_de}} and \code{\link{ll}}.
}
