% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/03_properties_impulse.R
\name{impresp}
\alias{impresp}
\alias{impresp.armamod}
\alias{impresp.rmfdmod}
\alias{impresp.stspmod}
\alias{impresp.impresp}
\title{Impulse Response Function}
\usage{
impresp(obj, lag.max, H)

\method{impresp}{armamod}(obj, lag.max = 12, H = NULL)

\method{impresp}{rmfdmod}(obj, lag.max = 12, H = NULL)

\method{impresp}{stspmod}(obj, lag.max = 12, H = NULL)

\method{impresp}{impresp}(obj, lag.max = NULL, H = NULL)
}
\arguments{
\item{obj}{\code{\link[=armamod]{armamod()}}, \code{\link[=stspmod]{stspmod()}} object or \code{\link[=impresp]{impresp()}} object.
The last case may be used to transform the impulse response function to
a different orthogonalization scheme.}

\item{lag.max}{Maximum lag of the impulse response coefficients. This parameter is ignored in
the case that \code{obj} is an impresp object.}

\item{H}{An (n x n) (non singular) matrix which specifies a transformation of the noise.
The noise \eqn{u_t}{u[n]} is transformed to \eqn{H^{-1}u_t}{H^{-1}u[t]} and
the impulse response coefficients (\eqn{k_j \rightarrow k_j H}{k[j] -> k[j] H}) and the (left)
square root of the noise covariance matrix (\eqn{L \rightarrow H^{-1}L}{L -> H^{-1}L}) are
transformed correspondingly.
\cr
The default case \code{H=NULL} corresponds to the identity matrix (i.e. no transformation).
\cr
For \code{H='chol'}, the transformation matrix \code{H = t(chol(Sigma))}
is determined from the Choleski decomposition of the noise covariance \eqn{\Sigma}.
For \code{H='eigen'} the symmetric square root of
\eqn{\Sigma} (obtained from the the eigenvalue decomposition of \eqn{\Sigma})
is used. For \code{H='sigma_L'} the left square root of the noise covariance,
which is stored in the object \code{obj}, is used. In these cases
one obtains an \emph{orthogonalized} impulse response function.
Other orthogonalization schemes may be obtained by setting \eqn{H} to a
suitable square root of \eqn{\Sigma}.}
}
\value{
\code{impresp} object, i.e. a list with components
\item{irf}{\code{pseries} object.}
\item{sigma_L}{(n,n)-dimensional matrix which contains left square of noise covariance matrix.}
\item{names}{(n)-dimensional character vector or NULL}
\item{label}{character string or NULL}
}
\description{
Compute the (orthogonalized) impulse response function of a VARMA model or
a state space model. The impulse response coefficients are also called
\emph{Power series parameters} of the system.
}
\details{
The impulse response coefficients \eqn{(k_j \,|\, j \geq 0)}{(k[j], j \ge 0)}
define the map between the noise and the output process. If the model is stable then
the stationary solution of the ARMA system, respectively state space system, is given by
\deqn{
y_t = \sum_{j \geq 0} k_j u_{t-j}.
}{
y[t] = sum_{j \ge 0} k[j] u[t-j].
}
For a state space system the impulse response coefficients
are
\deqn{k_0 = D \mbox{ and }}{k[0] = D and}
\deqn{k_j = CA^{j-1}B \mbox{ for }j >0.}{k[j] = CA^{j-1}B for j>0.}
For an ARMA model the coefficients are (recursively) computed
by a comparison of coefficients in the equation
\deqn{
(a_0 + a_1 z + \cdots + a_p z^p)(k_0 + k_1 z + k_2 z^2 + \cdots ) = b_0 + b_1 z + \cdots + b_q z^q
}{
(a[0] + a[1] z + \dots + a[p] z^p)(k[0] + k[1] z + k[2] z^2 + \dots ) = b[0] + b[1] z + \dots + b[q] z^q
}

The S3 methods \verb{impresp.*} compute the coefficients \eqn{k_j}{k[j]} for
\eqn{j = 0,\cdots,N}{j = 0,\dots,N} and store the result, together with the left square root
(\code{sigma_L}) of the noise covariance \eqn{\Sigma}, in a \strong{impresp} object.
\code{impresp} objects contain the complete information
about the underlying model, provided that the maximum lag \eqn{N} is large enough.
This means that one may reconstruct the underlying model from an impulse response object.
}
\examples{
# IRF from state space model ################################################
model = stspmod(stsp(A = c(0,0.2,1,-0.5), B = c(1,1,1,-1),
                     C = c(1,0,0,1)),
                sigma_L = matrix(c(4, 1, 1, 3), 2, 2),
                names = c('y1','y2'), label = 'test model')

# IRF
irf = impresp(model, lag.max=10)
irf

# Orthogonalized IRF: Cholesky
irf_chol = impresp(model, lag.max = 10, H = 'chol')
irf_chol
print(irf_chol$sigma_L) # Sigma is (approximately equal to) the identity matrix


# IRF from VARMA model ################################################
model = armamod(sys = test_lmfd(dim = c(2,2), degrees = c(2,1)))

irf = impresp(model)
print(irf, digits = 2, format = 'iz|j')
}
\references{
\insertRef{luet05}{RLDM}
}
