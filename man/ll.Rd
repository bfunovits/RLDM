% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/afb_estimate_logLikelihood.R
\name{ll}
\alias{ll}
\alias{ll.armamod}
\alias{ll.stspmod}
\title{Log Likelihood Methods}
\usage{
ll(obj, y, which, ...)

\method{ll}{armamod}(obj, y, which = c("concentrated", "conditional"), skip = 0L, ...)

\method{ll}{stspmod}(
  obj,
  y,
  which = c("concentrated", "conditional", "kf", "kf2"),
  skip = 0L,
  P1 = NULL,
  a1 = NULL,
  tol = 1e-08,
  ...
)
}
\arguments{
\item{obj}{Object of type \code{\link[=armamod]{armamod()}}, \code{\link[=rmfdmod]{rmfdmod()}}, or \code{\link[=stspmod]{stspmod()}}.}

\item{y}{Data sample given as \eqn{(N,m)} dimensional matrix, or
a "time series" object (in the sense that \code{as.matrix(y)}
should return an \eqn{(N,m)}-dimensional numeric matrix).
Missing values (\code{NA}, \code{NaN} and \code{Inf}) are \strong{not} supported.}

\item{which}{(character) which likelihood to compute.}

\item{...}{Not used.}

\item{skip}{(integer) skip initial observations. This parameter is only used, when the
(concentrated) conditional likelihood is computed.}

\item{P1}{\eqn{(s,s)} dimensional covariance matrix of the error of the initial state estimate.
If \code{NULL} then the state covariance \eqn{P=APA'+B\Sigma B'} is used.
This parameter is only used, when the (exact) likelihood is
computed via the Kalman Filter. See \code{\link[=ll_kf]{ll_kf()}} for more details.}

\item{a1}{\eqn{s} dimensional vector, which holds the initial estimate for the state at time t=1.
If \code{a1=NULL}, then a zero vector is used. This parameter is only used, when the
(exact) likelihood is computed via the Kalman Filter. See \code{\link[=ll_kf]{ll_kf()}} for more details.}

\item{tol}{(small) tolerance value (or zero) used by the Kalman Filter routines, see \code{\link[=ll_kf]{ll_kf()}}.}
}
\value{
(double) the (scaled) log Likelihood of the model.
}
\description{
Tools and methods for the computation of the (conditional or exact) Gaussian log-likelihood
of ARMA, RMFD, and state space models.
For functions which serve as input for optimizers like \link[stats:optim]{optim},
see \link{ll_theta} and \link{ll_FUN} (where the latter is a \emph{function factory} which
generates a closure that serves as such an input).
}
\details{
The procedure three choices ...

For an ARMA model
\deqn{a_0 y_t + a_1 y_{t-1} + \cdots + a_p y_{t-p} = b_0 u_t + b_1 u_{t-1} + \cdots + b_q u_{t-q}}{
     a[0] y[t] + a[1] y[t-1] + \dots + a[p] y[t-p] = b[0] u[t] + b[1] u[t-1] + \dots + b[q] u[t-q]}
with Gaussian noise \eqn{u_t \sim N(0,\Sigma)}{u[t] ~ N(0,\Sigma)} an \emph{approximation} of the
\strong{scaled} log likelihood is
\deqn{ll = -(1/2)(m \ln(2\pi) + \mathrm{tr}(S\Sigma^{-1}) + \ln\det \Sigma + 2 \ln\det (a_0^{-1}b_0)}{
     ll = -(1/2)(m ln(2\pi) + tr(S\Sigma^{-1}) + ln det \Sigma + 2 ln det (a[0]^{-1}b[0])}
where \eqn{S} denotes the sample covariance of the residuals of the model
\deqn{S=\frac{1}{N-s}\sum_{t=s+1}^N e_t e_t'}{
      S=(1/(N-s)) \sum_{t=s+1}^N e[t] e[t]'}
The residuals are computed from a sample \eqn{y_t, t=1,\ldots,N}{y[t], t=1,...,N} by solving the (inverse) ARMA system
\deqn{b_0 e_t = -b_1 e_{t-1} - \cdots - b_q e_{t-q} + a_0 y_t + a_1 y_{t-1} + \cdots + a_p y_{t-p}}{
      b[0] e[t] = -b[1] e[t-1] - \dots -b[q] e[t-q] + a[0] y[t] + a[1] y[t-1] + \dots + a[p] y[t-p]}
and setting all unknown initial values \eqn{y_t=0}{y[t]=0} and \eqn{e_t=0}{e[t]=0} for
\eqn{t\leq 0}{t\le 0} equal to zero.
See e.g. \code{\link[=solve_inverse_de]{solve_inverse_de()}}.
Note that the log Likelihood here is \strong{scaled} by a factor \eqn{1/(N-s)} and
that the first \eqn{s} observations are \strong{skipped} when computing the sample covariance matrix.

The log-likelihood may be easily maximized with respect to the noise covariance matrix \eqn{\Sigma}.
For given \eqn{S}, the optimal value for \eqn{\Sigma} is \eqn{\Sigma=S}.
If we plug this maximizer into the log-likelihood function, we obtain the "concentrated" log likelihood function
\deqn{cll = -(1/2)(m \ln(2\pi) + m + \ln\det S + 2 \ln\det (a_0^{-1}b_0)}{
      cll = -(1/2)(m ln(2\pi) + m + ln det S + 2 ln det (a[0]^{-1}b[0])}
which only depends on the sample \code{y} and the ARMA parameter matrices \eqn{a_i}{a[i]} and \eqn{b_i}{b[i]}.

For state space models the (approximate) log likelihood is computed quite analogously.
}
\note{
To be precise, the functions returns \eqn{1/(N-s)} times the (approximate) log likelihood.

The above routines only handle the case of centered data,
i.e. it is assumed that the output process \eqn{(y_t)}{(y[t])} has mean zero!

The computation of the concentrated log likelihood assumes
that the model structure does \strong{not} impose restrictions on the noise covariance matrix.
}
\examples{
# Generate a random model in echelon form model (m = 3)
tmpl = tmpl_arma_echelon(nu = c(2,1,1))
model = r_model(template = tmpl, bpoles = 1, bzeroes = 1, sd = 0.25)
diag(model$sigma_L) = 1 # scale the diagonal entries of sigma_L
print(model)
# extract the corresponding free/deep parameters
th = extract_theta(model, tmpl)

# generate a sample with 50 observations
y = sim(model, n.obs = 50, n.burn_in = 100)$y

# conditional log likelihood
# the following statements return the same ll value!
ll(model, y, which = 'conditional', skip = 0)
ll_theta(th, template= tmpl, y, which = 'conditional', skip = 0)
llfun = ll_FUN(tmpl, y, which = 'conditional', skip = 0)
llfun(th)

# concentrated, conditional log likelihood
# the following statements return the same ll value!
ll(model, y, which = 'concentrated', skip = 0)
ll_theta(th, template= tmpl, y, which = 'concentrated', skip = 0)
llfun = ll_FUN(tmpl, y, which = 'concentrated', skip = 0)
llfun(th)
}
