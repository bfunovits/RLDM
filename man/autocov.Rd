% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/03_properties_autocov.R
\name{autocov}
\alias{autocov}
\alias{autocov.default}
\alias{autocov.autocov}
\alias{autocov.armamod}
\alias{autocov.stspmod}
\title{Autocovariance, Autocorelation and Partial Autocorrelation Function}
\usage{
autocov(obj, type, ...)

\method{autocov}{default}(
  obj,
  type = c("covariance", "correlation", "partial"),
  lag.max = NULL,
  na.action = stats::na.fail,
  demean = TRUE,
  ...
)

\method{autocov}{autocov}(obj, type = c("covariance", "correlation", "partial"), ...)

\method{autocov}{armamod}(
  obj,
  type = c("covariance", "correlation", "partial"),
  lag.max = 12,
  ...
)

\method{autocov}{stspmod}(
  obj,
  type = c("covariance", "correlation", "partial"),
  lag.max = 12,
  ...
)
}
\arguments{
\item{obj}{either a \code{\link[=armamod]{armamod()}}, \code{\link[=stspmod]{stspmod()}}, \code{\link[=autocov]{autocov()}} object
or a "data" object.}

\item{type}{character string giving the type of acf to be computed. Allowed values are
"covariance" (the default), "correlation", or "partial". Will be partially matched.
Note that the default value here is "covariance" whereas \code{\link[stats:acf]{stats::acf()}}
uses "correlation" as default.}

\item{...}{not used.}

\item{lag.max}{(integer) maximum lag.}

\item{na.action}{function to be called to handle missing values. \code{\link[stats:na.fail]{stats::na.pass()}} can be used.}

\item{demean}{logical. Should the covariances be about the sample means?}
}
\value{
\code{autocov} object, i.e. a list with slots
\item{acf}{\code{\link[rationalmatrices:pseries]{rationalmatrices::pseries()}} object, which stores the covariances (correlations).}
\item{type}{character string which indicates the type of the ACF.}
\item{gamma}{(m,m,lag.max+1) dimensional array which stores the autocovariance function.}
\item{names}{(m)-dimensional character vector or NULL. This optional slot stores the names
for the components of the time series/process.}
\item{label}{character string or NULL.}
\item{n.obs}{integer or NULL. This slot stores the sample size.}
}
\description{
Compute respectively estimate the autocovariance, autocorrelation or partial autocorrelation function of a stationary process.
}
\details{
The class of the input parameter "\code{obj}" determines the S3 method called and hence what is actually computed.

\strong{Population ACF:}

If "\code{obj}" is an \code{\link[=armamod]{armamod()}} or \code{\link[=stspmod]{stspmod()}} object then \code{autocov(obj, ...)} computes the ACF of the corresponding stationary process.

Note however, that the function returns nonsense, if the model does not satisfy the \emph{stability} condition.

\strong{Change the type of an ACF:}

Calling \code{autocov(obj, type)}, where "\code{obj}" is an \code{autocov} object returns an ACF of the desired type.
E.g. if "\code{obj}" holds a partial autocorrelation function then \code{autocov(obj, type = 'covariance')} may be used to retrieve the corresponding autocovariance function.

This is possible since the \code{autocov} object stores the "original" autocovariances in a slot named \code{gamma}.

\strong{Sample ACF:}

The default S3 method estimates the ACF from given data.
It assumes that "\code{obj}" is a univariate or multivariate numeric time series object,
a (numeric) data frame or a (numeric) vector, respectively matrix
and then simply calls the function \code{\link[stats:acf]{stats::acf()}} in the \pkg{stats} package to compute the sample autocovariance function.
If needed, then the corresponding sample autocorrelation, respectively sample partial autocorrelation function is computed (and returned).

The syntax is quite analogous to \code{\link[stats:acf]{stats::acf()}}, so please consider the documentation of \code{\link[stats:acf]{stats::acf()}} for more details.

Note that \pkg{stats} stores autocovariance/autocorrelation functions as \verb{(lag.max+1,m,m)} dimensional arrays, whereas \pkg{RLDM} uses \verb{(m,m,lag.max+1)} dimensional arrays.

The definition of partial autocorrelations used by \code{\link[stats:acf]{stats::acf()}} differs from the definition used here, see e.g. \insertCite{Reinsel1997}{RLDM}.
Furthermore \code{\link[stats:acf]{stats::acf()}} skips the lag zero partial autocorrelation coefficient
and thus the pacf computed by  \code{\link[stats:acf]{stats::acf()}} is (lag.max,n,n) dimensional.

The default choice for the number of lags is \eqn{10*log10(N/m)} where \eqn{N}
is the number of observations and \eqn{m} the number of series.
This number will be automatically limited to one less than the number
of observations in the series.
}
\examples{
model = stspmod(sys = stsp(A = c(0,0.2,1,-0.5), B = c(1,1,1,-1),
                           C = c(1,0,0,1)), sigma_L = diag(c(4,1)),
                names = c('y1','y2'), label = 'test model')
g = autocov(model, lag.max=10)       # ACF
r = autocov(model, lag.max=10, type = 'correlation')  # autocorrelation function
r = autocov(g, type = 'correlation')                  # this gives the same result!
c = autocov(r, type = 'partial')     # partial autocorrelation function

\dontrun{
# consider an equivalent VARMA model
model2 = impresp2varma(irf(model, lag.max = 20))$model
g2 = autocov(model2, lag.max = 10)
all.equal(g,g2) # of course both return the same ACF

autocov(matrix(rnorm(100*2), nrow = 100))
autocov(stspmod(test_stsp(dim = c(2,2), s = 2), sigma_L = diag(2)))

# generate a random sample with 100 observations and 3 outputs/series.
x = matrix(rnorm(100*3), nrow = 100, ncol = 3)

# the covariance estimates are of course identical
stats_acfobj = stats::acf(x, type = 'covariance', demean = TRUE, plot = FALSE)
rldm_acfobj  = acf_estimate(x, type = 'covariance', demean = TRUE)
testthat::expect_equivalent(rldm_acfobj$gamma, aperm(stats_acfobj$acf,c(2,3,1)))

# also the correlation estimates are identical
stats_acfobj = stats::acf(x, type = 'correlation', demean = TRUE, plot = FALSE)
rldm_acfobj  = acf_estimate(x, type = 'correlation', demean = TRUE)
testthat::expect_equivalent(rldm_acfobj$gamma, aperm(stats_acfobj$acf,c(2,3,1)))

# However, the partial correlations dont match!
stats_acfobj = stats::acf(x, type = 'partial', demean = TRUE, plot = FALSE)
rldm_acfobj  = acf_estimate(x, type = 'partial', demean = TRUE)
testthat::expect_equivalent(rldm_acfobj$gamma[,,-1,drop=FALSE], aperm(stats_acfobj$acf,c(2,3,1)))
}

}
\references{
\insertRef{Reinsel1997}{RLDM}
}
\seealso{
The autocovariance function of (V)ARMA processes may also be
computed by \code{\link[stats:ARMAacf]{stats::ARMAacf()}} in the scalar case and by
\code{MTS::VARMAcov()} in the multivariate case (m > 1).

As noted above the sample ACF is computed via the \code{\link[stats:acf]{stats::acf()}} routine in the \pkg{stats} package.
}
