% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ab_templates.R
\name{STSmodels}
\alias{STSmodels}
\alias{tmpl_llm}
\alias{tmpl_lltm}
\alias{tmpl_cycle}
\alias{tmpl_season}
\alias{cbind_templates}
\title{Structural Time Series Models}
\usage{
tmpl_llm()

tmpl_lltm()

tmpl_cycle(fr, rho)

tmpl_season(s)

cbind_templates(...)
}
\arguments{
\item{fr, rho}{frequency and damping factor for cyclical components}

\item{s}{(integer > 1) period of seasonal component.}

\item{...}{compatible (state space model) templates. The output dimensions of the state space models must be
the same for all templates.}
}
\value{
Model template, i.e. a list with slots
\item{\code{h}}{\eqn{((m+s)(n+s) + m^2)}-dimensional vector,}
\item{\code{H}}{\eqn{((m+s)(n+s) + m^2, k)}-dimensional matrix,}
\item{\code{class}}{\code{class = "stspmod"}, only state space models are implemented}
\item{\code{order}}{\code{order = c(m,n,s)} (output, noise and state dimensions),}
\item{\code{n.par}}{number of free parameters \eqn{=k} and}
\item{\code{idx}}{a list with slots \code{state}, \code{noise} and \code{par}. These
indices code which states, noise components and parameters are
associated to the respective components. See the example(s) below.}
}
\description{
Tools for Structural Time Series Models, as described e.g. in
\insertCite{Harvey94}{RLDM}.
}
\details{
\strong{Local Level Model (LLM):} \code{tmpl_llm()}
\deqn{a_{t+1} = a_t + u_t,\quad y_t = a_t}{a[t+1] = a[t] + u[t], y[t] = a[t]}
where \eqn{(u_t)}{(u[t])} is white noise with variance \eqn{\sigma_u^2}{\sigma[u]^2}.
The model has one free parameter \eqn{\theta = \sigma_u}{\theta = \sigma[u]}.
The output process \eqn{(y_t)}{(y[t])} is a random walk.

\strong{Local Linear Trend Model (LLTM):} \code{tmpl_lltm()}
\deqn{a_{t+1} = a_t + b_t + u_t,\quad b_{t+1} = b_t + v_t,\quad y_t = a_t}{
      a[t+1] = a[t] + b[t] + u[t], b[t+1] = b[t] + v[t], y[t] = a[t]}
where \eqn{(u_t)}{(u[t])}, \eqn{(v_t)}{(v[t])} are two independent white noise processes
with variance  \eqn{\sigma_u^2}{\sigma[u]^2} and  \eqn{\sigma_v^2}{\sigma[v]^2}.
The model has two free parameter \eqn{\theta_1 = \sigma_u}{\theta[1] = \sigma[u]}
and  \eqn{\theta_2 = \sigma_v}{\theta[2] = \sigma[v]}. In general the output process is
integrated of order two (\eqn{I(2)}). For \eqn{sigma[v]^2=0}{sigma_v^2=0}
the model generates a random walk with drift and for \eqn{sigma[u]^2=0}{sigma_u^2=0}
one gets an integrated random walk.

\strong{Cyclical Models:} \code{tmpl_cycle(fr, rho)}

\verb{tmpl_cycl(fr. rho)} generates a template for scalar AR(2) models, where
the AR polynomial has two roots at
\deqn{z = \rho^{-1}\exp((\pm i 2\pi f)}{z = \rho^{-1} exp(Â± i 2\pi f)}
If the "damping factor" \eqn{\rho} is close to one then the model generates
processes with a strong "cyclical component" with frequency \eqn{f}.
For \eqn{\rho <1} the AR(2) model satisfies the stability condition, i.e.
the forward solution converges to a stationary process. For \eqn{\rho > 1}
the trajectories of the forward solution diverge exponentially.
The template has one free parameter, the standard deviation of the driving white noise:
\eqn{\theta = \sigma_u}{\theta = \sigma[u]}.

\strong{Seasonal Models:} \code{tmpl_season(s)}

\code{tmpl_season(s)} generates a template for scalar seasonal models, i.e.
for models which generate trajectories which are "almost" periodic
with a given period, \eqn{s} say. The template has one free parameter,
the standard deviation of the driving white noise:
\eqn{\theta = \sigma_u}{\theta = \sigma[u]}.

\strong{Combine Models} \code{cbind_templates(...)}

The utility \code{cbind_templates(...)} may be used to construct
models from simple "bulding blocks". Suppose e.g. that the observed process is
described as the sum of two (unobserved) components
\deqn{y_t = k_1(z) u_t + k_2(z) v_t}{y[t] = k[1](z) u[t] + k[2](z) v[t]}
where \eqn{(u_t)}{(u[t])}, \eqn{(v_t)}{(v[t])} are two independent white noise processes.
If both components are described by the templates \code{tmpl1} and \code{tmpl2}
then we may construct a template for the combined model simply
by \code{cbind_templates(tmpl1, tmpl2)}.

The function \code{cbind_templates} only deals with state space models and
of course all templates must describe outputs with the same dimension.

The functions \code{tmpl_llm()}, ..., \code{tmpl_season()} generate templates
for scalar time series. However, the utility \code{cbind_templates(...)}
also handles the multivariate case.
}
\examples{
# build a structural times series model (see Harve 94) with
#   a "local linear trend component",
#   a cyclical component with period 50 (frequency 1/50),
#   a seasonal component with period 6 and
#   an AR(1) component.
tmpl = cbind_templates(tmpl_lltm(), tmpl_cycle(1/50,1), tmpl_season(6),
                       tmpl_stsp_ar(1, 1, sigma_L = 'identity'))
# set some "reasonable" values for the standard deviations
# of the respective noise and for the AR(1) coefficient.
model = fill_template(c(0.0, 0.1,  # parameters for trend (lltm) component
                            0.1,       # parameter for cyclical component
                            0.1,       # parameter for seasonal component
                           -0.5        # AR(1) coefficient
                           ), tmpl)
print(model)

# simulate the time series (with initial states)
out = sim(model, n.obs = 100,
          a1 = c(100, 1,     # initial states for the trend component
                 3, 0,       # initial states for the cyclical component
                 5, 10, 10, -10, -10,   # ... for the seasonal component
                 0           # initial state for the AR(1) component
          ))

# extract the contribution of the respective components
X = cbind(out$y,
 out$a[1:100,tmpl$idx$state == 1, drop = FALSE] \%*\% model$sys$C[1, tmpl$idx$state == 1] +
  out$u[,tmpl$idx$noise == 1, drop = FALSE] \%*\% model$sys$D[1, tmpl$idx$noise == 1],
 out$a[1:100,tmpl$idx$state == 2, drop = FALSE] \%*\% model$sys$C[1, tmpl$idx$state == 2] +
  out$u[,tmpl$idx$noise == 2, drop = FALSE] \%*\% model$sys$D[1, tmpl$idx$noise == 2],
 out$a[1:100,tmpl$idx$state == 3, drop = FALSE] \%*\% model$sys$C[1, tmpl$idx$state == 3] +
  out$u[,tmpl$idx$noise == 3, drop = FALSE] \%*\% model$sys$D[1, tmpl$idx$noise == 3],
 out$a[1:100,tmpl$idx$state == 4, drop = FALSE] \%*\% model$sys$C[1, tmpl$idx$state == 4] +
  out$u[,tmpl$idx$noise == 4, drop = FALSE] \%*\% model$sys$D[1, tmpl$idx$noise == 4])

matplot(X, ylab = 'y', xlab = 't',
        type = 'l', lty = 1, col = 1:5)
grid()
legend('topleft', legend = c('y','trend','cycle','season','AR(1) noise'),
       lwd = 2, col = 1:5, bty = 'n')

\dontrun{
# the following examples throw errors
# 1 is not a template
cbind_templates(1, tmpl_season(4))
# the respective output dimensions are not equal
cbind_templates(tmpl_season(4), tmpl_stsp_ar(2, 2))
# the third argument is a "VARMA template"
cbind_templates(tmpl_lltm(), tmpl_cycle(1/20,1), tmpl_arma_pq(1, 1, 1, 1))
}
}
\references{
\insertRef{Harvey94}{RLDM}
}
\seealso{
See \link{model structures} and
\link{local model structures} for more details on model templates.
}
