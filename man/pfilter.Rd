% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/05_estimation_particle.R
\name{pfilter}
\alias{pfilter}
\alias{pfilter.stspmod}
\title{Sequential Monte Carlo (Particle Filter) Methods}
\usage{
pfilter(
  model,
  y,
  method = c("sir", "apf"),
  N_particles = 1000,
  resampling = c("systematic", "multinomial", "stratified"),
  ess_threshold = 0.5,
  P1 = NULL,
  a1 = NULL,
  ...
)

\method{pfilter}{stspmod}(
  model,
  y,
  method = c("sir", "apf"),
  N_particles = 1000,
  resampling = c("systematic", "multinomial", "stratified"),
  ess_threshold = 0.5,
  P1 = NULL,
  a1 = NULL,
  ...
)
}
\arguments{
\item{model}{\code{\link[=stspmod]{stspmod()}} object, which represents the state space model.
For nonlinear models, additional parameters may be required.}

\item{y}{sample, i.e. an \eqn{(N,m)} dimensional matrix,
or a "time series" object (i.e. \code{as.matrix(y)} should return an
\eqn{(N,m)}-dimensional numeric matrix). Missing values (\code{NA}, \code{NaN} and
\code{Inf}) are \strong{not} supported.}

\item{method}{Character string specifying the particle filter algorithm.
Options: \code{"sir"} (Sampling Importance Resampling, default),
\code{"apf"} (Auxiliary Particle Filter).}

\item{N_particles}{Number of particles to use (default: 1000).}

\item{resampling}{Resampling method: \code{"multinomial"}, \code{"systematic"} (default),
or \code{"stratified"}.}

\item{ess_threshold}{Effective sample size threshold for triggering resampling
(default: 0.5). Resampling occurs when ESS < ess_threshold * N_particles.}

\item{P1}{\eqn{(s,s)} dimensional covariance matrix of the error of the initial state estimate,
i.e. \eqn{\Pi_{1|0}}{P[1|0]}. If \code{NULL}, then the state covariance
\eqn{P = APA'+B\Sigma B'} is used.}

\item{a1}{\eqn{s} dimensional vector, which holds the initial estimate \eqn{a_{1|0}}{a[1|0]}
for the state at time \eqn{t=1}. If \code{a1=NULL}, then a zero vector is used.}

\item{...}{Additional arguments passed to filter implementations.}
}
\value{
List with components
\item{filtered_states}{\eqn{(N+1,s)} dimensional matrix with the filtered state estimates.
The \eqn{t}-th row corresponds to \eqn{E[x_t | y_{1:t}]}.}
\item{predicted_states}{\eqn{(N+1,s)} dimensional matrix with the predicted state estimates.
The \eqn{t}-th row corresponds to \eqn{E[x_t | y_{1:t-1}]}.}
\item{particles}{\eqn{(s, N\_particles, N+1)} dimensional array containing the particle trajectories.}
\item{weights}{\eqn{(N\_particles)} dimensional vector of normalized particle weights at final time.}
\item{log_likelihood}{Particle approximation of the log-likelihood.}
\item{log_likelihood_contributions}{\eqn{(N)} dimensional vector of log-likelihood contributions per time step.}
\item{effective_sample_size}{\eqn{(N+1)} dimensional vector of effective sample sizes.}
\item{N_particles}{Number of particles used.}
\item{resampling_method}{Resampling method used.}
\item{filter_type}{Type of particle filter used.}
}
\description{
Implementation of Sequential Monte Carlo (SMC) methods, also known as particle filters,
for state space models. These methods extend Kalman filtering to nonlinear and/or
non-Gaussian state space models.
}
\details{
The particle filter approximates the filtering distribution \eqn{p(x_t | y_{1:t})}
using a set of weighted particles (samples). The basic algorithm is the
Sampling Importance Resampling (SIR) filter, also known as the bootstrap filter.

The model considered is
\deqn{x_{t+1} = f(x_t, u_t)}{x[t+1] = f(x[t], u[t])}
\deqn{y_t = h(x_t, v_t)}{y[t] = h(x[t], v[t])}
where \eqn{f} is the state transition function, \eqn{h} is the observation function,
and \eqn{u_t}, \eqn{v_t} are noise processes.

For linear Gaussian models (the default), these reduce to
\deqn{x_{t+1} = A x_t + B u_t}{x[t+1] = A x[t] + B u[t]}
\deqn{y_t = C x_t + D v_t}{y[t] = C x[t] + D v[t]}
with \eqn{u_t \sim N(0, Q)}{u[t] ~ N(0, Q)} and \eqn{v_t \sim N(0, R)}{v[t] ~ N(0, R)}.
}
\examples{
# Linear Gaussian example: compare particle filter with Kalman filter
s = 2  # state dimension
m = 1  # number of outputs
n = m  # number of inputs
n.obs = 100 # sample size

# Generate a stable state space model
tmpl = tmpl_stsp_full(m, n, s, sigma_L = "chol")
model = r_model(tmpl, bpoles = 1, sd = 0.5)
# Generate a sample
data = sim(model, n.obs = n.obs, a1 = NA)

# Run particle filter
pf_result = pf(model, data$y, N_particles = 500)

# Compare with Kalman filter
kf_result = kf(model, data$y)

# Plot filtered states comparison
plot(pf_result$filtered_states[,1], type = "l", col = "blue",
     main = "Filtered State Estimates")
lines(kf_result$a[,1], col = "red", lty = 2)
legend("topright", legend = c("Particle Filter", "Kalman Filter"),
       col = c("blue", "red"), lty = 1:2)
}
\seealso{
\code{\link[=kf]{kf()}} for Kalman filter (optimal for linear Gaussian models),
\code{\link[=ll_pf]{ll_pf()}} for particle filter approximation of log-likelihood.
}
