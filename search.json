[{"path":"https://bfunovits.github.io/RLDM/CLAUDE.html","id":null,"dir":"","previous_headings":"","what":"CLAUDE.md","title":"CLAUDE.md","text":"file provides guidance Claude Code (claude.ai/code) working code repository.","code":""},{"path":"https://bfunovits.github.io/RLDM/CLAUDE.html","id":"project-overview","dir":"","previous_headings":"","what":"Project Overview","title":"CLAUDE.md","text":"RLDM (Rational Linear Dynamic Models) R package modeling stationary processes rational spectral density. uses Rcpp/RcppArmadillo performance-critical computations including Kalman filtering recursive least squares. Dependencies: Requires sister package rationalmatrices (installed GitHub via remotes::install_github(\"bfunovits/rationalmatrices\")).","code":""},{"path":"https://bfunovits.github.io/RLDM/CLAUDE.html","id":"build-commands","dir":"","previous_headings":"","what":"Build Commands","title":"CLAUDE.md","text":"","code":"# Development workflow devtools::load_all()           # Load package in dev mode devtools::document()           # Generate Roxygen docs devtools::test()               # Run testthat tests devtools::check()              # Full package check devtools::build()              # Build source package  # Run a single test file testthat::test_file(\"tests/testthat/test-templates.R\")  # Rcpp workflow (after modifying C++ code) Rcpp::compileAttributes()      # Regenerate RcppExports.cpp/R devtools::load_all()           # Reload with new compiled code"},{"path":"https://bfunovits.github.io/RLDM/CLAUDE.html","id":"testing","dir":"","previous_headings":"","what":"Testing","title":"CLAUDE.md","text":"Test Patterns: - Use testthat::test_file(\"tests/testthat/test-*.R\") run specific test files - Use devtools::test(filter = \"pattern\") run tests matching pattern (e.g., devtools::test(filter = \"pfilter\")) - Common assertions: expect_no_error(), expect_true(inherits(obj, \"class\")), expect_named(), expect_equal() - Set seeds set.seed() reproducible stochastic tests - Convergence tests: compare particle filter results Kalman filter baseline increasing particle counts - Validation bounds: Use reasonable thresholds (e.g., RMSE < 0.5, likelihood difference < 10) rather strict convergence Example test structure:","code":"test_that(\"function runs without errors\", {   set.seed(123)   model <- r_model(tmpl_stsp_full(...))   data <- sim(model, n.obs = 20)   expect_no_error(result <- pfilter(model, data$y))   expect_true(inherits(result, \"pfilter\"))   expect_named(result, c(\"filtered_states\", \"predicted_states\", ...)) })"},{"path":"https://bfunovits.github.io/RLDM/CLAUDE.html","id":"benchmarking","dir":"","previous_headings":"","what":"Benchmarking","title":"CLAUDE.md","text":"Use microbenchmark package timing comparisons (library(microbenchmark)) Create benchmark scripts save results .RData files later analysis Compare performance across parameter ranges (particle counts, noise levels, cross-covariance) Validate theoretical expectations (e.g., optimal proposal approach Kalman filter increasing particles)","code":""},{"path":[]},{"path":"https://bfunovits.github.io/RLDM/CLAUDE.html","id":"model-classes-s3","dir":"","previous_headings":"Architecture","what":"Model Classes (S3)","title":"CLAUDE.md","text":"Three main model classes, inheriting rldm: - armamod - VARMA models (left matrix fraction description) - stspmod - State space models - rmfdmod - Right matrix fraction description (experimental, many methods yet implemented)","code":""},{"path":"https://bfunovits.github.io/RLDM/CLAUDE.html","id":"processing-pipeline","dir":"","previous_headings":"Architecture","what":"Processing Pipeline","title":"CLAUDE.md","text":"","code":"Model Construction (armamod/stspmod/rmfdmod)     ↓ Parameter Templates (tmpl_* functions) - maps deep parameters to linear parameters     ↓ Derived Objects (autocov, freqresp, impresp, spectrald)     ↓ Estimation (moment-based or likelihood)     ↓ Model Comparison & Diagnostics"},{"path":"https://bfunovits.github.io/RLDM/CLAUDE.html","id":"key-file-organization-numeric-functional-system","dir":"","previous_headings":"Architecture","what":"Key File Organization (Numeric Functional System)","title":"CLAUDE.md","text":"R files use numeric prefix system organized purpose/workflow: Key principle: Files organized code (operations), object type operates (S3 dispatch handles representation differences). numeric convention ensures files load dependency order groups related functionality together. See R/README.md detailed organization documentation.","code":""},{"path":"https://bfunovits.github.io/RLDM/CLAUDE.html","id":"c-code-src","dir":"","previous_headings":"Architecture","what":"C++ Code (src/)","title":"CLAUDE.md","text":"kf.cpp - Kalman filter implementation solve_fwd_bwd_cll.cpp - Forward-backward solving conditional log-likelihood rls_core.cpp - Recursive least squares (exponential forgetting windowed variants) Makevars - Links OpenMP, LAPACK, BLAS","code":""},{"path":"https://bfunovits.github.io/RLDM/CLAUDE.html","id":"key-entry-points","dir":"","previous_headings":"","what":"Key Entry Points","title":"CLAUDE.md","text":"Model construction: armamod(), stspmod(), rmfdmod() Estimation: est_ML(), est_ar(), est_arma_hrk3(), est_stsp_cca() Analysis: autocov(), spectrald(), impresp(), freqresp() Solving: solve_de(), solve_inverse_de() Comparison: KL_divergence(), pm_test(), compare_estimates()","code":""},{"path":[]},{"path":"https://bfunovits.github.io/RLDM/CLAUDE.html","id":"vignettes","dir":"","previous_headings":"Documentation","what":"Vignettes","title":"CLAUDE.md","text":"RLDM three main vignettes organized different user levels: Beginner-friendly introduction Simple univariate bivariate examples ~10-15 minute read executable code Best starting point new users Practical end--end workflow Blanchard-Quah economic data analysis Comparing multiple estimation methods Model diagnostics, prediction, interpretation Comprehensive class method documentation Mathematical foundations Method selection guidance Reference material advanced users Developer Documentation: - inst/doc/technical_notes.Rmd - Deep mathematical derivations algorithm details - Durbin-Levinson-Whittle recursions - HRK Stage 3 algorithm specifications - ARMA ACF computation - built vignette included package","code":""},{"path":"https://bfunovits.github.io/RLDM/CLAUDE.html","id":"documentation-tools","dir":"","previous_headings":"Documentation","what":"Documentation Tools","title":"CLAUDE.md","text":"Uses Roxygen2 markdown support References managed via Rdpack Online docs: https://bfunovits.github.io/RLDM/","code":""},{"path":[]},{"path":"https://bfunovits.github.io/RLDM/CONTRIBUTING.html","id":"numeric-functional-system","dir":"","previous_headings":"","what":"Numeric Functional System","title":"R/ Folder Organization","text":"RLDM uses numeric prefix system organized purpose/workflow, object type. organization scheme emphasizes mathematical operations (estimation, properties, visualization) conceptually independent model representation.","code":""},{"path":"https://bfunovits.github.io/RLDM/CONTRIBUTING.html","id":"core-philosophy","dir":"","previous_headings":"Numeric Functional System","what":"Core Philosophy","title":"R/ Folder Organization","text":"Representations (lmfd/armamod, stsp/stspmod, rmfd/rmfdmod) just different encodings rational process Operations (estimation, properties, prediction) work representations via S3 dispatch Templates map deep (free) parameters model parameters using affine transformations Users think terms workflow (“want estimate”) representation","code":""},{"path":[]},{"path":"https://bfunovits.github.io/RLDM/CONTRIBUTING.html","id":"load-order","dir":"","previous_headings":"Numeric Functional System","what":"Load Order","title":"R/ Folder Organization","text":"Files load alphabetically. Dependencies must come dependents: 01 - Core classes (needed everything) 02 - Templates (needed estimation model creation) 03-04 - Properties operations (use classes) 05-07 - Higher-level functionality (use estimation/properties) 08 - Utilities (minimal dependencies) 99 - Auto-generated (loaded last)","code":""},{"path":"https://bfunovits.github.io/RLDM/CONTRIBUTING.html","id":"file-naming-convention","dir":"","previous_headings":"Numeric Functional System","what":"File Naming Convention","title":"R/ Folder Organization","text":"NN_category_subcategory.R : NN = Two-digit numeric prefix category = Functional area (single word: representations, templates, properties, etc.) subcategory = Specific aspect (method name, model type, descriptor) Examples: - 02_templates.R - template-related functions - 03_properties_autocov.R - Autocovariance computation - 04_timeseries_solve.R - Difference equation solving - 05_estimation_ar.R - AR model estimation - 06_visualization_plot.R - General plotting methods","code":""},{"path":"https://bfunovits.github.io/RLDM/CONTRIBUTING.html","id":"s3-method-organization","dir":"","previous_headings":"Numeric Functional System","what":"S3 Method Organization","title":"R/ Folder Organization","text":"Key principle: Methods grouped operation (noun), class. Example: 03_properties_autocov.R contains: - autocov() generic - autocov.armamod() - via Yule-Walker equations - autocov.stspmod() - via Lyapunov equation - autocov.rmfdmod() - experimental - autocov.default() - time series data emphasizes: Operation primary, representation implementation detail.","code":""},{"path":"https://bfunovits.github.io/RLDM/CONTRIBUTING.html","id":"roxygen2-integration","dir":"","previous_headings":"Numeric Functional System","what":"Roxygen2 Integration","title":"R/ Folder Organization","text":"file header comment block (see example ) Cross-references via @rdname related functions @include directives specify file loading order documentation Roxygen tags group documentation functional area (@name model_structures, etc.)","code":""},{"path":"https://bfunovits.github.io/RLDM/CONTRIBUTING.html","id":"template-header-format","dir":"","previous_headings":"Numeric Functional System","what":"Template Header Format","title":"R/ Folder Organization","text":"file begin structured header comment:","code":"# ==================================================================== # Category Name # # Purpose: [Clear, single-sentence description] #   - Function 1 (brief role) #   - Function 2 (brief role) # # Key Operations: [What this file does in the workflow] # Representations: [Which model types, if relevant] # Dependencies: [Which files this imports/depends on] # Related Files: [Cross-references to related functionality] # ===================================================================="},{"path":"https://bfunovits.github.io/RLDM/CONTRIBUTING.html","id":"transition-from-alphabetical-system","dir":"","previous_headings":"Numeric Functional System","what":"Transition from Alphabetical System","title":"R/ Folder Organization","text":"previous alphabetical prefix system (aa_, ab_, aca_, etc.) reorganized: Old → New: - aa_* → 01_representations_* - ab_* → 02_templates - aca_*, acb_*, ... → 03_properties_* - ada_*, adb_* → 03_properties_poles, 04_timeseries_* - aeb_*, aec_* → 08_utilities_* - aeaa_* → 06_visualization_* - afa* → 05_estimation_* - ag_* → 07_comparison_*","code":""},{"path":"https://bfunovits.github.io/RLDM/CONTRIBUTING.html","id":"verification-commands","dir":"","previous_headings":"Numeric Functional System","what":"Verification Commands","title":"R/ Folder Organization","text":"reorganization, verify everything still works:","code":"# Load package in development mode devtools::load_all()  # Generate documentation (respects new file organization) devtools::document()  # Check for any warnings/errors devtools::check()  # Run test suite devtools::test()"},{"path":"https://bfunovits.github.io/RLDM/CONTRIBUTING.html","id":"guidelines-for-adding-new-files","dir":"","previous_headings":"Numeric Functional System","what":"Guidelines for Adding New Files","title":"R/ Folder Organization","text":"Choose right prefix based code Use descriptive names - subcategory clarify function Add header comment explaining purpose dependencies Check load order - ensure dependencies load first (automatic via naming) Use @rdname related functions documentation Add tests implementing new functionality","code":""},{"path":"https://bfunovits.github.io/RLDM/CONTRIBUTING.html","id":"notes","dir":"","previous_headings":"Numeric Functional System","what":"Notes","title":"R/ Folder Organization","text":"23 R files (excluding RcppExports.R) fit within categories 01-08 Load order automatically handled via alphabetical sorting filenames subdirectories used (R package requirement) Documentation unified across files via Roxygen2 tags","code":""},{"path":"https://bfunovits.github.io/RLDM/LICENSE.html","id":"license","dir":"","previous_headings":"","what":"License","title":"NA","text":"package licensed GPL-3 license. See https://www.gnu.org/licenses/gpl-3.0.html details. Copyright (c) 2026 Wolfgang Scherrer, Bernd Funovits","code":""},{"path":"https://bfunovits.github.io/RLDM/articles/0_getting_started.html","id":"what-is-rldm","dir":"Articles","previous_headings":"","what":"What is RLDM?","title":"Getting Started with RLDM","text":"RLDM (Rational Linear Dynamic Models) R package modeling analyzing stationary time series using linear systems theory. implements powerful methods : Autoregressive (AR) models - Simple, interpretable baseline models ARMA (VARMA) models - Flexible models combining AR Moving Average terms State Space models - Compact representations complex dynamics Impulse response analysis - Understanding shocks propagate system Spectral analysis - Analyzing behavior different frequencies Model comparison - Selecting best model data RLDM particularly useful multivariate time series data want go beyond simple AR(1) models capture complex dependencies.","code":""},{"path":"https://bfunovits.github.io/RLDM/articles/0_getting_started.html","id":"installation","dir":"Articles","previous_headings":"","what":"Installation","title":"Getting Started with RLDM","text":"RLDM depends companion package rationalmatrices matrix fraction computations. Install GitHub: load package:","code":"# Install dependencies first remotes::install_github(\"bfunovits/rationalmatrices\")  # Then install RLDM remotes::install_github(\"bfunovits/RLDM\") library(RLDM)"},{"path":"https://bfunovits.github.io/RLDM/articles/0_getting_started.html","id":"simple-ar-model-univariate-example","dir":"Articles","previous_headings":"","what":"Simple AR Model: Univariate Example","title":"Getting Started with RLDM","text":"Let’s start simple univariate time series. ’ll generate synthetic data AR(2) process estimate model.","code":""},{"path":"https://bfunovits.github.io/RLDM/articles/0_getting_started.html","id":"generate-ar2-data","dir":"Articles","previous_headings":"Simple AR Model: Univariate Example","what":"Generate AR(2) Data","title":"Getting Started with RLDM","text":"","code":"# Simulate an AR(1) process: y_t = 0.8*y_{t-1} + u_t # # In RLDM convention: y_t - 0.8*y_{t-1} = u_t a_coef <-c(1, -0.8)  # AR coefficient with sign convention b_coef <- c(1)     # MA term (just white noise) sys <- lmfd(a_coef, b_coef)  # Create ARMA model with noise variance = 1 model_true <- armamod(sys, sigma_L = 1, label = \"AR(1)\")  # Simulate 200 observations y_list <- sim(model_true, n.obs = 200) y <- y_list$y  # Plot the simulated data plot(y, main = \"Simulated AR(1) Process\", ylab = \"y_t\", type = 'l')"},{"path":"https://bfunovits.github.io/RLDM/articles/0_getting_started.html","id":"estimate-the-model","dir":"Articles","previous_headings":"Simple AR Model: Univariate Example","what":"Estimate the Model","title":"Getting Started with RLDM","text":"Now let’s estimate AR model data using Yule-Walker method. RLDM uses information criteria (AIC) automatically select order:","code":"# Estimate AR model with automatic order selection result <- est_ar(y, p.max = 10)  # Display basic information cat(\"Selected AR order:\", result$p, \"\\n\") #> Selected AR order: 1 cat(\"Number of parameters:\", result$p, \"\\n\") #> Number of parameters: 1 cat(\"Information Criterion:\", result$stats[result$p + 1, \"ic\"], \"\\n\\n\") #> Information Criterion: -0.03234463  # View the estimated model result$model #> ARMA model [1,1] with orders p = 1 and q = 0 #> AR polynomial a(z): #>      z^0 [,1]   z^1 [,1] #> [1,]        1 -0.7855093 #> MA polynomial b(z): #>      z^0 [,1] #> [1,]        1 #> Left square root of noise covariance Sigma: #>           u[1] #> u[1] 0.9790502"},{"path":"https://bfunovits.github.io/RLDM/articles/0_getting_started.html","id":"model-diagnostics","dir":"Articles","previous_headings":"Simple AR Model: Univariate Example","what":"Model Diagnostics","title":"Getting Started with RLDM","text":"Check model adequately captures dynamics:","code":"# Compute residuals residuals <- solve_inverse_de(result$model$sys, y)$u  # Plot residuals par(mfrow = c(2, 1)) plot(residuals, main = \"Residuals\", type = 'l', ylab = \"Residuals\") abline(h = 0, col = 'red', lty = 2)  # ACF of residuals (should show no significant correlations) acf(residuals, main = \"ACF of Residuals\") par(mfrow = c(1, 1))"},{"path":"https://bfunovits.github.io/RLDM/articles/0_getting_started.html","id":"make-predictions","dir":"Articles","previous_headings":"Simple AR Model: Univariate Example","what":"Make Predictions","title":"Getting Started with RLDM","text":"Forecast future values:","code":"# Predict 10 steps ahead n.ahead <- 10 pred <- predict(result$model, y, h = 1, n.ahead = n.ahead)  # Combine data and predictions n_obs <- length(y) plot_range <- max(1, n_obs - 40):n_obs plot(plot_range, y[plot_range], type = 'l',      xlab = \"Time\", ylab = \"Value\",      main = \"Data and Predictions\")  # Add predictions pred_time <- (n_obs+1):(n_obs+n.ahead) lines(pred_time, pred$yhat.ahead[, 1], col = 'blue', lwd = 2)  # Add confidence bands (approximate, assuming normality) # Extract the variance for each step ahead (the variance increases with horizon) variance_ahead <- as.vector(pred$sigmahat.ahead[1, 1, ]) se <- sqrt(variance_ahead) lines(pred_time, pred$yhat.ahead[, 1] + 1.96*se, col = 'blue', lty = 2) lines(pred_time, pred$yhat.ahead[, 1] - 1.96*se, col = 'blue', lty = 2)  legend(\"topleft\", c(\"Data\", \"Forecast\", \"95% CI\"),        col = c(\"black\", \"blue\", \"blue\"), lty = c(1, 1, 2))"},{"path":"https://bfunovits.github.io/RLDM/articles/0_getting_started.html","id":"multivariate-example-bivariate-var","dir":"Articles","previous_headings":"","what":"Multivariate Example: Bivariate VAR","title":"Getting Started with RLDM","text":"Now let’s work multivariate system - 2-dimensional VAR(1) model.","code":""},{"path":"https://bfunovits.github.io/RLDM/articles/0_getting_started.html","id":"generate-bivariate-data","dir":"Articles","previous_headings":"Multivariate Example: Bivariate VAR","what":"Generate Bivariate Data","title":"Getting Started with RLDM","text":"","code":"# Define a 2D VAR(1) model # # [ y1_t ]   [ 0.8  0.2 ] [ y1_{t-1} ]   [ u1_t ] # [ y2_t ] = [ 0.1  0.7 ] [ y2_{t-1} ] + [ u2_t ]  # AR matrices (note sign convention) A1 <- matrix(c(1, 0, -0.8, -0.2,                 0, 1, -0.1, -0.7),               nrow = 2, byrow = TRUE) A1 = array(A1, dim = c(2,2,2))             B0 <- diag(2)  # Create VARMA system sys_var <- lmfd(A1, B0)  # Noise covariance (correlation between u1 and u2) rho <- 0.5 Sigma_L <- matrix(c(1, rho, 0, sqrt(1 - rho^2)), nrow = 2)  # Create model and simulate model_var <- armamod(sys_var, sigma_L = Sigma_L,                      names = c(\"Series 1\", \"Series 2\"))  y_var_list <- sim(model_var, n.obs = 300) y_var <- y_var_list$y  # Plot both series plot.ts(y_var, main = \"Bivariate VAR(1) Process\")"},{"path":"https://bfunovits.github.io/RLDM/articles/0_getting_started.html","id":"estimate-the-multivariate-model","dir":"Articles","previous_headings":"Multivariate Example: Bivariate VAR","what":"Estimate the Multivariate Model","title":"Getting Started with RLDM","text":"","code":"# Estimate VAR model result_var <- est_ar(y_var, p.max = 5)  cat(\"Selected VAR order:\", result_var$p, \"\\n\") #> Selected VAR order: 1 cat(\"Total parameters:\", result_var$p * 2^2, \"\\n\\n\") #> Total parameters: 4  # View estimated model result_var$model #> ARMA model [2,2] with orders p = 1 and q = 0 #> AR polynomial a(z): #>      z^0 [,1]  [,2]    z^1 [,1]       [,2] #> [1,]        1     0 -0.73515671 -0.2815920 #> [2,]        0     1 -0.06168781 -0.7129382 #> MA polynomial b(z): #>      z^0 [,1]  [,2] #> [1,]        1     0 #> [2,]        0     1 #> Left square root of noise covariance Sigma: #>           u[1]      u[2] #> u[1] 1.0159564 0.0000000 #> u[2] 0.4655142 0.8032231"},{"path":"https://bfunovits.github.io/RLDM/articles/0_getting_started.html","id":"analyze-the-system","dir":"Articles","previous_headings":"Multivariate Example: Bivariate VAR","what":"Analyze the System","title":"Getting Started with RLDM","text":"Impulse Response Function: system respond shocks?  Spectral Density: Understand frequency domain behavior:  Autocovariance Structure:","code":"# Compute impulse responses irf <- impresp(result_var$model, lag.max = 20)  # Plot impulse responses plot(irf,      main = \"Impulse Response Functions\",      legend = c(\"shock to Series 1\", \"shock to Series 2\")) # Compute and plot spectral density spec <- spectrald(result_var$model, n.f = 128)  plot(spec,      main = \"Spectral Density\",      legend = c(\"Series 1\", \"Series 2\")) # Compute autocovariances acov <- autocov(result_var$model, lag.max = 10, type = \"correlation\")  # Plot correlations plot(acov, main = \"Sample and Model ACF\")"},{"path":"https://bfunovits.github.io/RLDM/articles/0_getting_started.html","id":"state-space-example-simple-dynamic-system","dir":"Articles","previous_headings":"","what":"State Space Example: Simple Dynamic System","title":"Getting Started with RLDM","text":"State space models provide alternative way represent dynamic systems using hidden state variables. particularly useful : Minimal representations complex dynamics Interpretable latent components (trends, cycles, factors) Numerically stable computations balanced realizations Flexible model structures beyond standard ARMA forms","code":""},{"path":"https://bfunovits.github.io/RLDM/articles/0_getting_started.html","id":"create-and-simulate-a-state-space-model","dir":"Articles","previous_headings":"State Space Example: Simple Dynamic System","what":"Create and Simulate a State Space Model","title":"Getting Started with RLDM","text":"Let’s create state space representation AR(1) process saw earlier (yt=0.8yt−1+uty_t = 0.8y_{t-1} + u_t). state space form: $$ s_{t+1} = 0.8 s_t + u_t \\\\ y_t = s_t $$ sts_t state variable (case, simply yty_t ).","code":"# State space representation of AR(1) with coefficient 0.8 A <- matrix(0.8)  # State transition B <- matrix(1)    # Input matrix C <- matrix(1)    # Observation matrix D <- matrix(0)    # Direct feedthrough  # Create state space system sys_ss <- stsp(A, B, C, D)  # Create model with unit noise variance model_ss <- stspmod(sys_ss, sigma_L = matrix(1), label = \"State Space AR(1)\")  # Simulate 200 observations (different seed from earlier example) set.seed(123) sim_data <- sim(model_ss, n.obs = 200) y_ss <- sim_data$y  # Plot the simulated data plot.ts(y_ss, main = \"Simulated State Space AR(1) Process\",         ylab = \"y_t\", type = 'l')"},{"path":"https://bfunovits.github.io/RLDM/articles/0_getting_started.html","id":"estimate-state-space-model-from-data","dir":"Articles","previous_headings":"State Space Example: Simple Dynamic System","what":"Estimate State Space Model from Data","title":"Getting Started with RLDM","text":"Now let’s estimate state space model simulated data using Canonical Correlation Analysis (CCA) method:","code":"# Estimate state space model using CCA result_ss <- est_stsp_ss(y_ss, method = \"cca\", mean_estimate = \"zero\")  cat(\"Estimated state space model:\\n\") #> Estimated state space model: print(result_ss$model) #> state space model [1,1] with s = 1 states #>            s[1]       u[1] #> s[1]  0.7490384 -0.7084876 #> x[1] -1.0359971  1.0000000 #> Left square root of noise covariance Sigma: #>          u[1] #> u[1] 0.935128  cat(\"\\nSelected state dimension:\", result_ss$s, \"\\n\") #>  #> Selected state dimension: 1 cat(\"Estimated A matrix:\", result_ss$model$sys$A, \"\\n\") #> Estimated A matrix: 0.7490384 cat(\"True A matrix:\", A, \"\\n\") #> True A matrix: 0.8"},{"path":"https://bfunovits.github.io/RLDM/articles/0_getting_started.html","id":"analyze-the-estimated-model","dir":"Articles","previous_headings":"State Space Example: Simple Dynamic System","what":"Analyze the Estimated Model","title":"Getting Started with RLDM","text":"","code":"# Compute impulse responses irf_ss <- impresp(result_ss$model, lag.max = 20)  # Plot impulse responses plot(irf_ss, main = \"Impulse Response Function\") # Make one-step ahead predictions pred_ss <- predict(result_ss$model, y_ss, h = 1)  # Plot recent data and predictions n_obs <- length(y_ss) plot_range <- max(1, n_obs - 40):n_obs plot(plot_range, y_ss[plot_range], type = 'l',      xlab = \"Time\", ylab = \"Value\",      main = \"Data and One-Step Predictions\") lines(plot_range[-1], pred_ss$yhat[plot_range[-1], 1, 1],       col = 'blue', lwd = 2) legend(\"topleft\", c(\"Data\", \"Prediction\"),        col = c(\"black\", \"blue\"), lty = 1)"},{"path":"https://bfunovits.github.io/RLDM/articles/0_getting_started.html","id":"comparing-state-space-and-ar-representations","dir":"Articles","previous_headings":"State Space Example: Simple Dynamic System","what":"Comparing State Space and AR Representations","title":"Getting Started with RLDM","text":"state space representation equivalent AR(1) model estimated earlier. RLDM allows convert representations:","code":"# Convert state space to ARMA representation # Note: lmfd() conversion from state space to ARMA requires minimal realization # and is not directly supported. This conversion is commented out to avoid build errors. # arma_from_ss <- armamod(lmfd(result_ss$model$sys), #                        sigma_L = result_ss$model$sigma_L) # cat(\"ARMA representation of estimated state space model:\\n\") # print(arma_from_ss) cat(\"Note: Direct conversion from state space to ARMA representation requires\\n\") #> Note: Direct conversion from state space to ARMA representation requires cat(\"minimal realization and is not shown in this vignette.\\n\") #> minimal realization and is not shown in this vignette."},{"path":"https://bfunovits.github.io/RLDM/articles/0_getting_started.html","id":"when-to-use-state-space-models","dir":"Articles","previous_headings":"State Space Example: Simple Dynamic System","what":"When to Use State Space Models","title":"Getting Started with RLDM","text":"State space models particularly useful : - need interpretable latent states (e.g., trend, cycle, seasonal components) - system natural state variables (e.g., physical systems) - want minimal representations balanced realizations - ’re working high-dimensional systems state dimension can smaller AR order advanced state space modeling, including different parameterizations (CCA, DDLC, echelon form) estimation methods, see Case Study vignette.","code":""},{"path":[]},{"path":"https://bfunovits.github.io/RLDM/articles/0_getting_started.html","id":"for-real-world-applications","dir":"Articles","previous_headings":"Where to Go Next","what":"For Real-World Applications","title":"Getting Started with RLDM","text":"Check Case Study vignette (vignette(\"1_case_study\")) walks : - Economic data analysis (GDP growth unemployment) - Comparing multiple estimation methods - Selecting best model - Forecasting model diagnostics","code":""},{"path":"https://bfunovits.github.io/RLDM/articles/0_getting_started.html","id":"for-more-details","dir":"Articles","previous_headings":"Where to Go Next","what":"For More Details","title":"Getting Started with RLDM","text":"Technical Reference vignette (vignette(\"2_technical_reference\")) provides: - Detailed explanation model class - Mathematical foundations - Guidance method selection - Parameter templates estimation algorithms","code":""},{"path":[]},{"path":"https://bfunovits.github.io/RLDM/articles/0_getting_started.html","id":"quick-tips","dir":"Articles","previous_headings":"","what":"Quick Tips","title":"Getting Started with RLDM","text":"Start simple: Begin est_ar() understand data moving complex models Check diagnostics: Always plot residuals ACF verify model Use AIC: automatic order selection est_ar() est_arma_hrk() works well cases Compare models: Use compare_estimates() systematically compare methods Multivariate: RLDM really shines multivariate data relationships matter","code":""},{"path":"https://bfunovits.github.io/RLDM/articles/0_getting_started.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Getting Started with RLDM","text":"(Scherrer Deistler 2019)","code":""},{"path":[]},{"path":"https://bfunovits.github.io/RLDM/articles/1_case_study.html","id":"the-blanchard-quah-dataset","dir":"Articles","previous_headings":"Introduction and Research Question","what":"The Blanchard-Quah Dataset","title":"Case Study: Economic Data Analysis with RLDM","text":"case study analyzes quarterly US economic data real GDP growth rates detrended unemployment rates Blanchard-Quah (1989) study. research question : underlying shocks drive GDP growth unemployment, interact? classic question macroeconomics: separating supply shocks (permanently affect output) demand shocks (temporarily affect unemployment growth).","code":""},{"path":"https://bfunovits.github.io/RLDM/articles/1_case_study.html","id":"methods-overview","dir":"Articles","previous_headings":"Introduction and Research Question","what":"Methods Overview","title":"Case Study: Economic Data Analysis with RLDM","text":"analysis, ’ll compare several estimation approaches find model best captures relationships: AR Models (baseline) - Simple autoregressive models State Space Models - Flexible representations different estimation algorithms ARMA Models - Parsimonious alternatives combining AR MA terms method different strengths, ’ll compare performance systematically.","code":""},{"path":"https://bfunovits.github.io/RLDM/articles/1_case_study.html","id":"data-preparation-and-visualization","dir":"Articles","previous_headings":"","what":"Data Preparation and Visualization","title":"Case Study: Economic Data Analysis with RLDM","text":"Data Summary: - Total observations: 159 quarters 1948-04-01 1987-10-01 - Training set: 87 observations (model estimation) - Test set: 72 observations (--sample validation) - Variables: GDP growth rate unemployment rate (standardized unit variance)","code":"# Load the Blanchard-Quah dataset y = BQdata_xts  # Define split point for train/test break_date = as_date(\"1970-01-01\")  y_train = BQdata_xts[index(BQdata_xts) < break_date] y_test  = BQdata_xts[index(BQdata_xts) >= break_date] dim_out = ncol(y_train)  # Visualize the data plot(y) addLegend('topleft', c('GDP growth rate', 'Unemployment rate'),           col = c('black', 'red'), lwd = 2, bty = 'n') addEventLines(xts(\"Train/Test Split\", break_date), col = 'blue', on = NA)"},{"path":[]},{"path":"https://bfunovits.github.io/RLDM/articles/1_case_study.html","id":"what-are-ar-models","dir":"Articles","previous_headings":"Baseline: AR Models","what":"What are AR Models?","title":"Case Study: Economic Data Analysis with RLDM","text":"Autoregressive (AR) models form simplest baseline comparison. AR(p) model expresses variable linear combination past p values plus white noise: yt=a1yt−1+⋯+apyt−p+uty_t = a_1 y_{t-1} + \\cdots + a_p y_{t-p} + u_t use: - Understanding basic dynamics lag structure - Quick baseline model comparison - need interpretable, simple models - Automatic order selection via AIC multivariate data, estimate VAR(p) model treats variable AR cross-variable dependencies.","code":""},{"path":"https://bfunovits.github.io/RLDM/articles/1_case_study.html","id":"estimation","dir":"Articles","previous_headings":"Baseline: AR Models","what":"Estimation","title":"Case Study: Economic Data Analysis with RLDM","text":"est_ar() function uses Yule-Walker estimation (statistically efficient) automatic order selection: Selected AR order: 1","code":"# Estimate AR model with automatic order selection out = est_ar(y_train, mean_estimate = 'zero')  # View available outputs cat(\"Output components:\\n\") #> Output components: cat(paste(names(out), collapse = \", \"), \"\\n\\n\") #> model, p, stats, y.mean, ll  # Display statistics for different orders cat(\"Model selection statistics:\\n\") #> Model selection statistics: print(out$stats) #>        p n.par lndetSigma        ic #>  [1,]  0     0   1.013188  1.013188 #>  [2,]  1     4  -2.193313 -2.101359 #>  [3,]  2     8  -2.231092 -2.047184 #>  [4,]  3    12  -2.257910 -1.982048 #>  [5,]  4    16  -2.317073 -1.949257 #>  [6,]  5    20  -2.336830 -1.877060 #>  [7,]  6    24  -2.362950 -1.811226 #>  [8,]  7    28  -2.380498 -1.736819 #>  [9,]  8    32  -2.452787 -1.717155 #> [10,]  9    36  -2.461676 -1.634090 #> [11,] 10    40  -2.522346 -1.602806 #> [12,] 11    44  -2.539423 -1.527929 #> [13,] 12    48  -2.565177 -1.461729"},{"path":"https://bfunovits.github.io/RLDM/articles/1_case_study.html","id":"interpretation","dir":"Articles","previous_headings":"Baseline: AR Models","what":"Interpretation","title":"Case Study: Economic Data Analysis with RLDM","text":"estimated AR model captures first-order dynamics data:","code":"# View the model print(out$model) #> ARMA model [2,2] with orders p = 1 and q = 0 #> AR polynomial a(z): #>      z^0 [,1]  [,2]   z^1 [,1]       [,2] #> [1,]        1     0 -0.4579266 -0.1795184 #> [2,]        0     1  0.3098179 -0.9328347 #> MA polynomial b(z): #>      z^0 [,1]  [,2] #> [1,]        1     0 #> [2,]        0     1 #> Left square root of noise covariance Sigma: #>            u[1]      u[2] #> u[1]  0.9567816 0.0000000 #> u[2] -0.2050479 0.3490723  # Store for later comparison models    = list(AR1 = out$model) estimates = list(AR1 = list(model = out$model, n.par = out$p * dim_out^2))"},{"path":[]},{"path":"https://bfunovits.github.io/RLDM/articles/1_case_study.html","id":"what-are-state-space-models","dir":"Articles","previous_headings":"State Space Models","what":"What are State Space Models?","title":"Case Study: Economic Data Analysis with RLDM","text":"State space models provide flexible framework capturing complex dynamics: st+1=Ast+Buts_{t+1} = s_t + B u_tyt=Cst+Duty_t = C s_t + D u_t sts_t hidden state variables matrices , B, C, D define system dynamics. use: - Complex systems hidden variables - need interpretable latent factors - Flexible different specifications (CCA, DDLC, echelon form) ’ll estimate state space models using three different parameterizations:","code":""},{"path":"https://bfunovits.github.io/RLDM/articles/1_case_study.html","id":"cca-estimate-canonical-correlation-analysis","dir":"Articles","previous_headings":"State Space Models > What are State Space Models?","what":"CCA Estimate (Canonical Correlation Analysis)","title":"Case Study: Economic Data Analysis with RLDM","text":"CCA data-driven method finding informative state representation. ’s good don’t priori knowledge system structure.","code":"out = est_stsp_ss(y_train, method = 'cca', mean_estimate = 'zero')  cat(\"CCA estimation output components:\\n\") #> CCA estimation output components: print(names(out)) #> [1] \"model\"  \"models\" \"s\"      \"stats\"  \"info\"   \"y.mean\"  cat(\"\\n\\nModel selection statistics (order selection):\\n\") #>  #>  #> Model selection statistics (order selection): print(out$stats) #>      s n.par       Hsv lndetSigma criterion #> [1,] 0     0        NA         NA 0.9480826 #> [2,] 1     4 0.9736953         NA 0.5022205 #> [3,] 2     8 0.5448774  -2.229582 0.4863466 #> [4,] 3    12 0.2751153         NA 0.6217772 #> [5,] 4    16 0.0760915         NA 0.8213164  cat(\"\\n\\nSelected model:\\n\") #>  #>  #> Selected model: print(out$model) #> state space model [2,2] with s = 2 states #>            s[1]       s[2]       u[1]      u[2] #> s[1]  0.9191263  0.1912447 -0.1103757 0.7043585 #> s[2] -0.3340845  0.6472138 -0.6742802 0.2083379 #> x[1]  0.1800227 -0.5626354  1.0000000 0.0000000 #> x[2]  1.4254461  0.1339044  0.0000000 1.0000000 #> Left square root of noise covariance Sigma: #>            u[1]      u[2] #> u[1]  0.9477920 0.0000000 #> u[2] -0.1968541 0.3460504  models$CCA    = out$model estimates$CCA = list(model = out$model, n.par = 2*dim_out*out$s)"},{"path":"https://bfunovits.github.io/RLDM/articles/1_case_study.html","id":"ddlc-estimate-ml-with-diagonal-direct-lead-coefficient","dir":"Articles","previous_headings":"State Space Models > What are State Space Models?","what":"DDLC Estimate (ML with Diagonal Direct-Lead Coefficient)","title":"Case Study: Economic Data Analysis with RLDM","text":"DDLC uses maximum likelihood estimation specific parameterization ’s often numerically stable. refine CCA estimate iterative ML optimization:","code":"# Create template for ML estimation tmpl = tmpl_DDLC(models$CCA, balance = 'minimum phase', sigma_L = 'identity') th0 = numeric(tmpl$n.par)  # Define likelihood function llfun = ll_FUN(tmpl, y_train, skip = 0, which = \"concentrated\")  # Optimization with increasing iterations for (maxit in c(10, 20, 200)) {   control = list(trace = 0, fnscale = -1, maxit = maxit)   out = optim(th0, llfun, method = 'BFGS', control = control)   th = out$par   model = fill_template(th, tmpl)    # Reparametrize for next iteration   if (maxit < 200) {     tmpl = tmpl_DDLC(model, balance = 'minimum phase', sigma_L = 'identity')     th0 = numeric(tmpl$n.par)   } }  # Ensure Cholesky factor is lower triangular model$sigma_L = t(chol(model$sigma_L))  models$DDLC    = model estimates$DDLC = list(model = model, n.par = tmpl$n.par)  cat(\"DDLC Model (ML refined from CCA):\\n\") #> DDLC Model (ML refined from CCA): print(model) #> state space model [2,2] with s = 2 states #>            s[1]       s[2]       u[1]       u[2] #> s[1]  0.9314125 -0.5174226 0.05086557 -0.8108537 #> s[2]  0.3158625  0.5107108 0.01463569  1.2381876 #> x[1] -0.2628945 -1.3907238 1.00000000  0.0000000 #> x[2] -1.2551652  0.4318004 0.00000000  1.0000000 #> Left square root of noise covariance Sigma: #>      u[1] u[2] #> u[1]    1    0 #> u[2]    0    1"},{"path":"https://bfunovits.github.io/RLDM/articles/1_case_study.html","id":"echelon-form-ml-estimate","dir":"Articles","previous_headings":"State Space Models > What are State Space Models?","what":"Echelon Form ML Estimate","title":"Case Study: Economic Data Analysis with RLDM","text":"Echelon form canonical representation provides parsimony structural restrictions. First, compute Kronecker indices impulse response:","code":"lag.max = 20 ir = impresp(models$CCA, lag.max = lag.max)$irf     # Impulse response nu = pseries2nu(ir)                                  # Kronecker indices  cat(\"Kronecker indices (system order structure):\\n\") #> Kronecker indices (system order structure): print(nu) #> [1] 1 1  # Transform CCA estimate into echelon form model = stspmod(sys = pseries2stsp(ir, method = 'echelon')$Xs,                 sigma_L = models$CCA$sigma_L)  # Verify the conversion preserves the system cat(\"\\nVerifying echelon form preserves autocovariance:\\n\") #>  #> Verifying echelon form preserves autocovariance: print(all.equal(autocov(model, lag.max = lag.max),                 autocov(models$CCA, lag.max = lag.max))) #> [1] TRUE  # ML refinement of echelon form tmpl = tmpl_stsp_echelon(nu, sigma_L = 'identity') th0 = extract_theta(model, tmpl, on_error = 'stop', ignore_sigma_L = TRUE)  llfun = ll_FUN(tmpl, y_train, skip = 0, which = \"concentrated\") control = list(trace = 0, fnscale = -1, maxit = 500)  out = optim(th0, llfun, method = 'BFGS', control = control) th = out$par model = fill_template(th, tmpl)  models$SSECF    = model estimates$SSECF = list(model = model, n.par = tmpl$n.par)  cat(\"Echelon Form State Space Model (ML):\\n\") #> Echelon Form State Space Model (ML): print(model) #> state space model [2,2] with s = 2 states #>            s[1]      s[2]       u[1]       u[2] #> s[1]  0.5316189 0.2011516  0.3138400 -0.4001788 #> s[2] -0.3600091 0.9572035 -0.1629595  1.3478205 #> x[1]  1.0000000 0.0000000  1.0000000  0.0000000 #> x[2]  0.0000000 1.0000000  0.0000000  1.0000000 #> Left square root of noise covariance Sigma: #>      u[1] u[2] #> u[1]    1    0 #> u[2]    0    1"},{"path":[]},{"path":"https://bfunovits.github.io/RLDM/articles/1_case_study.html","id":"what-are-arma-models","dir":"Articles","previous_headings":"ARMA Models","what":"What are ARMA Models?","title":"Case Study: Economic Data Analysis with RLDM","text":"ARMA (VARMA multivariate) models combine autoregressive moving average components: a0yt+a1yt−1+⋯+apyt−p=b0ut+b1ut−1+⋯+bqut−qa_0 y_t + a_1 y_{t-1} + \\cdots + a_p y_{t-p} = b_0 u_t + b_1 u_{t-1} + \\cdots + b_q u_{t-q} use: - want parsimony (fewer parameters AR) - Capturing short-term longer-term dependencies - MA-type features data Hannan-Rissanen-Kavalieris (HRK) procedure provides good initial estimates, refine ML.","code":""},{"path":"https://bfunovits.github.io/RLDM/articles/1_case_study.html","id":"hrk-estimate","dir":"Articles","previous_headings":"ARMA Models > What are ARMA Models?","what":"HRK Estimate","title":"Case Study: Economic Data Analysis with RLDM","text":"HRK three-stage procedure provides consistent ARMA estimates without requiring nonlinear optimization:","code":"# Define echelon form template for ARMA tmpl = tmpl_arma_echelon(nu, sigma_L = 'chol')  # HRK estimation out = est_arma_hrk(y_train, tmpl = tmpl, mean_estimate = 'zero') #> HRK estimation of ARMA model: m=2, n.obs=87, p=1, q=1 #> initial AR estimate of noise p.max=9, p=8, ll=-1.085391 #> iter |th - th0|  n.val      MSE       ll  #>    1      0.967     78    0.846   -1.282  models$HRK = out$model estimates$HRK = list(model = out$model, n.par = tmpl$n.par - dim_out*(dim_out+1)/2)  cat(\"ARMA HRK Estimate:\\n\") #> ARMA HRK Estimate: print(out$model) #> ARMA model [2,2] with orders p = 1 and q = 1 #> AR polynomial a(z): #>      z^0 [,1]  [,2]   z^1 [,1]       [,2] #> [1,]        1     0 -0.6039963 -0.1627991 #> [2,]        0     1  0.3696634 -0.9673143 #> MA polynomial b(z): #>      z^0 [,1]  [,2]   z^1 [,1]       [,2] #> [1,]        1     0 -0.2239565 -0.1928248 #> [2,]        0     1  0.1675349  0.2200974 #> Left square root of noise covariance Sigma: #>            u[1]      u[2] #> u[1]  0.8698782 0.0000000 #> u[2] -0.1746577 0.2425972"},{"path":"https://bfunovits.github.io/RLDM/articles/1_case_study.html","id":"ml-refinement-of-arma","dir":"Articles","previous_headings":"ARMA Models > What are ARMA Models?","what":"ML Refinement of ARMA","title":"Case Study: Economic Data Analysis with RLDM","text":"optimize HRK estimate using maximum likelihood:","code":"tmpl = tmpl_arma_echelon(nu, sigma_L = 'identity') th0 = extract_theta(models$HRK, tmpl, on_error = 'stop', ignore_sigma_L = TRUE)  llfun = ll_FUN(tmpl, y_train, skip = 0, which = \"concentrated\") control = list(trace = 0, fnscale = -1, maxit = 200)  out = optim(th0, llfun, method = 'BFGS', control = control) th = out$par model = fill_template(th, tmpl)  models$ARMAECF = model estimates$ARMAECF = list(model = model, n.par = tmpl$n.par)  cat(\"ARMA ML (Echelon Form):\\n\") #> ARMA ML (Echelon Form): print(model) #> ARMA model [2,2] with orders p = 1 and q = 1 #> AR polynomial a(z): #>      z^0 [,1]  [,2]   z^1 [,1]       [,2] #> [1,]        1     0 -0.5316187 -0.2011493 #> [2,]        0     1  0.3600104 -0.9572044 #> MA polynomial b(z): #>      z^0 [,1]  [,2]   z^1 [,1]       [,2] #> [1,]        1     0 -0.2177798 -0.6013328 #> [2,]        0     1  0.1970517  0.3906198 #> Left square root of noise covariance Sigma: #>      u[1] u[2] #> u[1]    1    0 #> u[2]    0    1"},{"path":"https://bfunovits.github.io/RLDM/articles/1_case_study.html","id":"converting-between-representations","dir":"Articles","previous_headings":"ARMA Models > What are ARMA Models?","what":"Converting Between Representations","title":"Case Study: Economic Data Analysis with RLDM","text":"RLDM provides functions convert state space ARMA representations. Since ML-refined models equivalent, can convert :","code":"# Convert state space (SSECF) to ARMA representation # Note: lmfd() conversion from state space to ARMA requires minimal realization # and is not directly supported. This conversion is commented out to avoid build errors. # arma_from_ss <- armamod(lmfd(models$SSECF$sys), #                        sigma_L = models$SSECF$sigma_L) # cat(\"ARMA representation of SSECF model:\\n\") # print(arma_from_ss) cat(\"Note: Direct conversion from state space to ARMA representation requires\\n\") #> Note: Direct conversion from state space to ARMA representation requires cat(\"minimal realization and is not shown in this vignette.\\n\") #> minimal realization and is not shown in this vignette."},{"path":[]},{"path":"https://bfunovits.github.io/RLDM/articles/1_case_study.html","id":"equivalence-of-ml-estimates","dir":"Articles","previous_headings":"Model Comparison and Selection","what":"Equivalence of ML Estimates","title":"Case Study: Economic Data Analysis with RLDM","text":"dataset, three ML-refined state space ARMA models essentially equivalent (data generating process):","code":"# Compare impulse responses eq_ddlc_ssecf = all.equal(impresp(models$DDLC, lag.max = lag.max),                           impresp(models$SSECF, lag.max = lag.max)) eq_ssecf_arma = all.equal(impresp(models$SSECF, lag.max = lag.max),                           impresp(models$ARMAECF, lag.max = lag.max))  cat(\"DDLC ≈ SSECF:\", isTRUE(eq_ddlc_ssecf), \"\\n\") #> DDLC ≈ SSECF: FALSE cat(\"SSECF ≈ ARMAECF:\", isTRUE(eq_ssecf_arma), \"\\n\\n\") #> SSECF ≈ ARMAECF: FALSE  # Keep only the unique models for further analysis models    = models[c('AR1', 'CCA', 'HRK', 'SSECF')] estimates = estimates[c('AR1', 'CCA', 'HRK', 'SSECF')]  cat(\"Models selected for comparison:\\n\") #> Models selected for comparison: print(names(models)) #> [1] \"AR1\"   \"CCA\"   \"HRK\"   \"SSECF\""},{"path":"https://bfunovits.github.io/RLDM/articles/1_case_study.html","id":"systematic-model-comparison","dir":"Articles","previous_headings":"Model Comparison and Selection","what":"Systematic Model Comparison","title":"Case Study: Economic Data Analysis with RLDM","text":"Compare models using multiple criteria: Interpretation: - Log-Likelihood: Higher better (fit quality) - AIC/BIC: Lower better (penalizes complexity) - Portmanteau Test p-value: Higher better (residuals white noise) - RMSE: Lower better (prediction accuracy)","code":"# Residual diagnostics u = solve_inverse_de(models$AR1$sys, as.matrix(y_train))$u pm_result = pm_test(u, 8, dim_out^2)  cat(\"Portmanteau Test for AR1 Model:\\n\") #> Portmanteau Test for AR1 Model: print(pm_result) #>      lags        Q df          p #> [1,]    2 11.22127  4 0.02418664 #> [2,]    3 12.63544  8 0.12502364 #> [3,]    4 16.29370 12 0.17815125 #> [4,]    5 19.35190 16 0.25083795 #> [5,]    6 20.69316 20 0.41538642 #> [6,]    7 31.86943 24 0.13026383 #> [7,]    8 33.88714 28 0.20461367  # Comprehensive comparison stats = compare_estimates(estimates, y_train, n.lags = 8)  if (requireNamespace(\"kableExtra\", quietly = TRUE)) {   kable(stats) %>%     kableExtra::kable_styling(bootstrap_options = c(\"striped\", \"hover\")) %>%     kableExtra::column_spec(1, bold = TRUE) } else {   print(stats) }"},{"path":[]},{"path":"https://bfunovits.github.io/RLDM/articles/1_case_study.html","id":"autocorrelation-analysis","dir":"Articles","previous_headings":"Model Diagnostics","what":"Autocorrelation Analysis","title":"Case Study: Economic Data Analysis with RLDM","text":"models capture autocorrelation structure data?  look : - Model ACF track data ACF - Large deviations indicate missing dynamics - ARMAECF SSECF match data closely","code":"plot(autocov(y, lag.max = lag.max),      lapply(models, FUN = autocov, lag.max = lag.max),      legend = c('Data', names(models)),      col = c('black', default_colmap(length(models))))"},{"path":"https://bfunovits.github.io/RLDM/articles/1_case_study.html","id":"spectral-density","dir":"Articles","previous_headings":"Model Diagnostics","what":"Spectral Density","title":"Case Study: Economic Data Analysis with RLDM","text":"Frequency domain analysis - model fit different frequencies?  Interpretation: - Peaks show dominant frequencies data - Model spectral densities follow data pattern - Good fit across frequencies indicates good model","code":"plot(spectrald(models[[1]], n.f = 2^10),      lapply(models[-1], FUN = spectrald, n.f = 2^10),      legend = names(models))"},{"path":"https://bfunovits.github.io/RLDM/articles/1_case_study.html","id":"impulse-response-functions","dir":"Articles","previous_headings":"Model Diagnostics","what":"Impulse Response Functions","title":"Case Study: Economic Data Analysis with RLDM","text":"system respond shocks?  Economic interpretation: - Top-left: GDP shock effect GDP - Top-right: unemployment shock effect GDP - Bottom-left: GDP shock effect unemployment - Bottom-right: unemployment shock effect unemployment","code":"plot(impresp(models[[1]], lag.max = lag.max),      lapply(models[-1], FUN = impresp, lag.max = lag.max),      legend = names(models))"},{"path":[]},{"path":"https://bfunovits.github.io/RLDM/articles/1_case_study.html","id":"out-of-sample-predictions","dir":"Articles","previous_headings":"Prediction and Forecasting","what":"Out-of-Sample Predictions","title":"Case Study: Economic Data Analysis with RLDM","text":"Forecast test set using model fit training data:","code":"n.ahead = 8 n.obs = nrow(y) pred = predict(models$SSECF, y, h = c(1, 4), n.ahead = n.ahead)  # Clean up prediction names for plotting dimnames(pred$yhat)[[3]] = gsub('=', '==', dimnames(pred$yhat)[[3]])  # Plot predictions p.y0 = plot_prediction(pred, which = 'y0', style = 'bw',                        parse_names = TRUE, plot = FALSE) p.y0() # Plot prediction errors plot_prediction(pred, which = 'error', qu = c(2, 2, 2),                 parse_names = TRUE) # CUSUM plot for error accumulation plot_prediction(pred, which = 'cusum', style = 'gray',                 parse_names = TRUE)"},{"path":"https://bfunovits.github.io/RLDM/articles/1_case_study.html","id":"compare-prediction-performance","dir":"Articles","previous_headings":"Prediction and Forecasting","what":"Compare Prediction Performance","title":"Case Study: Economic Data Analysis with RLDM","text":"","code":"# Generate predictions from all models out = lapply(models, FUN = function(model) {   predict(model, y, h = c(1, 4))$yhat }) yhat = do.call(dbind, c(3, out)) dimnames(yhat)[[3]] = kronecker(names(models), c(1, 4), FUN = paste, sep = ':')  # Evaluate using multiple criteria stats = evaluate_prediction(y, yhat,                            h = rep(c(1, 4), length(models)),                            criteria = list('RMSE', 'MAE', 'MdAPE'),                            samples = list(                              in.sample = 1:nrow(y_train),                              out.of.sample = (nrow(y_train)+1):nrow(y)                            ))  # Format for display stats.df = array2data.frame(stats, cols = 4) stats.df$h = sub(\"^.*:\", \"\", as.character(stats.df$predictor)) stats.df$predictor = sub(\":.$\", \"\", as.character(stats.df$predictor)) stats.df = stats.df[c('sample', 'h', 'criterion', 'predictor',                       'rGDPgrowth_demeaned', 'unemp_detrended', 'total')] stats.df = stats.df[order(stats.df$sample, stats.df$h,                           stats.df$criterion, stats.df$predictor), ] rownames(stats.df) = NULL  if (requireNamespace(\"kableExtra\", quietly = TRUE)) {   kable(stats.df) %>%     kableExtra::kable_styling(bootstrap_options = c(\"striped\", \"hover\")) %>%     kableExtra::collapse_rows(columns = 1:3, valign = \"top\") } else {   print(stats.df) }"},{"path":[]},{"path":"https://bfunovits.github.io/RLDM/articles/1_case_study.html","id":"key-findings","dir":"Articles","previous_headings":"Conclusions","what":"Key Findings","title":"Case Study: Economic Data Analysis with RLDM","text":"Model Selection: SSECF ARMAECF models perform best, capturing complex dynamics GDP growth unemployment interactions Baseline Performance: simple AR1 model provides useful baseline misses important multivariate dependencies State Space vs ARMA: approaches competitive; choice depends interpretability needs computational constraints Forecast Accuracy: advanced models show improved --sample prediction compared baseline AR","code":""},{"path":"https://bfunovits.github.io/RLDM/articles/1_case_study.html","id":"practical-recommendations","dir":"Articles","previous_headings":"Conclusions","what":"Practical Recommendations","title":"Case Study: Economic Data Analysis with RLDM","text":"interpretability: Use state space models CCA initialization parsimony: Use ARMA/VARMA models echelon form quick analysis: Start AR, compare state space production: Validate model assumptions monitor forecast performance time","code":""},{"path":"https://bfunovits.github.io/RLDM/articles/1_case_study.html","id":"references","dir":"Articles","previous_headings":"Conclusions","what":"References","title":"Case Study: Economic Data Analysis with RLDM","text":"(Scherrer Deistler 2019)","code":""},{"path":[]},{"path":"https://bfunovits.github.io/RLDM/articles/2_technical_reference.html","id":"notation","dir":"Articles","previous_headings":"Preliminaries","what":"Notation","title":"Technical Reference: RLDM Classes and Methods","text":"following notation used throughout RLDM:","code":""},{"path":"https://bfunovits.github.io/RLDM/articles/2_technical_reference.html","id":"sign-convention","dir":"Articles","previous_headings":"Preliminaries","what":"Sign Convention","title":"Technical Reference: RLDM Classes and Methods","text":"RLDM uses non-standard sign convention AR coefficients maintain consistency matrix fraction descriptions. Standard form (often seen time series textbooks): yt=a1yt−1+a2yt−2+⋯+apyt−p+uty_t = a_1 y_{t-1} + a_2 y_{t-2} + \\cdots + a_p y_{t-p} + u_t RLDM form (matrix fraction description): yt+a1yt−1+a2yt−2+⋯+apyt−p=uty_t + a_1 y_{t-1} + a_2 y_{t-2} + \\cdots + a_p y_{t-p} = u_t Notice opposite signs AR coefficients. ensures consistency working rational matrix fractions : a0yt+a1yt−1+⋯+apyt−p=b0ut+b1ut−1+⋯+bqut−qa_0 y_t + a_1 y_{t-1} + \\cdots + a_p y_{t-p} = b_0 u_t + b_1 u_{t-1} + \\cdots + b_q u_{t-q} a0=Ima_0 = I_m (identity matrix).","code":""},{"path":[]},{"path":"https://bfunovits.github.io/RLDM/articles/2_technical_reference.html","id":"overview-model-representations","dir":"Articles","previous_headings":"Model Classes","what":"Overview: Model Representations","title":"Technical Reference: RLDM Classes and Methods","text":"RLDM supports three equivalent ways represent rational linear dynamic models:","code":""},{"path":"https://bfunovits.github.io/RLDM/articles/2_technical_reference.html","id":"left-matrix-fraction-description-lmfd-armamod","dir":"Articles","previous_headings":"Model Classes > Overview: Model Representations","what":"1. Left Matrix Fraction Description (LMFD): armamod","title":"Technical Reference: RLDM Classes and Methods","text":"ARMA/VARMA representation: (z)yt=b(z)uta(z) y_t = b(z) u_t (z)(z) b(z)b(z) polynomial matrices lag operator zz.","code":""},{"path":"https://bfunovits.github.io/RLDM/articles/2_technical_reference.html","id":"state-space-form-stspmod","dir":"Articles","previous_headings":"Model Classes > Overview: Model Representations","what":"2. State Space Form: stspmod","title":"Technical Reference: RLDM Classes and Methods","text":"canonical state space representation: st+1=Ast+Butyt=Cst+Dut\\begin{aligned} s_{t+1} &= s_t + B u_t \\\\ y_t &= C s_t + D u_t \\end{aligned} sts_t state vector dimension ss.","code":""},{"path":"https://bfunovits.github.io/RLDM/articles/2_technical_reference.html","id":"right-matrix-fraction-description-rmfd-rmfdmod","dir":"Articles","previous_headings":"Model Classes > Overview: Model Representations","what":"3. Right Matrix Fraction Description (RMFD): rmfdmod","title":"Technical Reference: RLDM Classes and Methods","text":"alternative ARMA representation (experimental): wt=c(z)utyt=d(z)wt\\begin{aligned} w_t &= c(z) u_{t} \\\\ y_t &= d(z) w_t \\end{aligned}","code":""},{"path":"https://bfunovits.github.io/RLDM/articles/2_technical_reference.html","id":"varmaarma-models-armamod-class","dir":"Articles","previous_headings":"Model Classes","what":"VARMA/ARMA Models: armamod Class","title":"Technical Reference: RLDM Classes and Methods","text":"armamod class represents VARMA (multivariate ARMA) processes left matrix fraction form.","code":""},{"path":"https://bfunovits.github.io/RLDM/articles/2_technical_reference.html","id":"structure","dir":"Articles","previous_headings":"Model Classes > VARMA/ARMA Models: armamod Class","what":"Structure","title":"Technical Reference: RLDM Classes and Methods","text":"armamod object S3 list following slots: Class attribute: c(\"armamod\", \"rldm\")","code":""},{"path":"https://bfunovits.github.io/RLDM/articles/2_technical_reference.html","id":"constructor","dir":"Articles","previous_headings":"Model Classes > VARMA/ARMA Models: armamod Class","what":"Constructor","title":"Technical Reference: RLDM Classes and Methods","text":"Example:","code":"armamod(sys, sigma_L, names = NULL, label = NULL) # Create a simple AR(1) model: y_t = 0.8*y_{t-1} + u_t # In RLDM convention: y_t - 0.8*y_{t-1} = u_t a_coef <- matrix(-0.8)  # negative sign for standard convention b_coef <- matrix(1) sys <- lmfd(a_coef, b_coef)  model <- armamod(sys, sigma_L = matrix(1), names = \"Output\", label = \"AR(1)\") model #> AR(1): ARMA model [1,1] with orders p = 0 and q = 0 #> AR polynomial a(z): #>      z^0 [,1] #> [1,]     -0.8 #> MA polynomial b(z): #>      z^0 [,1] #> [1,]        1 #> Left square root of noise covariance Sigma: #>      u[1] #> u[1]    1"},{"path":"https://bfunovits.github.io/RLDM/articles/2_technical_reference.html","id":"available-methods","dir":"Articles","previous_headings":"Model Classes > VARMA/ARMA Models: armamod Class","what":"Available Methods","title":"Technical Reference: RLDM Classes and Methods","text":"Key methods: - autocov() - Compute autocovariance function - impresp() - Impulse response functions - spectrald() - Spectral density - freqresp() - Frequency response - predict() - Forecasting - solve_de() - Simulate model - print() / plot() - Visualization","code":"methods(class = 'armamod') #>  [1] as.stspmod autocov    freqresp   impresp    ll         poles      #>  [7] predict    print      sim        spectrald  str        zeroes     #> see '?methods' for accessing help and source code"},{"path":"https://bfunovits.github.io/RLDM/articles/2_technical_reference.html","id":"state-space-models-stspmod-class","dir":"Articles","previous_headings":"Model Classes","what":"State Space Models: stspmod Class","title":"Technical Reference: RLDM Classes and Methods","text":"stspmod class represents processes canonical state space form. State space models offer several advantages representations: Minimality: state dimension ss represents essential “memory” system, providing compact representation. Balancing: Realizations can balanced improve numerical stability (balance parameter template functions). Latent state interpretation: Hidden states can represent meaningful unobserved components (trends, cycles, factors). Flexibility: Can model complex dynamics relatively parameters appropriate state dimension selection.","code":""},{"path":"https://bfunovits.github.io/RLDM/articles/2_technical_reference.html","id":"structure-1","dir":"Articles","previous_headings":"Model Classes > State Space Models: stspmod Class","what":"Structure","title":"Technical Reference: RLDM Classes and Methods","text":"stspmod object S3 list slots: Class attribute: c(\"stspmod\", \"rldm\")","code":""},{"path":"https://bfunovits.github.io/RLDM/articles/2_technical_reference.html","id":"constructor-1","dir":"Articles","previous_headings":"Model Classes > State Space Models: stspmod Class","what":"Constructor","title":"Technical Reference: RLDM Classes and Methods","text":"Example:","code":"stspmod(sys, sigma_L, names = NULL, label = NULL) # Create a simple state space model # s_{t+1} = 0.8*s_t + u_t # y_t = s_t  A_matrix <- matrix(0.8) B_matrix <- matrix(1) C_matrix <- matrix(1) D_matrix <- matrix(0)  sys <- stsp(A_matrix, B_matrix, C_matrix, D_matrix) model_ss <- stspmod(sys, sigma_L = matrix(1)) model_ss #> state space model [1,1] with s = 1 states #>      s[1] u[1] #> s[1]  0.8    1 #> x[1]  1.0    0 #> Left square root of noise covariance Sigma: #>      u[1] #> u[1]    1"},{"path":"https://bfunovits.github.io/RLDM/articles/2_technical_reference.html","id":"available-methods-1","dir":"Articles","previous_headings":"Model Classes > State Space Models: stspmod Class","what":"Available Methods","title":"Technical Reference: RLDM Classes and Methods","text":"Similar armamod, state space models support: - Autocovariance, impulse responses, spectral density computation - Forecasting simulation - Conversion impulse response representation","code":"methods(class = 'stspmod') #>  [1] autocov    freqresp   impresp    ll_pfilter ll         pfilter    #>  [7] poles      predict    print      sim        spectrald  str        #> [13] zeroes     #> see '?methods' for accessing help and source code"},{"path":"https://bfunovits.github.io/RLDM/articles/2_technical_reference.html","id":"state-space-parameterizations","dir":"Articles","previous_headings":"Model Classes > State Space Models: stspmod Class","what":"State Space Parameterizations","title":"Technical Reference: RLDM Classes and Methods","text":"RLDM supports several standard state space canonical forms template functions: tmpl_DDLC() - Diagonal-Direct-Lead-Coefficient form tmpl_stsp_echelon() - Echelon canonical form tmpl_stsp_innovation() - Innovation form","code":""},{"path":"https://bfunovits.github.io/RLDM/articles/2_technical_reference.html","id":"right-matrix-fraction-description-rmfdmod-class","dir":"Articles","previous_headings":"Model Classes","what":"Right Matrix Fraction Description: rmfdmod Class","title":"Technical Reference: RLDM Classes and Methods","text":"rmfdmod class represents processes right matrix fraction form (experimental, limited methods): estimation analysis methods yet implemented class.","code":"rmfdmod(sys, sigma_L, names = NULL, label = NULL)"},{"path":"https://bfunovits.github.io/RLDM/articles/2_technical_reference.html","id":"derived-objects","dir":"Articles","previous_headings":"","what":"Derived Objects","title":"Technical Reference: RLDM Classes and Methods","text":"classes represent computed properties process models, model specifications .","code":""},{"path":"https://bfunovits.github.io/RLDM/articles/2_technical_reference.html","id":"autocovariance-autocov-class","dir":"Articles","previous_headings":"Derived Objects","what":"Autocovariance: autocov Class","title":"Technical Reference: RLDM Classes and Methods","text":"Stores autocovariances, autocorrelations, partial autocorrelations.","code":""},{"path":[]},{"path":"https://bfunovits.github.io/RLDM/articles/2_technical_reference.html","id":"computation","dir":"Articles","previous_headings":"Derived Objects > Autocovariance: autocov Class","what":"Computation","title":"Technical Reference: RLDM Classes and Methods","text":"Example:","code":"# From data autocov.default(obj, lag.max = 20, type = \"correlation\")  # From model autocov.armamod(obj, lag.max = 20, type = \"correlation\") autocov.stspmod(obj, lag.max = 20, type = \"correlation\") # Generate AR model and compute ACF y <- sim(model, n.obs = 500) acov <- autocov(model, lag.max = 15, type = \"correlation\") plot(acov)"},{"path":"https://bfunovits.github.io/RLDM/articles/2_technical_reference.html","id":"impulse-response-impresp-class","dir":"Articles","previous_headings":"Derived Objects","what":"Impulse Response: impresp Class","title":"Technical Reference: RLDM Classes and Methods","text":"Stores impulse response coefficients: kjk_j yt=∑j≥0kjut−jy_t = \\sum_{j \\geq 0} k_j u_{t-j}.","code":""},{"path":[]},{"path":"https://bfunovits.github.io/RLDM/articles/2_technical_reference.html","id":"computation-1","dir":"Articles","previous_headings":"Derived Objects > Impulse Response: impresp Class","what":"Computation","title":"Technical Reference: RLDM Classes and Methods","text":"Example:  H parameter allows custom orthogonalization (default: Cholesky).","code":"impresp.armamod(obj, lag.max = 40, H = NULL) impresp.stspmod(obj, lag.max = 40, H = NULL) irf <- impresp(model, lag.max = 20) plot(irf, main = \"Impulse Response\")"},{"path":"https://bfunovits.github.io/RLDM/articles/2_technical_reference.html","id":"spectral-density-spectrald-class","dir":"Articles","previous_headings":"Derived Objects","what":"Spectral Density: spectrald Class","title":"Technical Reference: RLDM Classes and Methods","text":"Frequency-domain representation: Γ(λ)=K(λ)ΣK*(λ)\\Gamma(\\lambda) = K(\\lambda) \\Sigma K^*(\\lambda) K(λ)K(\\lambda) frequency response.","code":""},{"path":[]},{"path":"https://bfunovits.github.io/RLDM/articles/2_technical_reference.html","id":"computation-2","dir":"Articles","previous_headings":"Derived Objects > Spectral Density: spectrald Class","what":"Computation","title":"Technical Reference: RLDM Classes and Methods","text":"Example:","code":"spectrald(obj, n.f = 128, ...) spec <- spectrald(model, n.f = 256) plot(spec)"},{"path":"https://bfunovits.github.io/RLDM/articles/2_technical_reference.html","id":"frequency-response-freqresp-class","dir":"Articles","previous_headings":"Derived Objects","what":"Frequency Response: freqresp Class","title":"Technical Reference: RLDM Classes and Methods","text":"frequency transfer function K(λ)=∑jkje−iλjK(\\lambda) = \\sum_j k_j e^{-\\lambda j}.","code":"freqresp.armamod(obj, n.f = 256)"},{"path":"https://bfunovits.github.io/RLDM/articles/2_technical_reference.html","id":"forecast-error-variance-decomposition-fevardec-class","dir":"Articles","previous_headings":"Derived Objects","what":"Forecast Error Variance Decomposition: fevardec Class","title":"Technical Reference: RLDM Classes and Methods","text":"Decomposes forecast error variance contributions shock.","code":"fevardec(obj, h.max = 40)"},{"path":[]},{"path":[]},{"path":"https://bfunovits.github.io/RLDM/articles/2_technical_reference.html","id":"yule-walker-method-est_ar_yw","dir":"Articles","previous_headings":"Estimation Methods > AR Model Estimation","what":"Yule-Walker Method: est_ar_yw()","title":"Technical Reference: RLDM Classes and Methods","text":"Theory: Solves Yule-Walker equations using Cholesky decomposition: γk=a1γk−1+⋯+apγk−p\\gamma_k = a_1 \\gamma_{k-1} + \\cdots + a_p \\gamma_{k-p} Advantages: - Statistically efficient (minimum variance) - Produces AR orders simultaneously - Automatic log-determinant sequence model selection Example:","code":"est_ar_yw(gamma, p.max = 10, penalty = -1)"},{"path":"https://bfunovits.github.io/RLDM/articles/2_technical_reference.html","id":"durbin-levinson-whittle-method-est_ar_dlw","dir":"Articles","previous_headings":"Estimation Methods > AR Model Estimation","what":"Durbin-Levinson-Whittle Method: est_ar_dlw()","title":"Technical Reference: RLDM Classes and Methods","text":"Theory: Recursive algorithm AR parameter partial autocorrelation computation. Advantages: - Numerically stable - Computes partial ACF - Efficient recursions Example:","code":"est_ar_dlw(gamma, p.max = 10, penalty = -1)"},{"path":"https://bfunovits.github.io/RLDM/articles/2_technical_reference.html","id":"wrapper-function-est_ar","dir":"Articles","previous_headings":"Estimation Methods > AR Model Estimation","what":"Wrapper Function: est_ar()","title":"Technical Reference: RLDM Classes and Methods","text":"Primary interface AR estimation automatic order selection: Parameters: - ic: Information criterion (“AIC”, “BIC”, “HQ”) - mean_estimate: estimate mean (“sample.mean”, “zero”, vector) - method: “yw” (Yule-Walker), “dlw” (Durbin-Levinson-Whittle), “auto” Returns: List components: - model: Estimated armamod object - p: Selected order - stats: Criterion values order - ll: Log-likelihood values","code":"est_ar(data, p.max = NULL, method = \"auto\",        ic = \"AIC\", mean_estimate = \"sample.mean\")"},{"path":[]},{"path":"https://bfunovits.github.io/RLDM/articles/2_technical_reference.html","id":"hannan-rissanen-kavalieris-hrk-est_arma_hrk","dir":"Articles","previous_headings":"Estimation Methods > ARMA Model Estimation","what":"Hannan-Rissanen-Kavalieris (HRK): est_arma_hrk()","title":"Technical Reference: RLDM Classes and Methods","text":"Three-stage procedure VARMA estimation without nonlinear optimization: Stage 1: Estimate long AR model Stage 2: Compute initial ARMA estimates Stage 3: Refine using feasible GLS Advantages: - Provides consistent initial estimates - nonlinear optimization required - Suitable maximum likelihood refinement use: - Initial estimates multivariate ARMA - Moderate high-dimensional systems - want avoid local optima","code":"est_arma_hrk(data, tmpl = NULL, p = NULL, q = NULL,              mean_estimate = \"zero\")"},{"path":[]},{"path":"https://bfunovits.github.io/RLDM/articles/2_technical_reference.html","id":"cca-method-est_stsp_ssmethod-cca","dir":"Articles","previous_headings":"Estimation Methods > State Space Estimation","what":"CCA Method: est_stsp_ss(method = \"cca\")","title":"Technical Reference: RLDM Classes and Methods","text":"Canonical Correlation Analysis determining state space order initial estimates. Advantages: - Data-driven order selection - Suitable prior knowledge system structure - Good numerical properties State Dimension Selection: s = NULL (default), CCA automatically selects state dimension using singular value criteria. manual selection, consider: - Singular Value Criterion (SVC): Look gap singular values weighted Hankel matrix - Information Criteria: AIC/BIC computed different state dimensions - Cross-validation: --sample prediction performance - Interpretability: Choose dimension matches expected number latent factors practice, start automatic selection via est_stsp_ss() s = NULL, inspect singular values plot (available) compare information criteria across dimensions.","code":"est_stsp_ss(data, method = \"cca\", s = NULL,             keep_models = FALSE, ...)"},{"path":"https://bfunovits.github.io/RLDM/articles/2_technical_reference.html","id":"subspace-methods-est_stsp_ssmethod-ccahomoesp","dir":"Articles","previous_headings":"Estimation Methods > State Space Estimation","what":"Subspace Methods: est_stsp_ss(method = \"cca\"/\"ho\"/\"moesp\")","title":"Technical Reference: RLDM Classes and Methods","text":"Multiple subspace identification methods available matrix fraction estimation.","code":""},{"path":[]},{"path":"https://bfunovits.github.io/RLDM/articles/2_technical_reference.html","id":"general-ml-framework-ll_fun","dir":"Articles","previous_headings":"Estimation Methods > Maximum Likelihood Estimation","what":"General ML Framework: ll_FUN()","title":"Technical Reference: RLDM Classes and Methods","text":"Create likelihood functions structured parameter templates: optimize using standard R optimizers:","code":"llfun <- ll_FUN(tmpl, data, skip = 0, which = \"concentrated\") out <- optim(theta0, llfun, method = \"BFGS\", control = list(fnscale = -1))"},{"path":"https://bfunovits.github.io/RLDM/articles/2_technical_reference.html","id":"parameter-templates","dir":"Articles","previous_headings":"Estimation Methods > Maximum Likelihood Estimation","what":"Parameter Templates","title":"Technical Reference: RLDM Classes and Methods","text":"Templates map deep model parameters linear parameters optimization: tmpl_DDLC() - Diagonal-Direct-Lead-Coefficient tmpl_arma_echelon() - ARMA echelon form tmpl_stsp_echelon() - State space echelon form Workflow:","code":"# Create template from initial estimate tmpl <- tmpl_DDLC(model_initial, sigma_L = 'identity')  # Extract starting parameter vector theta0 <- extract_theta(model_initial, tmpl)  # Create and optimize likelihood llfun <- ll_FUN(tmpl, data, which = \"concentrated\") opt <- optim(theta0, llfun, method = \"BFGS\", control = list(fnscale = -1, maxit = 500))  # Reconstruct model from optimized parameters model_ml <- fill_template(opt$par, tmpl)"},{"path":[]},{"path":"https://bfunovits.github.io/RLDM/articles/2_technical_reference.html","id":"overview","dir":"Articles","previous_headings":"Estimation Methods > Particle Filtering","what":"Overview","title":"Technical Reference: RLDM Classes and Methods","text":"Particle filters (Sequential Monte Carlo methods) extend Kalman filtering nonlinear /non-Gaussian state space models. Kalman filter provides optimal closed-form solutions linear Gaussian models, particle filters use Monte Carlo approximation handle: Nonlinear state transitions: xt=f(xt−1,ut)x_t = f(x_{t-1}, u_t) Non-Gaussian observations: yt∼p(y|xt)y_t \\sim p(y | x_t) arbitrary distribution Complex noise structures RLDM implementation includes three particle filter variants: SIR (Bootstrap) filter: Basic sampling importance resampling APF (Auxiliary Particle Filter): Two-stage resampling lookahead Optimal proposal: linear Gaussian models, approaches Kalman filter performance","code":""},{"path":"https://bfunovits.github.io/RLDM/articles/2_technical_reference.html","id":"basic-usage-linear-gaussian-comparison","dir":"Articles","previous_headings":"Estimation Methods > Particle Filtering","what":"Basic Usage: Linear Gaussian Comparison","title":"Technical Reference: RLDM Classes and Methods","text":"linear Gaussian models, particle filters approximate Kalman filter solution:","code":"library(RLDM)  # Create a linear Gaussian state space model m <- 1; s <- 2; n <- s tmpl <- tmpl_stsp_full(m, n, s, sigma_L = \"chol\") model <- r_model(tmpl, bpoles = 1, sd = 0.5) data <- sim(model, n.obs = 100) y <- data$y  # Kalman filter (optimal for linear Gaussian) kf_result <- kf(model, y)  # Particle filters pf_sir <- pfilter(model, y, N_particles = 1000, method = \"sir\") pf_apf <- pfilter(model, y, N_particles = 1000, method = \"apf\") pf_opt <- pfilter(model, y, N_particles = 1000, method = \"optimal\")  # Compare filtered states plot(kf_result$a[,1], type = \"l\", col = \"black\", lwd = 2,      main = \"Filtered State Estimates\") lines(pf_sir$filtered_states[,1], col = \"blue\", lty = 2) lines(pf_apf$filtered_states[,1], col = \"red\", lty = 2) lines(pf_opt$filtered_states[,1], col = \"green\", lty = 2) legend(\"topright\", legend = c(\"Kalman\", \"SIR\", \"APF\", \"Optimal\"),        col = c(\"black\", \"blue\", \"red\", \"green\"), lty = c(1, 2, 2, 2), lwd = c(2, 1, 1, 1))"},{"path":"https://bfunovits.github.io/RLDM/articles/2_technical_reference.html","id":"likelihood-approximation","dir":"Articles","previous_headings":"Estimation Methods > Particle Filtering","what":"Likelihood Approximation","title":"Technical Reference: RLDM Classes and Methods","text":"Particle filters can approximate log-likelihood nonlinear/non-Gaussian models exact Kalman filter likelihood unavailable:","code":"# Kalman filter likelihood (exact for linear Gaussian) ll_kf <- ll_kf(model, y)  # Particle filter likelihood approximation (averaged over multiple runs) ll_pf <- ll_pfilter(model, y, N_particles = 1000, filter_type = \"apf\", N_runs = 10)  cat(\"Kalman filter LL:\", ll_kf, \"\\n\") cat(\"Particle filter LL:\", ll_pf, \"\\n\") cat(\"Difference:\", ll_pf - ll_kf, \"\\n\")"},{"path":"https://bfunovits.github.io/RLDM/articles/2_technical_reference.html","id":"nonlinear-and-non-gaussian-examples","dir":"Articles","previous_headings":"Estimation Methods > Particle Filtering","what":"Nonlinear and Non-Gaussian Examples","title":"Technical Reference: RLDM Classes and Methods","text":"RLDM includes example scripts demonstrating particle filter superiority nonlinear/non-Gaussian models: inst/examples/nonlinear_sin.R - Nonlinear state transition: xt=sin(xt−1)+ηtx_t = \\sin(x_{t-1}) + \\eta_t inst/examples/nonlinear_poisson.R - Non-Gaussian observation: yt∼Poisson(λ=exp(Cxt))y_t \\sim \\text{Poisson}(\\lambda = \\exp(C x_t)) inst/examples/stochastic_volatility.R - Stochastic volatility model: yt=exp(xt/2)εty_t = \\exp(x_t/2) \\varepsilon_t example compares particle filter performance approximate Kalman filter variants (Extended Kalman Filter, Gaussian approximation, log-squared transformation).","code":""},{"path":"https://bfunovits.github.io/RLDM/articles/2_technical_reference.html","id":"diagnostics-and-visualization","dir":"Articles","previous_headings":"Estimation Methods > Particle Filtering","what":"Diagnostics and Visualization","title":"Technical Reference: RLDM Classes and Methods","text":"plot.pfilter() method provides several diagnostic plots:","code":"pf <- pfilter(model, y, N_particles = 500, method = \"sir\")  # Filtered state estimates plot(pf, type = \"states\")  # Effective Sample Size (ESS) over time plot(pf, type = \"ess\")  # Particle weight distribution at final time plot(pf, type = \"weights\")  # Log-likelihood contributions per time step plot(pf, type = \"likelihood\")"},{"path":"https://bfunovits.github.io/RLDM/articles/2_technical_reference.html","id":"performance-considerations","dir":"Articles","previous_headings":"Estimation Methods > Particle Filtering","what":"Performance Considerations","title":"Technical Reference: RLDM Classes and Methods","text":"Particle count: particles improve accuracy increase computation (typical: 1000-10000) Resampling methods: Systematic (default), multinomial, stratified ESS threshold: Adaptive resampling ESS < threshold × N_particles (default: 0.5) Optimal proposal: Use linear Gaussian models minimize weight degeneracy","code":""},{"path":"https://bfunovits.github.io/RLDM/articles/2_technical_reference.html","id":"references","dir":"Articles","previous_headings":"Estimation Methods > Particle Filtering","what":"References","title":"Technical Reference: RLDM Classes and Methods","text":"Gordon, N. J., Salmond, D. J., & Smith, . F. M. (1993). Novel approach nonlinear/non-Gaussian Bayesian state estimation Pitt, M. K., & Shephard, N. (1999). Filtering via simulation: Auxiliary particle filters Doucet, ., Godsill, S., & Andrieu, C. (2000). sequential Monte Carlo sampling methods Bayesian filtering","code":""},{"path":[]},{"path":[]},{"path":"https://bfunovits.github.io/RLDM/articles/2_technical_reference.html","id":"forward-solution-solve_de","dir":"Articles","previous_headings":"Solution and Simulation > Solving Difference Equations","what":"Forward Solution: solve_de()","title":"Technical Reference: RLDM Classes and Methods","text":"Simulate forward initial conditions: yt=k0ut+k1ut−1+k2ut−2+⋯y_t = k_0 u_t + k_1 u_{t-1} + k_2 u_{t-2} + \\cdots","code":"y <- solve_de(sys, u, y_init = NULL)"},{"path":"https://bfunovits.github.io/RLDM/articles/2_technical_reference.html","id":"inverse-solution-solve_inverse_de","dir":"Articles","previous_headings":"Solution and Simulation > Solving Difference Equations","what":"Inverse Solution: solve_inverse_de()","title":"Technical Reference: RLDM Classes and Methods","text":"Extract residuals given data (solve backwards): ut=(z)−1b(z)−1ytu_t = (z)^{-1} b(z)^{-1} y_t","code":"u <- solve_inverse_de(sys, y)$u"},{"path":[]},{"path":"https://bfunovits.github.io/RLDM/articles/2_technical_reference.html","id":"stationary-arma-processes","dir":"Articles","previous_headings":"Mathematical Foundations","what":"Stationary ARMA Processes","title":"Technical Reference: RLDM Classes and Methods","text":"ARMA process described : (z)yt=b(z)uta(z) y_t = b(z) u_t : - (z)=Im+a1z+⋯+apzpa(z) = I_m + a_1 z + \\cdots + a_p z^p (AR polynomial) - b(z)=b0+b1z+⋯+bqzqb(z) = b_0 + b_1 z + \\cdots + b_q z^q (MA polynomial) - (ut)(u_t) white noise 𝔼(utut′)=Σ\\mathbb{E}(u_t u_t') = \\Sigma process stationary roots det((z))=0\\det((z)) = 0 lie outside unit circle. stationary solution : yt=∑j≥0kjut−jy_t = \\sum_{j \\geq 0} k_j u_{t-j} kjk_j satisfy: (z)k(z)=b(z)(z) k(z) = b(z).","code":""},{"path":"https://bfunovits.github.io/RLDM/articles/2_technical_reference.html","id":"autocovariance-function","dir":"Articles","previous_headings":"Mathematical Foundations","what":"Autocovariance Function","title":"Technical Reference: RLDM Classes and Methods","text":"stationary ARMA processes, autocovariance function γk=𝔼(yt+kyt′)\\gamma_k = \\mathbb{E}(y_{t+k} y_t') satisfies generalized Yule-Walker equations: a0γk+a1γk−1+⋯+apγk−p={b0Σk0′+⋯+bqΣkq−k′0≤k≤q0k>qa_0 \\gamma_k + a_1 \\gamma_{k-1} + \\cdots + a_p \\gamma_{k-p} = \\begin{cases} b_0 \\Sigma k_0' + \\cdots + b_q \\Sigma k_{q-k}' & 0 \\leq k \\leq q \\\\ 0 & k > q \\end{cases}","code":""},{"path":"https://bfunovits.github.io/RLDM/articles/2_technical_reference.html","id":"spectral-factorization","dir":"Articles","previous_headings":"Mathematical Foundations","what":"Spectral Factorization","title":"Technical Reference: RLDM Classes and Methods","text":"spectral density can written : Γ(λ)=12πK(λ)ΣK*(λ)\\Gamma(\\lambda) = \\frac{1}{2\\pi} K(\\lambda) \\Sigma K^*(\\lambda) K(λ)K(\\lambda) frequency response K*K^* denotes conjugate transpose. enables: - Frequency domain analysis - Filter design - Whitening transformations","code":""},{"path":"https://bfunovits.github.io/RLDM/articles/2_technical_reference.html","id":"kronecker-indices","dir":"Articles","previous_headings":"Mathematical Foundations","what":"Kronecker Indices","title":"Technical Reference: RLDM Classes and Methods","text":"VARMA models canonical form, Kronecker indices (n1,…,nm)(n_1, \\ldots, n_m) define minimal orders required output: - Total state dimension: s=n1+⋯+nms = n_1 + \\cdots + n_m - specify echelon structure","code":""},{"path":[]},{"path":[]},{"path":"https://bfunovits.github.io/RLDM/articles/2_technical_reference.html","id":"choosing-state-space-parameterizations","dir":"Articles","previous_headings":"Method Selection Guide","what":"Choosing State Space Parameterizations","title":"Technical Reference: RLDM Classes and Methods","text":"RLDM supports several state space parameterizations, different strengths: Guidelines: 1. Start CCA initial model discovery automatic order selection 2. Refine DDLC maximum likelihood estimation good numerical properties 3. Use echelon form need canonical, identifiable representations structural restrictions 4. Convert forms using pseries2stsp() template functions needed","code":""},{"path":"https://bfunovits.github.io/RLDM/articles/2_technical_reference.html","id":"model-comparison-workflow","dir":"Articles","previous_headings":"Method Selection Guide","what":"Model Comparison Workflow","title":"Technical Reference: RLDM Classes and Methods","text":"Start AR using est_ar() Try state space est_stsp_ss() dimensionality reduction Compare ARMA using HRK initial estimates + ML refinement Refine best model parameter templates optimization Validate using residual diagnostics, ACF, spectral plots","code":""},{"path":[]},{"path":"https://bfunovits.github.io/RLDM/articles/2_technical_reference.html","id":"references-1","dir":"Articles","previous_headings":"","what":"References","title":"Technical Reference: RLDM Classes and Methods","text":"(Scherrer Deistler 2019)","code":""},{"path":"https://bfunovits.github.io/RLDM/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Wolfgang Scherrer. Author. Bernd Funovits. Author, maintainer.","code":""},{"path":"https://bfunovits.github.io/RLDM/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Scherrer W, Funovits B (2026). RLDM: Rational Linear Dynamic (Time Series) Models. R package version 0.0.0.9006, https://bfunovits.github.io/RLDM.","code":"@Manual{,   title = {RLDM: Rational Linear Dynamic (Time Series) Models},   author = {Wolfgang Scherrer and Bernd Funovits},   year = {2026},   note = {R package version 0.0.0.9006},   url = {https://bfunovits.github.io/RLDM}, }"},{"path":"https://bfunovits.github.io/RLDM/index.html","id":"rational-linear-dynamic-models-rldm","dir":"","previous_headings":"","what":"Rational Linear Dynamic (Time Series) Models","title":"Rational Linear Dynamic (Time Series) Models","text":"RLDM (Rational Linear Dynamic Models) R package provides models stationary processes rational spectral density methods estimation. refer rational models. builds heavily sister R package rationalmatrices, see https://bfunovits.github.io/rationalmatrices/.","code":""},{"path":"https://bfunovits.github.io/RLDM/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Rational Linear Dynamic (Time Series) Models","text":"can install latest version code using remotes R package.","code":"remotes::install_github(\"bfunovits/RLDM\")"},{"path":"https://bfunovits.github.io/RLDM/index.html","id":"content","dir":"","previous_headings":"","what":"Content","title":"Rational Linear Dynamic (Time Series) Models","text":"package provides following sets functions whose documentation can found reference page https://bfunovits.github.io/RLDM/reference website https://bfunovits.github.io/RLDM/ (created https://pkgdown.r-lib.org/): VARMA models armamod() State space models stspmod() Right matrix fraction description (RMFD) models rmfdmod() (experimental) matrix HH number rows number linear parameters given model number columns number deep parameters given model column vector hh appropriate dimension See help(\"model structures\") help(\"local model structures\") details. Generic functions create objects derived rational models autocovariance sequence, see autocov() Spectral density, see spectrald() Forecast error variance decomposition, see fevardec(), given IRF Frequency response (transfer function evaluated unit circle), see freqresp() Several generic functions extend R’s generic functions plot(), print(), str(), predict() helpers estimation methods: solve_de(), solve_inverse_de(), Moment estimation methods AR models, see e.g. est_ar() ARMA models, see Hannan-Rissannen-Kavalieris algorithm est_arma_hrk3() state space models, see e.g. est_stsp_cca() Likelihood estimation methods ll() ll_theta() ll_FUN() estimation deep parameters rational model ll_kf() tooling like simulation sim() model comparison KL_divergence(), pm_test(), compare_estimates()","code":""},{"path":"https://bfunovits.github.io/RLDM/index.html","id":"getting-started","dir":"","previous_headings":"","what":"Getting Started","title":"Rational Linear Dynamic (Time Series) Models","text":"RLDM includes comprehensive documentation organized user level: Practical introduction simple examples AR models multivariate VAR/VARMA systems ~10-15 minute read executable code Blanchard-Quah economic data analysis Comparing AR, state space, ARMA models Model selection, diagnostics, forecasting Complete class method documentation Mathematical foundations Method selection guidance","code":""},{"path":"https://bfunovits.github.io/RLDM/index.html","id":"installation-notes","dir":"","previous_headings":"","what":"Installation Notes","title":"Rational Linear Dynamic (Time Series) Models","text":"package depends rationalmatrices. Install : Vignette Building: build vignettes locally, need pandoc-citeproc installed system: - Ubuntu/Debian: sudo apt-get install pandoc-citeproc - macOS: brew install pandoc-citeproc - Windows: Included pandoc installer Pre-built vignettes available package website. load explore:","code":"remotes::install_github(\"bfunovits/rationalmatrices\") remotes::install_github(\"bfunovits/RLDM\") library(RLDM) browseVignettes(\"RLDM\")  # View all vignettes (if built locally) vignette(\"0_getting_started\")  # Access specific vignette"},{"path":"https://bfunovits.github.io/RLDM/reference/BQdata.html","id":null,"dir":"Reference","previous_headings":"","what":"Blanchard/Quah (1989) dataset — BQdata","title":"Blanchard/Quah (1989) dataset — BQdata","text":"dataset contains (159 x 2)-dimensional matrix quarterly data real GDP growth rates (first column) unemployment rate USA. starts second quarter 1948 ends last quarter 1987. script transforming raw data (csv-file) matrix BQdata available data-raw directory. dataset used Gourieroux, Monfort, Renne (2019)","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/BQdata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Blanchard/Quah (1989) dataset — BQdata","text":"","code":"BQdata  BQdata_ts  BQdata_xts"},{"path":"https://bfunovits.github.io/RLDM/reference/BQdata.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Blanchard/Quah (1989) dataset — BQdata","text":"tibble (BQdata), ts-object (BQdata_ts), xts-object (BQdata_xts) 159 rows 2 variables (plus timestamp, total 3): date Timestamp column type dttm tibble, index ts xts object. rGDPgrowth_demeaned real GDP growth series demeaned respect two different subperiods: Till last quarter 1973 first quarter 1974 unemp_detrended unemployment rate detrended respect linear trend (intercept). object class mts (inherits ts, matrix) 159 rows 2 columns. object class xts (inherits zoo) 159 rows 2 columns.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/BQdata.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Blanchard/Quah (1989) dataset — BQdata","text":"https://academic.oup.com/restud/advance-article/doi/10.1093/restud/rdz028/5490841#supplementary-data","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/KL_divergence.html","id":null,"dir":"Reference","previous_headings":"","what":"Kullback–Leibler divergence — KL_divergence","title":"Kullback–Leibler divergence — KL_divergence","text":"Compute Kullback-Leibler divergence \"true\" state space model estimated state space model. function works square systems, \"true\" model stable estimate (strictly) miniphase.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/KL_divergence.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Kullback–Leibler divergence — KL_divergence","text":"","code":"KL_divergence(model, model_hat)"},{"path":"https://bfunovits.github.io/RLDM/reference/KL_divergence.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Kullback–Leibler divergence — KL_divergence","text":"model stspmod() object, true model model_hat stspmod() object, estimated model","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/KL_divergence.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Kullback–Leibler divergence — KL_divergence","text":"KL divergence.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/KL_divergence.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Kullback–Leibler divergence — KL_divergence","text":"KL divergence computed follows. Suppose \\(y_t = k(z) u_t\\), \\(\\mathbf{E} u_t u_t' = \\Sigma\\) true model, let \\(y_t = h(z) u_t\\), \\(\\mathbf{E} u_t u_t'=\\Omega\\) denote estimate. W.l.o.g. assume models innovation form, .e. \\(k(0) = h(0) = \\). procedure computes covariance matrix, \\(\\Delta = \\mathbf{E} e_t e_t'\\) say, one-step-ahead prediction errors \\(e_t = h^{-1}(z) k(z) u_t\\) KL divergence $$ \\mathrm{KL} = (1/2)(\\mathrm{tr}(\\Omega^{-1}\\Delta) - m - \\ln\\det(\\Omega^{-1}\\Delta))) $$ Note procedure breaks transfer function \\(h^{-1}(z) k(z)\\) stable. Therefore true models stable estimated model strictly miniphase.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/KL_divergence.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Kullback–Leibler divergence — KL_divergence","text":"","code":"# Create a true model and an estimated model true_model = stspmod(sys = stsp(A = matrix(c(0.5, 0, 0, 0.3), 2, 2),                                 B = matrix(c(1, 0), 2, 1),                                 C = matrix(c(1, 1), 1, 2),                                 D = matrix(1, 1, 1)),                      sigma_L = matrix(1, 1, 1)) # Create a slightly different estimated model est_model = stspmod(sys = stsp(A = matrix(c(0.45, 0, 0, 0.35), 2, 2),                                B = matrix(c(1.1, 0), 2, 1),                                C = matrix(c(0.9, 1.1), 1, 2),                                D = matrix(1, 1, 1)),                     sigma_L = matrix(1.1, 1, 1)) # Compute KL divergence kl = KL_divergence(true_model, est_model) kl #> [1] 0.008339709"},{"path":"https://bfunovits.github.io/RLDM/reference/RLDM-package.html","id":null,"dir":"Reference","previous_headings":"","what":"RLDM: Rational Linear Dynamic Models — RLDM-package","title":"RLDM: Rational Linear Dynamic Models — RLDM-package","text":"package provides tools stationary processes rational spectral density. implements VARMA state space models methods estimation, simulation, prediction, model comparison.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/RLDM-package.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"RLDM: Rational Linear Dynamic Models — RLDM-package","text":"package uses Rcpp/RcppArmadillo performance-critical computations including Kalman filtering recursive least squares. depends sister package rationalmatrices rational matrix operations.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/RLDM-package.html","id":"package-organization","dir":"Reference","previous_headings":"","what":"Package Organization","title":"RLDM: Rational Linear Dynamic Models — RLDM-package","text":"R source files use numeric prefix system organized purpose/workflow: 01_: Model representations classes (armamod, stspmod, rmfdmod) 02_: Parameter templates (tmpl_* functions, fill_template, extract_theta) 03_: Derived properties (autocovariance, frequency response, impulse response, spectral density, poles) 04_: Time series operations (solve_de, sim, prediction/forecasting) 05_: Estimation methods (AR, ARMA, subspace, likelihood, recursive least squares) 06_: Visualization (plot methods properties predictions) 07_: Model comparison metrics diagnostics 08_: Utilities (print, str, data documentation, package metadata)","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/RLDM-package.html","id":"getting-started","dir":"Reference","previous_headings":"","what":"Getting Started","title":"RLDM: Rational Linear Dynamic Models — RLDM-package","text":"See vignettes different user levels: vignette(\"0_getting_started\") beginner-friendly introduction vignette(\"1_case_study\") practical end--end workflow vignette(\"2_technical_reference\") technical details method selection","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/RLDM-package.html","id":"citation","dir":"Reference","previous_headings":"","what":"Citation","title":"RLDM: Rational Linear Dynamic Models — RLDM-package","text":"using RLDM publications, please cite relevant theory papers referenced vignettes. Use citation(\"RLDM\") package citation.","code":""},{"path":[]},{"path":"https://bfunovits.github.io/RLDM/reference/RLDM-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"RLDM: Rational Linear Dynamic Models — RLDM-package","text":"Wolfgang Scherrer, Bernd Funovits Maintainer: bernd.funovits@gmail.com","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/RSdata.html","id":null,"dir":"Reference","previous_headings":"","what":"Ramey/Shapiro dataset — RSdata","title":"Ramey/Shapiro dataset — RSdata","text":"dataset contains (248 x 7)-dimensional matrix quarterly US data first quarter 1947 till last quarter 2008. script transforming raw data (csv-file) matrix RSdata available data-raw directory. data set used identify government spending shocks particular investigate response consumption real wages respect shocks. variables orthogonalized respect intercept linear trend. See https://doi.org/10.1093/qje/qjq008 details.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/RSdata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Ramey/Shapiro dataset — RSdata","text":"","code":"RSdata  RSdata_ts  RSdata_xts"},{"path":"https://bfunovits.github.io/RLDM/reference/RSdata.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Ramey/Shapiro dataset — RSdata","text":"matrix 248 rows 7 variables (plus timestamp, total 8 variables). Versions tibble (RSdata), ts (RSdata_ts), xts (RSdata_xts) object available: Date column logarithm real per capita quantities total government spending real GDP total hours worked nondurable plus services consumption private fixed investment real wage (precisely nominal compensation private business divided deflator private business) tax rate object class mts (inherits ts, matrix) 248 rows 7 columns. object class xts (inherits zoo) 248 rows 7 columns.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/RSdata.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Ramey/Shapiro dataset — RSdata","text":"https://econweb.ucsd.edu/~vramey/research.html","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/STSmodel.html","id":null,"dir":"Reference","previous_headings":"","what":"Structural Time Series Models — STSmodels","title":"Structural Time Series Models — STSmodels","text":"Tools Structural Time Series Models, described e.g. (Harvey 1994) .","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/STSmodel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Structural Time Series Models — STSmodels","text":"","code":"tmpl_llm()  tmpl_lltm()  tmpl_cycle(fr, rho)  tmpl_season(s)  cbind_templates(...)"},{"path":"https://bfunovits.github.io/RLDM/reference/STSmodel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Structural Time Series Models — STSmodels","text":"fr, rho frequency damping factor cyclical components s (integer > 1) period seasonal component. ... compatible (state space model) templates. output dimensions state space models must templates.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/STSmodel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Structural Time Series Models — STSmodels","text":"Model template, .e. list slots h \\(((m+s)(n+s) + m^2)\\)-dimensional vector, H \\(((m+s)(n+s) + m^2, k)\\)-dimensional matrix, class class = \"stspmod\", state space models implemented order order = c(m,n,s) (output, noise state dimensions), n.par number free parameters \\(=k\\) idx list slots state, noise par. indices code states, noise components parameters associated respective components. See example(s) .","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/STSmodel.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Structural Time Series Models — STSmodels","text":"Local Level Model (LLM): tmpl_llm() $$a_{t+1} = a_t + u_t,\\quad y_t = a_t$$ \\((u_t)\\) white noise variance \\(\\sigma_u^2\\). model one free parameter \\(\\theta = \\sigma_u\\). output process \\((y_t)\\) random walk. Local Linear Trend Model (LLTM): tmpl_lltm() $$a_{t+1} = a_t + b_t + u_t,\\quad b_{t+1} = b_t + v_t,\\quad y_t = a_t$$ \\((u_t)\\), \\((v_t)\\) two independent white noise processes variance  \\(\\sigma_u^2\\)  \\(\\sigma_v^2\\). model two free parameter \\(\\theta_1 = \\sigma_u\\)  \\(\\theta_2 = \\sigma_v\\). general output process integrated order two (\\((2)\\)). \\(sigma[v]^2=0\\) model generates random walk drift \\(sigma[u]^2=0\\) one gets integrated random walk. Cyclical Models: tmpl_cycle(fr, rho) tmpl_cycl(fr. rho) generates template scalar AR(2) models, AR polynomial two roots $$z = \\rho^{-1}\\exp((\\pm 2\\pi f)$$ \"damping factor\" \\(\\rho\\) close one model generates processes strong \"cyclical component\" frequency \\(f\\). \\(\\rho <1\\) AR(2) model satisfies stability condition, .e. forward solution converges stationary process. \\(\\rho > 1\\) trajectories forward solution diverge exponentially. template one free parameter, standard deviation driving white noise: \\(\\theta = \\sigma_u\\). Seasonal Models: tmpl_season(s) tmpl_season(s) generates template scalar seasonal models, .e. models generate trajectories \"almost\" periodic given period, \\(s\\) say. template one free parameter, standard deviation driving white noise: \\(\\theta = \\sigma_u\\). Combine Models cbind_templates(...) utility cbind_templates(...) may used construct models simple \"bulding blocks\". Suppose e.g. observed process described sum two (unobserved) components $$y_t = k_1(z) u_t + k_2(z) v_t$$ \\((u_t)\\), \\((v_t)\\) two independent white noise processes. components described templates tmpl1 tmpl2 may construct template combined model simply cbind_templates(tmpl1, tmpl2). function cbind_templates deals state space models course templates must describe outputs dimension. functions tmpl_llm(), ..., tmpl_season() generate templates scalar time series. However, utility cbind_templates(...) also handles multivariate case.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/STSmodel.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Structural Time Series Models — STSmodels","text":"Harvey AC (1994). Forecasting, Structural Time Series Models Kalman Filter. Cambridge University Press, Cambridge.","code":""},{"path":[]},{"path":"https://bfunovits.github.io/RLDM/reference/STSmodel.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Structural Time Series Models — STSmodels","text":"","code":"# build a structural times series model (see Harve 94) with #   a \"local linear trend component\", #   a cyclical component with period 50 (frequency 1/50), #   a seasonal component with period 6 and #   an AR(1) component. tmpl = cbind_templates(tmpl_lltm(), tmpl_cycle(1/50,1), tmpl_season(6),                        tmpl_stsp_ar(1, 1, sigma_L = 'identity')) # set some \"reasonable\" values for the standard deviations # of the respective noise and for the AR(1) coefficient. model = fill_template(c(0.0, 0.1,  # parameters for trend (lltm) component                             0.1,       # parameter for cyclical component                             0.1,       # parameter for seasonal component                            -0.5        # AR(1) coefficient                            ), tmpl) print(model) #> state space model [1,5] with s = 10 states #>       s[1] s[2]     s[3] s[4] s[5] s[6] s[7] s[8] s[9] s[10] u[1] u[2] u[3] #> s[1]     1    1 0.000000    0    0    0    0    0    0   0.0    1    0    0 #> s[2]     0    1 0.000000    0    0    0    0    0    0   0.0    0    1    0 #> s[3]     0    0 1.984229   -1    0    0    0    0    0   0.0    0    0    1 #> s[4]     0    0 1.000000    0    0    0    0    0    0   0.0    0    0    0 #> s[5]     0    0 0.000000    0   -1   -1   -1   -1   -1   0.0    0    0    0 #> s[6]     0    0 0.000000    0    1    0    0    0    0   0.0    0    0    0 #> s[7]     0    0 0.000000    0    0    1    0    0    0   0.0    0    0    0 #> s[8]     0    0 0.000000    0    0    0    1    0    0   0.0    0    0    0 #> s[9]     0    0 0.000000    0    0    0    0    1    0   0.0    0    0    0 #> s[10]    0    0 0.000000    0    0    0    0    0    0  -0.5    0    0    0 #> x[1]     1    0 1.984229   -1   -1   -1   -1   -1   -1  -0.5    0    0    1 #>       u[4] u[5] #> s[1]     0    0 #> s[2]     0    0 #> s[3]     0    0 #> s[4]     0    0 #> s[5]     1    0 #> s[6]     0    0 #> s[7]     0    0 #> s[8]     0    0 #> s[9]     0    0 #> s[10]    0    1 #> x[1]     1    1 #> Left square root of noise covariance Sigma: #>      u[1] u[2] u[3] u[4] u[5] #> u[1]    0  0.0  0.0  0.0    0 #> u[2]    0  0.1  0.0  0.0    0 #> u[3]    0  0.0  0.1  0.0    0 #> u[4]    0  0.0  0.0  0.1    0 #> u[5]    0  0.0  0.0  0.0    1  # simulate the time series (with initial states) out = sim(model, n.obs = 100,           a1 = c(100, 1,     # initial states for the trend component                  3, 0,       # initial states for the cyclical component                  5, 10, 10, -10, -10,   # ... for the seasonal component                  0           # initial state for the AR(1) component           ))  # extract the contribution of the respective components X = cbind(out$y,  out$a[1:100,tmpl$idx$state == 1, drop = FALSE] %*% model$sys$C[1, tmpl$idx$state == 1] +   out$u[,tmpl$idx$noise == 1, drop = FALSE] %*% model$sys$D[1, tmpl$idx$noise == 1],  out$a[1:100,tmpl$idx$state == 2, drop = FALSE] %*% model$sys$C[1, tmpl$idx$state == 2] +   out$u[,tmpl$idx$noise == 2, drop = FALSE] %*% model$sys$D[1, tmpl$idx$noise == 2],  out$a[1:100,tmpl$idx$state == 3, drop = FALSE] %*% model$sys$C[1, tmpl$idx$state == 3] +   out$u[,tmpl$idx$noise == 3, drop = FALSE] %*% model$sys$D[1, tmpl$idx$noise == 3],  out$a[1:100,tmpl$idx$state == 4, drop = FALSE] %*% model$sys$C[1, tmpl$idx$state == 4] +   out$u[,tmpl$idx$noise == 4, drop = FALSE] %*% model$sys$D[1, tmpl$idx$noise == 4])  matplot(X, ylab = 'y', xlab = 't',         type = 'l', lty = 1, col = 1:5) grid() legend('topleft', legend = c('y','trend','cycle','season','AR(1) noise'),        lwd = 2, col = 1:5, bty = 'n')   if (FALSE) { # \\dontrun{ # the following examples throw errors # 1 is not a template cbind_templates(1, tmpl_season(4)) # the respective output dimensions are not equal cbind_templates(tmpl_season(4), tmpl_stsp_ar(2, 2)) # the third argument is a \"VARMA template\" cbind_templates(tmpl_lltm(), tmpl_cycle(1/20,1), tmpl_arma_pq(1, 1, 1, 1)) } # } # Create a template tmpl <- tmpl_lltm() tmpl #> $h #>  [1] 1 0 1 1 1 0 1 0 0 0 1 0 0 0 0 0 #>  #> $H #>       [,1] [,2] #>  [1,]    0    0 #>  [2,]    0    0 #>  [3,]    0    0 #>  [4,]    0    0 #>  [5,]    0    0 #>  [6,]    0    0 #>  [7,]    0    0 #>  [8,]    0    0 #>  [9,]    0    0 #> [10,]    0    0 #> [11,]    0    0 #> [12,]    0    0 #> [13,]    1    0 #> [14,]    0    0 #> [15,]    0    0 #> [16,]    0    1 #>  #> $class #> [1] \"stspmod\" #>  #> $order #> [1] 1 2 2 #>  #> $n.par #> [1] 2 #>   # Use the template with fill_template() # filled <- fill_template(tmpl, theta = rnorm(tmpl$n.par)) # Create a template tmpl <- tmpl_cycle(fr = 1/20, rho = 1) tmpl #> $h #>  [1]  1.902113  1.000000  1.902113 -1.000000  0.000000 -1.000000  1.000000 #>  [8]  0.000000  1.000000  0.000000 #>  #> $H #>       [,1] #>  [1,]    0 #>  [2,]    0 #>  [3,]    0 #>  [4,]    0 #>  [5,]    0 #>  [6,]    0 #>  [7,]    0 #>  [8,]    0 #>  [9,]    0 #> [10,]    1 #>  #> $class #> [1] \"stspmod\" #>  #> $order #> [1] 1 1 2 #>  #> $n.par #> [1] 1 #>   # Use the template with fill_template() # filled <- fill_template(tmpl, theta = rnorm(tmpl$n.par)) # Create a template tmpl <- tmpl_season(s = 4) tmpl #> $h #>  [1] -1  1  0 -1 -1  0  1 -1 -1  0  0 -1  1  0  0  1  0 #>  #> $H #>       [,1] #>  [1,]    0 #>  [2,]    0 #>  [3,]    0 #>  [4,]    0 #>  [5,]    0 #>  [6,]    0 #>  [7,]    0 #>  [8,]    0 #>  [9,]    0 #> [10,]    0 #> [11,]    0 #> [12,]    0 #> [13,]    0 #> [14,]    0 #> [15,]    0 #> [16,]    0 #> [17,]    1 #>  #> $class #> [1] \"stspmod\" #>  #> $order #> [1] 1 1 3 #>  #> $n.par #> [1] 1 #>   # Use the template with fill_template() # filled <- fill_template(tmpl, theta = rnorm(tmpl$n.par)) # Basic example result <- cbind_templates() result #> NULL"},{"path":"https://bfunovits.github.io/RLDM/reference/armamod.html","id":null,"dir":"Reference","previous_headings":"","what":"Constructor for LMFD (ARMA) Models — armamod","title":"Constructor for LMFD (ARMA) Models — armamod","text":"left-matrix fraction description (LMFD) plus parameterisation noise covariance.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/armamod.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Constructor for LMFD (ARMA) Models — armamod","text":"","code":"armamod(sys, sigma_L = NULL, names = NULL, label = NULL)"},{"path":"https://bfunovits.github.io/RLDM/reference/armamod.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Constructor for LMFD (ARMA) Models — armamod","text":"sys rationalmatrices::lmfd() rationalmatrices::rmfd() object sigma_L Left-factor noise covariance, .e. covariance \\(\\sigma\\) obtained sigma_L * t(sigma_L). sigma_L vector dimension \\(n\\), \\(n\\) input dimension, diagonal elements parametrized. vector dimension \\(n^2\\), elements sigma_L filled column column. names optional vector character strings label optional character string","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/armamod.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Constructor for LMFD (ARMA) Models — armamod","text":"Object class armamod.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/armamod.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Constructor for LMFD (ARMA) Models — armamod","text":"Hannan, Deistler (2012, page 7), RMFDs also called dynamic adjustment forms. Internally, MFDs lists slots sys, sigma_L, names, label.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/armamod.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Constructor for LMFD (ARMA) Models — armamod","text":"","code":"x = armamod(sys = lmfd(c(1, 0.5), 1), sigma_L = diag(1)) x #> ARMA model [1,1] with orders p = 1 and q = 0 #> AR polynomial a(z): #>      z^0 [,1] z^1 [,1] #> [1,]        1      0.5 #> MA polynomial b(z): #>      z^0 [,1] #> [1,]        1 #> Left square root of noise covariance Sigma: #>      u[1] #> u[1]    1"},{"path":"https://bfunovits.github.io/RLDM/reference/arx_rls_core.html","id":null,"dir":"Reference","previous_headings":"","what":"RLS function — arx_rls_core","title":"RLS function — arx_rls_core","text":"function implements Recursive Least Squares (RLS) algorithm exponentially -weighted past.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/arx_rls_core.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"RLS function — arx_rls_core","text":"","code":"arx_rls_core(   y,   X,   r = matrix(c(0.9, 0.95, 0.975, 0.9875, 0.99375, 0.996875, 0.9984375, 1), ncol = 1),   n_init = NULL,   start_of_eval = NULL,   end_of_train = NULL,   enhance_conv = TRUE )"},{"path":"https://bfunovits.github.io/RLDM/reference/arx_rls_core.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"RLS function — arx_rls_core","text":"y Vector doubles. Response variable regression. must NAs vector. X Matrix doubles. Dimension = (length(y) x maximal number regressors). NAs handled separately (.e. must checked function called). r Matrix doubles (column vector dimension \\(( \\text{forgetting\\_factors} \\times 1)\\) containing forgetting factors. n_init Integer. Number observations used initial estimate beta. value provided, least 21 observations (3 weeks) 3 times number regressors used. start_of_eval Integer. Starting value evaluation period honest prediction error (start early, bad initial estimations involved) end_of_train Integer. Index specifying end training set. (Afterwards forecasting period starts.) Important calculating honest prediction error (otherwise --sample...). comment_bf: one wants use arx_rls_core() outside automated forecasting framework, set end_of_train length(y). enhance_conv Boolean. Indicates whether convergence enhancing factor described Young (2011) page 55.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/arx_rls_core.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"RLS function — arx_rls_core","text":"List containing y_pred: vector predictions (vector length input y) fev_honest: double. honest prediction error (calculated end_of_train - start_of_eval + 1 observations) forgetting: double. forgetting factor produced minimal honest prediction error","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/arx_rls_core.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"RLS function — arx_rls_core","text":"","code":"# Generate simple time series data set.seed(123) n <- 100 x1 <- rnorm(n) x2 <- rnorm(n) X <- cbind(x1, x2) y <- 2*x1 + 3*x2 + rnorm(n, sd = 0.5) y <- matrix(y, ncol = 1)  # Convert to matrix  # Run RLS with default forgetting factors result <- arx_rls_core(y, X, n_init = 20, start_of_eval = 25, end_of_train = 80) str(result) #> List of 3 #>  $ y_pred    : num [1:100] NA NA NA NA NA NA NA NA NA NA ... #>  $ fev_honest: num 0.187 #>  $ forgetting: num 1"},{"path":"https://bfunovits.github.io/RLDM/reference/as.stspmod.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce to State Space Model — as.stspmod","title":"Coerce to State Space Model — as.stspmod","text":"function rationalmatrices::.stsp.pseries() calls rationalmatrices::pseries2stsp() default parameters. course rationalmatrices::pseries() object must contain sufficiently many lags. YET implemented","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/as.stspmod.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce to State Space Model — as.stspmod","text":"","code":"as.stspmod(obj, ...)  # S3 method for class 'armamod' as.stspmod(obj, ...)"},{"path":"https://bfunovits.github.io/RLDM/reference/as.stspmod.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce to State Space Model — as.stspmod","text":"obj object ... optional additional parameters method character string","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/as.stspmod.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coerce to State Space Model — as.stspmod","text":"object class stspmod().","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/as.stspmod.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coerce to State Space Model — as.stspmod","text":"","code":"# Convert an ARMA model to state space representation arma_model = armamod(sys = lmfd(c(1, 0.5, 0.2), c(1, -0.3)), sigma_L = diag(1)) ss_model = as.stspmod(arma_model) ss_model #> state space model [1,1] with s = 2 states #>      s[1] s[2] u[1] #> s[1] -0.5 -0.2  0.2 #> s[2]  1.0  0.0 -0.8 #> x[1]  0.0  1.0  1.0 #> Left square root of noise covariance Sigma: #>      u[1] #> u[1]    1"},{"path":"https://bfunovits.github.io/RLDM/reference/autocov.html","id":null,"dir":"Reference","previous_headings":"","what":"Autocovariance, Autocorelation and Partial Autocorrelation Function — autocov","title":"Autocovariance, Autocorelation and Partial Autocorrelation Function — autocov","text":"Compute respectively estimate autocovariance, autocorrelation partial autocorrelation function stationary process.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/autocov.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Autocovariance, Autocorelation and Partial Autocorrelation Function — autocov","text":"","code":"autocov(obj, type, ...)  # Default S3 method autocov(   obj,   type = c(\"covariance\", \"correlation\", \"partial\"),   lag.max = NULL,   na.action = stats::na.fail,   demean = TRUE,   ... )  # S3 method for class 'autocov' autocov(obj, type = c(\"covariance\", \"correlation\", \"partial\"), ...)  # S3 method for class 'armamod' autocov(   obj,   type = c(\"covariance\", \"correlation\", \"partial\"),   lag.max = 12,   ... )  # S3 method for class 'stspmod' autocov(   obj,   type = c(\"covariance\", \"correlation\", \"partial\"),   lag.max = 12,   ... )"},{"path":"https://bfunovits.github.io/RLDM/reference/autocov.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Autocovariance, Autocorelation and Partial Autocorrelation Function — autocov","text":"obj either armamod(), stspmod(), autocov() object \"data\" object. type character string giving type acf computed. Allowed values \"covariance\" (default), \"correlation\", \"partial\". partially matched. Note default value \"covariance\" whereas stats::acf() uses \"correlation\" default. ... used. lag.max (integer) maximum lag. na.action function called handle missing values. stats::na.pass() can used. demean logical. covariances sample means?","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/autocov.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Autocovariance, Autocorelation and Partial Autocorrelation Function — autocov","text":"autocov object, .e. list slots acf rationalmatrices::pseries() object, stores covariances (correlations). type character string indicates type ACF. gamma (m,m,lag.max+1) dimensional array stores autocovariance function. names (m)-dimensional character vector NULL. optional slot stores names components time series/process. label character string NULL. n.obs integer NULL. slot stores sample size.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/autocov.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Autocovariance, Autocorelation and Partial Autocorrelation Function — autocov","text":"class input parameter \"obj\" determines S3 method called hence actually computed. Population ACF: \"obj\" armamod() stspmod() object autocov(obj, ...) computes ACF corresponding stationary process. Note however, function returns nonsense, model satisfy stability condition. Change type ACF: Calling autocov(obj, type), \"obj\" autocov object returns ACF desired type. E.g. \"obj\" holds partial autocorrelation function autocov(obj, type = 'covariance') may used retrieve corresponding autocovariance function. possible since autocov object stores \"original\" autocovariances slot named gamma. Sample ACF: default S3 method estimates ACF given data. assumes \"obj\" univariate multivariate numeric time series object, (numeric) data frame (numeric) vector, respectively matrix simply calls function stats::acf() stats package compute sample autocovariance function. needed, corresponding sample autocorrelation, respectively sample partial autocorrelation function computed (returned). syntax quite analogous stats::acf(), please consider documentation stats::acf() details. Note stats stores autocovariance/autocorrelation functions (lag.max+1,m,m) dimensional arrays, whereas RLDM uses (m,m,lag.max+1) dimensional arrays. definition partial autocorrelations used stats::acf() differs definition used , see e.g. (Reinsel 1997) . Furthermore stats::acf() skips lag zero partial autocorrelation coefficient thus pacf computed  stats::acf() (lag.max,n,n) dimensional. default choice number lags \\(10*log10(N/m)\\) \\(N\\) number observations \\(m\\) number series. number automatically limited one less number observations series.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/autocov.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Autocovariance, Autocorelation and Partial Autocorrelation Function — autocov","text":"Reinsel GC (1997). Elements Multivariate Time Series Analysis. Springer.","code":""},{"path":[]},{"path":"https://bfunovits.github.io/RLDM/reference/autocov.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Autocovariance, Autocorelation and Partial Autocorrelation Function — autocov","text":"","code":"model = stspmod(sys = stsp(A = c(0,0.2,1,-0.5), B = c(1,1,1,-1),                            C = c(1,0,0,1)), sigma_L = diag(c(4,1)),                 names = c('y1','y2'), label = 'test model') g = autocov(model, lag.max=10)       # ACF r = autocov(model, lag.max=10, type = 'correlation')  # autocorrelation function r = autocov(g, type = 'correlation')                  # this gives the same result! c = autocov(r, type = 'partial')     # partial autocorrelation function  if (FALSE) { # \\dontrun{ # consider an equivalent VARMA model model2 = impresp2varma(irf(model, lag.max = 20))$model g2 = autocov(model2, lag.max = 10) all.equal(g,g2) # of course both return the same ACF  autocov(matrix(rnorm(100*2), nrow = 100)) autocov(stspmod(test_stsp(dim = c(2,2), s = 2), sigma_L = diag(2)))  # generate a random sample with 100 observations and 3 outputs/series. x = matrix(rnorm(100*3), nrow = 100, ncol = 3)  # the covariance estimates are of course identical stats_acfobj = stats::acf(x, type = 'covariance', demean = TRUE, plot = FALSE) rldm_acfobj  = acf_estimate(x, type = 'covariance', demean = TRUE) testthat::expect_equivalent(rldm_acfobj$gamma, aperm(stats_acfobj$acf,c(2,3,1)))  # also the correlation estimates are identical stats_acfobj = stats::acf(x, type = 'correlation', demean = TRUE, plot = FALSE) rldm_acfobj  = acf_estimate(x, type = 'correlation', demean = TRUE) testthat::expect_equivalent(rldm_acfobj$gamma, aperm(stats_acfobj$acf,c(2,3,1)))  # However, the partial correlations dont match! stats_acfobj = stats::acf(x, type = 'partial', demean = TRUE, plot = FALSE) rldm_acfobj  = acf_estimate(x, type = 'partial', demean = TRUE) testthat::expect_equivalent(rldm_acfobj$gamma[,,-1,drop=FALSE], aperm(stats_acfobj$acf,c(2,3,1))) } # }"},{"path":"https://bfunovits.github.io/RLDM/reference/compare_estimates.html","id":null,"dir":"Reference","previous_headings":"","what":"Compare Estimated Models — compare_estimates","title":"Compare Estimated Models — compare_estimates","text":"utility function computes number statistics may used compare/evaluate set estimated models. particular function returns log Likelihood (ll), Akaike Information Criterion (AIC), Bayes Information Criterion (BIC), Final Prediction Error (FPE) p-values Portmanteau test serial correlation residuals.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/compare_estimates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compare Estimated Models — compare_estimates","text":"","code":"compare_estimates(estimates, y, n.lags = NULL)"},{"path":"https://bfunovits.github.io/RLDM/reference/compare_estimates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compare Estimated Models — compare_estimates","text":"estimates (named) list estimates. slot contain list slots $model (estimated model) $n.par corresponding number (free) parameters model (class). y (N--m)-dimensional matrix observed data (object may coerced matrix .matrix(y)). n.lags number lags Portmantaeu test serial correlation residuals, see also pm_test().","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/compare_estimates.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compare Estimated Models — compare_estimates","text":"Matrix computed statistics estimated models. matrix attributes m, n.obs n.lags.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/compare_estimates.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compare Estimated Models — compare_estimates","text":"concentrated, conditional (scaled) log Likelihood $$ll = -(1/2)(m \\ln(2\\pi) + m + \\ln\\det S + 2 \\ln\\det (k_0)$$ computed ll(model, y, skip = 0, concentrated = TRUE), see ll(). \\(S\\) denotes sample covariance residuals model. information criteria $$AIC = -2 ll + (2/N) \\kappa$$ $$BIC = -2 ll + (\\ln(N)/N) \\kappa$$ \\(\\kappa\\) denotes respective number free parameters. Final Prediction Error $$FPE = \\det(S)\\frac{N+\\kappa}{N-\\kappa}$$ portmanteau test, see pm_test(). number lags specified procedure choses default value based sample size. (values attached output attribute). Note procedure (re)evaulates measures, even estimates contain information (e.g. residuals log likelihood may stored corresponding list). reason common data set common evaluation procedure estimates. Typically data y \"estimation data set\", .e. data used estimate models. However, one may also pass new data set procedure.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/compare_estimates.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compare Estimated Models — compare_estimates","text":"","code":"# Generate some data set.seed(123) model = stspmod(sys = stsp(A = matrix(c(0.5, 0.2, 0, 0.3), 2, 2),                            B = matrix(c(1, 0.5), 2, 1),                            C = matrix(c(1, 0), 1, 2),                            D = matrix(1, 1, 1)),                 sigma_L = matrix(1, 1, 1)) y = sim(model, n.obs = 100)$y  # Create two different estimates (simulated for example) estimate1 = list(model = model, n.par = 4) estimate2 = list(model = stspmod(sys = stsp(A = matrix(c(0.4, 0.1, 0, 0.35), 2, 2),                                            B = matrix(c(1.1, 0.4), 2, 1),                                            C = matrix(c(0.9, 0), 1, 2),                                            D = matrix(1, 1, 1)),                                     sigma_L = matrix(1.2, 1, 1)),                  n.par = 4)  # Compare estimates estimates = list(\"Estimate 1\" = estimate1, \"Estimate 2\" = estimate2) comparison = compare_estimates(estimates, y, n.lags = 5) comparison #>            #par        ll      AIC      BIC       FPE    PM test #> Estimate 1    4 -1.327622 2.735244 2.839451 0.9024965 0.03727574 #> Estimate 2    4 -1.319477 2.718955 2.823161 0.8879145 0.08825713 #> attr(,\"m\") #> [1] 100 #> attr(,\"n.obs\") #> [1] 100 #> attr(,\"n.lags\") #> [1] 5"},{"path":"https://bfunovits.github.io/RLDM/reference/dft_3D.html","id":null,"dir":"Reference","previous_headings":"","what":"Discrete Time Fourier Transform — dft_3D","title":"Discrete Time Fourier Transform — dft_3D","text":"Compute Discrete Time Fourier Transform data stored 3-dimensional array.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/dft_3D.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Discrete Time Fourier Transform — dft_3D","text":"","code":"dft_3D(a, n.f = dim(a)[3])"},{"path":"https://bfunovits.github.io/RLDM/reference/dft_3D.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Discrete Time Fourier Transform — dft_3D","text":"\\((m,n,k)\\) dimensional (numeric) array n.f (integer) number frequencies","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/dft_3D.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Discrete Time Fourier Transform — dft_3D","text":"rationalmatrices::zvalues() object.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/dft_3D.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Discrete Time Fourier Transform — dft_3D","text":"","code":"# Basic example a <- array(1:12, dim = c(2, 2, 3)) result <- dft_3D(a) result #> ( 2 x 2 ) frequency response #>      z[1] [,1]  [,2]    z[2] [,1]         [,2]    z[3] [,1]         [,2] #> [1,]     15+0i 21+0i -6+3.464102i -6+3.464102i -6-3.464102i -6-3.464102i #> [2,]     18+0i 24+0i -6+3.464102i -6+3.464102i -6-3.464102i -6-3.464102i"},{"path":"https://bfunovits.github.io/RLDM/reference/est_ML.html","id":null,"dir":"Reference","previous_headings":"","what":"Maximum Likelihood Estimation — est_ML","title":"Maximum Likelihood Estimation — est_ML","text":"naive implementation Maximum Likelihood Estimation. Rather use ll() ll_FUN().","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/est_ML.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Maximum Likelihood Estimation — est_ML","text":"","code":"est_ML(   y,   tmpl,   th,   which = c(\"concentrated\", \"conditional\", \"kf\"),   method = c(\"BFGS\", \"Nelder-Mead\", \"CG\", \"L-BFGS-B\", \"SANN\", \"Brent\"),   hessian = FALSE,   control = list() )"},{"path":"https://bfunovits.github.io/RLDM/reference/est_ML.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Maximum Likelihood Estimation — est_ML","text":"y sample, .e. \\((N,m)\\) dimensional matrix, \"time series\" object (.e. .matrix(y) return \\((N,m)\\)-dimensional numeric matrix). Missing values (NA, NaN Inf) supported. tmpl model template describes model class, see model structures(). Note case (non-empty, square) state space ARMA models implemented. th Initial parameter estimate. (character string) determines \"likelihood\" used, see also ll(). option \"kf\"  supported state space models. method, hessian, control passed optimization routine stats::optim().","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/est_ML.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Maximum Likelihood Estimation — est_ML","text":"list components model estimated model. th corresponding vector deep parameters. ll log likelihood estimated model. type likelihood used. counts, convergence, message, hessian returned  stats::optim().","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/est_ML.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Maximum Likelihood Estimation — est_ML","text":"optimization computed general-purpose routine stats::optim(). initial estimate needed. procedure respect constraints like stability minimum phase. case conditional, concentrated likelihood somewhat special. case model template must particular structure: (1) noise covariance parametrized via left cholesky factor. (2) last \\(m(m+1)/2\\) components parameter vector \\(\\theta\\) parametrize left cholesky factor components describe system. (implies overlap/dependency betweeen \"system parameters\" \"noise parameters\".)","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/est_ML.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Maximum Likelihood Estimation — est_ML","text":"","code":"set.seed(123) # Generate a random model in echelon form model (m = 3) tmpl = tmpl_stsp_echelon(nu = c(2,1,1)) model = r_model(template = tmpl, bpoles = 1, bzeroes = 1, sd = 0.25) diag(model$sigma_L) = 1 # scale the diagonal entries of sigma_L print(model) #> state space model [3,3] with s = 4 states #>             s[1]       s[2]       s[3]        s[4]        u[1]       u[2] #> s[1]  0.00000000 0.00000000  0.0000000  1.00000000  0.10019286  0.1244626 #> s[2] -0.14011891 0.01762710  0.1152291 -0.11141549  0.02767068 -0.4916543 #> s[3] -0.05754437 0.03232193 -0.3162653  0.30602045 -0.13896028  0.1753390 #> s[4]  0.38967708 0.42876625 -0.1717132  0.08995346  0.44672828 -0.1181979 #> x[1]  1.00000000 0.00000000  0.0000000  0.00000000  1.00000000  0.0000000 #> x[2]  0.00000000 1.00000000  0.0000000  0.00000000  0.00000000  1.0000000 #> x[3]  0.00000000 0.00000000  1.0000000  0.00000000  0.00000000  0.0000000 #>             u[3] #> s[1] -0.26695593 #> s[2] -0.05449373 #> s[3] -0.25650111 #> s[4] -0.18222281 #> x[1]  0.00000000 #> x[2]  0.00000000 #> x[3]  1.00000000 #> Left square root of noise covariance Sigma: #>            u[1]       u[2] u[3] #> u[1]  1.0000000  0.0000000    0 #> u[2] -0.4216733  1.0000000    0 #> u[3]  0.2094468 -0.2845342    1 # extract the corresponding free/deep parameters th = extract_theta(model, tmpl)  # generate a sample with 500 observations y = sim(model, n.obs = 500, n.burn_in = 100)$y  # We are cheating here and use the true model parameters # as starting values for the optimization routine:  # estimate the model with the \"exakt log likelihood\" out = est_ML(y, tmpl, th, which = 'kf') KL_divergence(model, out$model) #> [1] 0.007795355  # estimate the model with \"conditional log likelihood\" out = est_ML(y, tmpl, th, which = 'conditional') KL_divergence(model, out$model) #> [1] 0.007764377  # estimate the model with \"concentrated, conditional log likelihood\" out = est_ML(y, tmpl, th, which = 'concentrated') KL_divergence(model, out$model) #> [1] 0.007765628"},{"path":"https://bfunovits.github.io/RLDM/reference/est_ar.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate Autoregressive Models — est_ar","title":"Estimate Autoregressive Models — est_ar","text":"function est_ar estimates (V)AR models $$(y_t - \\mu) = a_1 (y_{t-1} - \\mu) + \\cdots + a_p (y_{t-p} - \\mu) + u_t$$ given sample given (sample) autocovariance function. model order \\(p\\) chosen information criterion, like AIC BIC. \"helper\" functions est_ar_ols, est_ar_yw est_ar_dlw implement three available estimation methods: estimation ordinary least squares, Yule-Walker estimates Durbin-Levinson-Whittle method.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/est_ar.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate Autoregressive Models — est_ar","text":"","code":"est_ar(   obj,   p.max = NULL,   penalty = NULL,   ic = c(\"AIC\", \"BIC\", \"max\"),   method = c(\"yule-walker\", \"ols\", \"durbin-levinson-whittle\"),   mean_estimate = c(\"sample.mean\", \"intercept\", \"zero\"),   n.obs = NULL )  est_ar_yw(gamma, p.max = (dim(gamma)[3] - 1), penalty = -1)  est_ar_dlw(gamma, p.max = (dim(gamma)[3] - 1), penalty = -1)  est_ar_ols(   y,   p.max = NULL,   penalty = -1,   mean_estimate = c(\"sample.mean\", \"intercept\", \"zero\"),   p.min = 0L )"},{"path":"https://bfunovits.github.io/RLDM/reference/est_ar.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate Autoregressive Models — est_ar","text":"obj either \"time series\" object (.e .matrix(obj) returns \\((N,m)\\)-dimensional numeric matrix) autocov() object represents (estimated) autocovariance function. type autocov object irrelevant since est_ar always uses slot obj$gamma contains autocovariance function. p.max (integer NULL) Maximum order candidate AR models. default choice see . penalty scalar (NULL) determines \"penalty\" per parameter model. Note parameter (NULL) overrides paramater ic. ic (character string) information criterion shall used find optimal order. Note ic=\"max\" means AR(p) model p=p.max estimated. Default ic=\"AIC\". method Character string giving method used fit model. Note 'yule-walker' 'durbin-levinson-whittle' (numerical errors) equivalent choice 'ols' available \"time-series\" object obj. mean_estimate Character string giving method used estimate mean \\(\\mu\\). Default mean_estimate = \"sample.mean\". See details . n.obs Optional integer gives sample size \\(N\\). parameter used, obj autocov object. n.obs=NULL slot obj$n.obs used. Note obj$n.obs=NULL obj$n.obs=Inf refers case population autocovariance function, .e. \\(N=\\infty\\).  \"time series\" object sample size course set number observations, .e. n.obs = nrow(.matrix(obj)).  sample size \\(N\\) controls computation default maximum order p.max computation information criterion. gamma \\((m,m,lag.max+1)\\)-dimensional array, contains (sample) autocovariance function. y \\((N,m)\\)-dimensional matrix, contains sample. p.min (non negative integer) Minimum order candidate AR models. used est_ar_ols.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/est_ar.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate Autoregressive Models — est_ar","text":"function est_ar returns list components model armamod() object represents estimated AR model. p optimal model order. stats (p.max+1,4) dimensional matrix stores \\(\\ln\\det(\\Sigma_p)\\) values, number parameters IC values. See details . y.mean estimate mean \\(\\mu\\). ll log likelihood estimated model. \"helper\" functions est_ar_yw, est_ar_dlw est_ar_ols return list components (m,m,p)-dimensional array estimated AR coefficients \\(a_i\\). sigma (m,m)-dimensional matrix estimated noise covariance \\(\\Sigma\\). p estimate AR order. stats (p.max+1,4) dimensional matrix stores \\(\\ln\\det(\\Sigma_p)\\) values, number parameters IC values. See details . y.mean (est_ar_ols ) estimate mean \\(\\mu\\). residuals (est_ar_ols ) (n.obs,m) dimensional matrix OLS residuals. partial (est_ar_dlw ) (m,m,p.max+1) dimensional array (estimated) partial autocorrelation coefficients.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/est_ar.html","id":"ols-method","dir":"Reference","previous_headings":"","what":"OLS method","title":"Estimate Autoregressive Models — est_ar","text":"helper function est_ar_ols implements three schemes estimate mean \\(\\mu\\) AR parameters. choice mean_estimate = \"zero\" assumes \\(\\mu=0\\) thus AR parameters determined regression: $$y_t = a_1 y_{t-1} + \\cdots + a_p y_{t-p} + u_t \\mbox{ } t=p+1,\\ldots,N$$ case mean_estimate = \"sample.mean\" mean \\(\\mu\\) estimated sample mean AR parameters determined LS estimate regression $$(y_t - \\mu) = a_1 (y_{t-1} - \\mu) + \\cdots + a_p (y_{t-p} - \\mu) + u_t \\mbox{ } t=p+1,\\ldots,N$$ last case mean_estimate = \"intercept\", regression intercept $$y_t = d + a_1 y_{t-1} + \\cdots + a_p y_{t-p} + u_t \\mbox{ } t=p+1,\\ldots,N$$ considered. estimate \\(\\mu\\) obtained $$\\mu = (I_m - a_1 - \\cdots - a_p)^{-1} d$$ estimate mean \\(\\mu\\) fails estimated AR model unit root, .e. \\((I_m - a_1 - \\cdots - a_p)\\) singular. sample covariance corresponding residuals (scaled \\(1/(N-p)\\)) serves estimate noise covariance \\(\\Sigma\\). actual computations routine stats::lsfit() stats package used.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/est_ar.html","id":"yule-walker-estimates","dir":"Reference","previous_headings":"","what":"Yule-Walker estimates","title":"Estimate Autoregressive Models — est_ar","text":" est_ar_yw est_ar_dlw use Yule-Walker equations estimate AR coefficients \\((a_i)\\) noise covariance matrix \\(\\Sigma\\). However, use different numerical scheme solve equations. function est_ar_dlw uses Durbin-Levinson-Whittle recursions addition returns (estimates ) partial autocorrelation coefficients. obj \"time series\" object, first ACF estimated call autocov(). option mean_estimate = \"zero\" implies mean assumed zero (\\(\\mu = 0\\)) therefore autocov called option demean = FALSE. mean_estimate = \"sample.mean\" mean_estimate = \"intercept\" mean \\(\\mu\\) estimated sample mean ACF computed  demean = TRUE.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/est_ar.html","id":"estimation-of-the-ar-order","dir":"Reference","previous_headings":"","what":"Estimation of the AR order","title":"Estimate Autoregressive Models — est_ar","text":"order \\(p\\) AR model chosen minimizing information criterion form $$IC(p) = \\ln\\det\\Sigma_p + c(p)r(N) \\mbox{ } p = 0,\\ldots,p_{\\max}$$ \\(\\Sigma_p\\) estimate noise (innovation) covariance, \\(c(p)\\) counts number parameters model, \\(r(N)\\) \"penalty\" per parameter model. Note \\(\\log\\det\\Sigma\\) constant scaling factor \\(-(N-p)/2\\) equal (scaled, approximate) Gaussian log likelihood model $$ll = -(1/2)(m \\ln(2\\pi) + m + \\ln\\det \\Sigma_p)$$ See also ll(). Note value \\(ll\\), returned routine, (approximate) log Likelihood scaled factor \\(1/(N-p)\\). AR(p) model intercept, number parameters \\(c(p) = p m^2 + m\\) AR model without intercept \\(c(p) = p m^2\\). Akaike information criterion (AIC) corresponds \\(r(N)=2/N\\) Bayes information criterion (BIC) uses penatlty \\(r(N)=\\log(N)/N\\). helper routines, user set penalty term \\(r(N)\\) explicitly via input parameter \"penalty\". default choice penalty = -1 means maximum possible order p=p.max chosen. function est_ar offers parameter \"ic\" tells routine set penalty accordingly. Note choice ic=\"max\" sets \\(r(N) = -1\\) thus model maximum possible order fitted. default maximum order p.max chosen follows. helper functions est_ar_yw est_ar_dlw simply chose maximum accordng maximum lag given autocovariances, p.max = dim(gamma)[3] - 1. routine est_ar_ols uses minimum \\(12\\), \\((N-1)/(m+1)\\) \\(10*log10(N)\\) default. function est_ar uses value. However, \"obj\" autocov object p.max addition bounded number lags contained object.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/est_ar.html","id":"notes","dir":"Reference","previous_headings":"","what":"Notes","title":"Estimate Autoregressive Models — est_ar","text":"Yule-Walker estimates offer easy way reconstruct \"true\" model population autocovariance function given. noise covariance (thus likelihood values) improve model order larger true model order \"estimated\". However due numerical errors may true. simple trick one may call est_ar (est_ar_yw est_ar_dlw) small positive penalty. See example . functions essentially equivalent stats routines. (re) implemented convenience, input output parameters (models) fit RLDM conventions. AIC values RLDM routines equivalent AIC values computed stats routines constant scaling \\(N\\). seems Yule-Walker estimate stats::[ar.yw][stats::ar.yw] uses scaling factor \\((N - m(p+1))/N\\) noise covariance \\(\\Sigma\\). Finally note est_ar_ols, est_ar_yw est_ar_dlw mainly intended \"internal helper\" functions. Therefore, functions check validity input parameters.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/est_ar.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate Autoregressive Models — est_ar","text":"","code":"# set seed, to get reproducable results set.seed(5436)  ############################################################### # generate a (bivariate) random, stable AR(3) model  m = 2 p = 3 n.obs = 100 p.max = 10 tmpl = tmpl_arma_pq(m = m, n = m, p = p, q = 0) model = r_model(tmpl, bpoles = 1, sd = 0.25) # make sure that the diagonal entries of sigma_L are non negative model$sigma_L = model$sigma_L %*% diag(sign(diag(model$sigma_L)))  ############################################################### # reconstruct the true AR model from the population ACF  true_acf = autocov(model, lag.max = 12, type = 'covariance') ARest = est_ar(true_acf, p.max = p.max, method = 'yule-walker', penalty = 1e-6) all.equal(model, ARest$model) #> [1] TRUE  ############################################################### # simulate a sample  y = sim(model, n.obs = n.obs, start = list(s1 = NA))$y  ############################################################### # estimate the AR(p) model with the true order p  # OLS ARest = est_ar(y, ic = 'max', p.max = p, method = 'ols', mean_estimate = \"zero\") # check the log Likelihood p.opt = ARest$p all.equal(ll(ARest$model, y, 'conditional', skip = p.opt), ARest$ll) #> [1] TRUE  # Yule-Walker and Durbin-Levinson-Whittle are equivalent (up to numerical errors) ARest = est_ar(y, ic = 'max', p.max = p, method = 'yule-walker', mean_estimate = \"zero\") junk = est_ar(y, ic = 'max', p.max = p, method = 'durbin-levinson-whittle', mean_estimate = \"zero\") all.equal(ARest$model, junk$model) #> [1] TRUE  # alternatively we may first estimate the sample autocovariance function # note that the 'type' of the ACF is irrelevant sample_acf = autocov(y, type = 'correlation', demean = FALSE) junk = est_ar(sample_acf, ic = 'max', p.max = p, method = 'yule-walker') all.equal(ARest$model, junk$model) #> [1] TRUE  ############################################################### # estimate the order of the AR model with 'AIC', estimate a model with intercept ARest = est_ar(y, ic = 'AIC', p.max = p.max, method = 'ols', mean_estimate = \"intercept\") print(ARest$model) #> ARMA model [2,2] with orders p = 3 and q = 0 #> AR polynomial a(z): #>      z^0 [,1]  [,2]  z^1 [,1]       [,2]  z^2 [,1]       [,2]  z^3 [,1] #> [1,]        1     0 0.1758752 -0.2469383 0.4064368 -0.2595963 0.7758289 #> [2,]        0     1 0.3113271 -0.3092643 0.3315128 -0.1661434 0.3077410 #>            [,2] #> [1,] -0.2624946 #> [2,] -0.2492206 #> MA polynomial b(z): #>      z^0 [,1]  [,2] #> [1,]        1     0 #> [2,]        0     1 #> Left square root of noise covariance Sigma: #>          u[1]      u[2] #> u[1] 0.144723 0.0000000 #> u[2] 0.188681 0.1501011  # compare with the stats::ar function ARest2 = stats::ar(y, aic = TRUE, order.max = p.max, method = 'ols', intercept = TRUE) # the estimated coefficients are equal all.equal(unclass(ARest$model$sys$a)[,,-1], -aperm(ARest2$ar, c(2,3,1)), check.attributes = FALSE) #> [1] TRUE # also the AIC values are up to scaling equivalent all.equal( ARest$stats[,'ic'] - min(ARest$stats[,'ic']), ARest2$aic/n.obs, check.attributes = FALSE) #> [1] TRUE  # reset seed set.seed(NULL) set.seed(123) # Generate example data model <- test_stspmod(dim = c(2,2), s = 2, bpoles = 1, sigma_L = diag(2)) y <- sim(model, n.obs = 100)$y  # Compute autocovariance acf_obj <- autocov(model, lag.max = 10) gamma <- acf_obj$gamma  # Run estimation result <- est_ar_yw(gamma) result #> $a #> , , 1 #>  #>           [,1]       [,2] #> [1,]  0.593593  0.4029055 #> [2,] -1.634472 -0.4848091 #>  #> , , 2 #>  #>            [,1]       [,2] #> [1,] 0.03294047 -0.1223931 #> [2,] 0.08994749  0.5193903 #>  #> , , 3 #>  #>             [,1]        [,2] #> [1,] -0.04003777 -0.04905823 #> [2,]  0.13755402  0.11528428 #>  #> , , 4 #>  #>             [,1]        [,2] #> [1,] -0.00855073  0.00186596 #> [2,]  0.01397270 -0.02196229 #>  #> , , 5 #>  #>              [,1]         [,2] #> [1,]  0.001743794  0.004002599 #> [2,] -0.008319666 -0.012063094 #>  #> , , 6 #>  #>               [,1]          [,2] #> [1,]  0.0009120883  0.0004635627 #> [2,] -0.0023173558 -0.0001580165 #>  #> , , 7 #>  #>              [,1]          [,2] #> [1,] 5.626719e-06 -0.0002334706 #> [2,] 2.806182e-04  0.0008908700 #>  #> , , 8 #>  #>               [,1]         [,2] #> [1,] -6.832243e-05 -0.000070400 #> [2,]  2.179598e-04  0.000146714 #>  #> , , 9 #>  #>               [,1]          [,2] #> [1,] -1.065933e-05  7.103105e-06 #> [2,]  1.149316e-05 -4.403497e-05 #>  #> , , 10 #>  #>               [,1]          [,2] #> [1,]  3.777965e-06  5.830430e-06 #> [2,] -1.240687e-05 -1.583706e-05 #>  #>  #> $sigma #>              [,1]         [,2] #> [1,]  1.00000e+00 -1.09468e-12 #> [2,] -1.09468e-12  1.00000e+00 #>  #> $p #> [1] 10 #>  #> $stats #>        p n.par   lndetSigma         ic #>  [1,]  0     0 1.611048e+00   1.611048 #>  [2,]  1     4 5.164767e-01  -3.483523 #>  [3,]  2     8 1.482537e-02  -7.985175 #>  [4,]  3    12 1.188096e-03 -11.998812 #>  [5,]  4    16 1.702456e-04 -15.999830 #>  [6,]  5    20 2.166470e-06 -19.999998 #>  [7,]  6    24 1.087133e-06 -23.999999 #>  [8,]  7    28 2.535586e-08 -28.000000 #>  [9,]  8    32 3.970023e-09 -32.000000 #> [10,]  9    36 3.657306e-10 -36.000000 #> [11,] 10    40 7.634338e-12 -40.000000 #>  set.seed(123) # Generate example data model <- test_stspmod(dim = c(2,2), s = 2, bpoles = 1, sigma_L = diag(2)) y <- sim(model, n.obs = 100)$y  # Compute autocovariance acf_obj <- autocov(model, lag.max = 10) gamma <- acf_obj$gamma  # Run estimation result <- est_ar_dlw(gamma) result #> $a #> , , 1 #>  #>           [,1]       [,2] #> [1,]  0.593593  0.4029055 #> [2,] -1.634472 -0.4848091 #>  #> , , 2 #>  #>            [,1]       [,2] #> [1,] 0.03294047 -0.1223931 #> [2,] 0.08994749  0.5193903 #>  #> , , 3 #>  #>             [,1]        [,2] #> [1,] -0.04003777 -0.04905823 #> [2,]  0.13755402  0.11528428 #>  #> , , 4 #>  #>             [,1]        [,2] #> [1,] -0.00855073  0.00186596 #> [2,]  0.01397270 -0.02196229 #>  #> , , 5 #>  #>              [,1]         [,2] #> [1,]  0.001743794  0.004002599 #> [2,] -0.008319666 -0.012063094 #>  #> , , 6 #>  #>               [,1]          [,2] #> [1,]  0.0009120883  0.0004635627 #> [2,] -0.0023173558 -0.0001580165 #>  #> , , 7 #>  #>              [,1]          [,2] #> [1,] 5.626719e-06 -0.0002334706 #> [2,] 2.806182e-04  0.0008908700 #>  #> , , 8 #>  #>               [,1]         [,2] #> [1,] -6.832243e-05 -0.000070400 #> [2,]  2.179598e-04  0.000146714 #>  #> , , 9 #>  #>               [,1]          [,2] #> [1,] -1.065933e-05  7.103105e-06 #> [2,]  1.149316e-05 -4.403497e-05 #>  #> , , 10 #>  #>               [,1]          [,2] #> [1,]  3.777965e-06  5.830430e-06 #> [2,] -1.240687e-05 -1.583706e-05 #>  #>  #> $sigma #>               [,1]          [,2] #> [1,]  1.000000e+00 -1.095188e-12 #> [2,] -1.095188e-12  1.000000e+00 #>  #> $p #> [1] 10 #>  #> $stats #>        p n.par   lndetSigma         ic #>  [1,]  0     0 1.611048e+00   1.611048 #>  [2,]  1     4 5.164767e-01  -3.483523 #>  [3,]  2     8 1.482537e-02  -7.985175 #>  [4,]  3    12 1.188096e-03 -11.998812 #>  [5,]  4    16 1.702456e-04 -15.999830 #>  [6,]  5    20 2.166470e-06 -19.999998 #>  [7,]  6    24 1.087133e-06 -23.999999 #>  [8,]  7    28 2.535586e-08 -28.000000 #>  [9,]  8    32 3.970023e-09 -32.000000 #> [10,]  9    36 3.657310e-10 -36.000000 #> [11,] 10    40 7.635448e-12 -40.000000 #>  #> $partial #> , , 1 #>  #>            [,1]       [,2] #> [1,]  1.0000000 -0.4553269 #> [2,] -0.4553269  1.0000000 #>  #> , , 2 #>  #>            [,1]        [,2] #> [1,]  0.2531218  0.35658618 #> [2,] -0.6359387 -0.09203067 #>  #> , , 3 #>  #>            [,1]       [,2] #> [1,]  0.1239848 -0.2030783 #> [2,] -0.3266716  0.6017541 #>  #> , , 4 #>  #>              [,1]        [,2] #> [1,]  0.010626244 -0.04270662 #> [2,] -0.005414358  0.08320880 #>  #> , , 5 #>  #>             [,1]         [,2] #> [1,] -0.00493339  0.005507714 #> [2,]  0.01907464 -0.031297476 #>  #> , , 6 #>  #>              [,1]         [,2] #> [1,] -0.001546243  0.004045939 #> [2,]  0.003282471 -0.011009282 #>  #> , , 7 #>  #>               [,1]         [,2] #> [1,]  0.0001401522 0.0001942242 #> [2,] -0.0009497122 0.0007089075 #>  #> , , 8 #>  #>               [,1]          [,2] #> [1,]  0.0001384386 -0.0002774523 #> [2,] -0.0003924843  0.0009420754 #>  #> , , 9 #>  #>              [,1]          [,2] #> [1,] 1.029896e-05 -5.667255e-05 #> [2,] 1.269272e-05  8.865205e-05 #>  #> , , 10 #>  #>               [,1]          [,2] #> [1,] -8.942113e-06  1.247439e-05 #> [2,]  3.168432e-05 -5.804427e-05 #>  #> , , 11 #>  #>               [,1]          [,2] #> [1,] -2.132853e-06  6.183752e-06 #> [2,]  3.827159e-06 -1.549790e-05 #>  #>  set.seed(123) # Generate example data model <- test_stspmod(dim = c(2,2), s = 2, bpoles = 1, sigma_L = diag(2)) y <- sim(model, n.obs = 100)$y  # Run estimation result <- est_ar_ols(y) result #> $a #> , , 1 #>  #>            [,1]       [,2] #> [1,]  0.5216462  0.4730037 #> [2,] -1.4383693 -0.7654621 #>  #> , , 2 #>  #>             [,1]      [,2] #> [1,] -0.03058286 0.0201262 #> [2,] -0.57701683 0.1919959 #>  #> , , 3 #>  #>            [,1]      [,2] #> [1,] 0.03399671 0.2621479 #> [2,] 0.16838782 0.2851212 #>  #> , , 4 #>  #>           [,1]         [,2] #> [1,] 0.5028358  0.191399797 #> [2,] 0.1098366 -0.009784647 #>  #> , , 5 #>  #>             [,1]        [,2] #> [1,]  0.06114687 -0.14561419 #> [2,] -0.03570935 -0.04731226 #>  #> , , 6 #>  #>             [,1]       [,2] #> [1,] -0.16753069 -0.1340659 #> [2,]  0.03861591 -0.1099899 #>  #> , , 7 #>  #>            [,1]       [,2] #> [1,] -0.2222810 0.06017286 #> [2,]  0.1619097 0.03008335 #>  #> , , 8 #>  #>             [,1]        [,2] #> [1,] -0.09662243  0.09499039 #> [2,]  0.04101294 -0.08523160 #>  #> , , 9 #>  #>              [,1]        [,2] #> [1,] -0.005804168  0.03833865 #> [2,] -0.131761868 -0.09399973 #>  #> , , 10 #>  #>             [,1]        [,2] #> [1,] -0.12243313 -0.01736716 #> [2,] -0.05457868 -0.07349516 #>  #>  #> $sigma #>             Y1          Y2 #> Y1  0.72666511 -0.05559743 #> Y2 -0.05559743  0.66870024 #>  #> $p #> [1] 10 #>  #> $stats #>        p n.par  lndetSigma         ic #>  [1,]  0     0  1.20445544   1.204455 #>  [2,]  1     4 -0.08870917  -4.088709 #>  [3,]  2     8 -0.30410303  -8.304103 #>  [4,]  3    12 -0.37670466 -12.376705 #>  [5,]  4    16 -0.43565670 -16.435657 #>  [6,]  5    20 -0.52199874 -20.521999 #>  [7,]  6    24 -0.61678161 -24.616782 #>  [8,]  7    28 -0.67075827 -28.670758 #>  [9,]  8    32 -0.70783818 -32.707838 #> [10,]  9    36 -0.72776027 -36.727760 #> [11,] 10    40 -0.72809053 -40.728091 #>  #> $y.mean #> [1]  0.02165726 -0.09609867 #>  #> $residuals #>               [,1]         [,2] #>   [1,]          NA           NA #>   [2,]          NA           NA #>   [3,]          NA           NA #>   [4,]          NA           NA #>   [5,]          NA           NA #>   [6,]          NA           NA #>   [7,]          NA           NA #>   [8,]          NA           NA #>   [9,]          NA           NA #>  [10,]          NA           NA #>  [11,]  0.75257328  2.198162516 #>  [12,] -0.91760186 -1.032808908 #>  [13,]  0.76632455 -0.606786757 #>  [14,] -1.06579517  0.251759752 #>  [15,] -0.17979718 -0.245658361 #>  [16,]  0.27724991  0.080232787 #>  [17,] -0.37302269  0.341120830 #>  [18,] -0.50015831  0.072468130 #>  [19,] -0.01569907  1.142532618 #>  [20,]  0.96697433  0.751541300 #>  [21,] -0.55902771  1.216187146 #>  [22,]  0.80665816  1.202537289 #>  [23,] -0.02411356 -0.555569966 #>  [24,]  1.03350698 -0.651661352 #>  [25,]  2.17157329  1.089114268 #>  [26,]  0.16547614 -0.764793440 #>  [27,]  0.21409777  0.008302741 #>  [28,] -0.04536647 -0.641723277 #>  [29,] -1.01896803 -0.537498856 #>  [30,] -0.35098949 -1.625324644 #>  [31,]  0.25812793  0.262770086 #>  [32,] -0.15655903 -0.246093154 #>  [33,] -0.80472319  0.549936862 #>  [34,]  0.27195315  0.971885677 #>  [35,] -0.59972480 -0.389902569 #>  [36,] -1.55592123 -0.948105060 #>  [37,] -0.39385286 -0.280085604 #>  [38,] -1.12087954 -0.391763102 #>  [39,]  1.25698575 -0.188953877 #>  [40,] -0.01136385  0.384438885 #>  [41,] -1.17009648  0.369025848 #>  [42,]  1.62920200  0.656971580 #>  [43,] -0.51412770 -0.320057101 #>  [44,] -2.22229902  1.673256300 #>  [45,] -1.48699674  1.268315893 #>  [46,]  1.12619553 -1.653433004 #>  [47,]  0.17349536 -1.006982326 #>  [48,] -1.25774385 -0.890962103 #>  [49,] -0.64212986 -1.011236836 #>  [50,] -1.35736696  0.398847416 #>  [51,]  1.13742110 -0.078472453 #>  [52,]  0.05139381  0.886701723 #>  [53,]  0.33062103 -1.002996119 #>  [54,]  0.44116995 -0.784823762 #>  [55,]  0.35244538  0.324631055 #>  [56,]  0.70706873  0.299612232 #>  [57,]  0.68436188 -1.210781876 #>  [58,] -1.15860514  2.101469622 #>  [59,] -0.25347648  0.815921861 #>  [60,]  0.68745570 -0.005964677 #>  [61,]  0.02590503  0.246083243 #>  [62,] -0.04637627 -0.045042374 #>  [63,]  0.59568567  1.562904923 #>  [64,] -0.45633772 -0.593718728 #>  [65,] -0.22115052  0.444769819 #>  [66,] -0.26259563 -0.375306481 #>  [67,] -1.01410842  1.149819586 #>  [68,] -0.35747275 -0.329157192 #>  [69,] -0.20354839  0.141739167 #>  [70,]  0.41248466 -0.064779494 #>  [71,]  0.84761359  0.065686675 #>  [72,]  0.35799828 -0.374802188 #>  [73,]  0.40488563 -0.750182143 #>  [74,] -1.33754181  1.684072263 #>  [75,]  0.15009271 -0.068410240 #>  [76,] -0.81437248 -1.435180746 #>  [77,]  1.69648596  0.776044634 #>  [78,]  0.26896221  0.175707511 #>  [79,]  0.35362148  0.127658253 #>  [80,] -0.37286734 -0.463701928 #>  [81,]  0.97945371 -0.262326806 #>  [82,] -0.21886162 -0.327893141 #>  [83,]  1.78950474  0.120786512 #>  [84,] -0.59661544  0.524661302 #>  [85,] -0.06882649 -0.161662442 #>  [86,] -1.32609204 -1.274967367 #>  [87,] -1.03635755  0.947246201 #>  [88,]  0.92884943  0.159311594 #>  [89,] -0.15720891 -0.020625734 #>  [90,] -0.41962457 -0.329405759 #>  [91,]  0.92280620 -0.870835579 #>  [92,]  1.51821116 -0.423700676 #>  [93,]  0.36918410 -0.326766709 #>  [94,] -0.18481198 -1.162690239 #>  [95,] -0.06802760 -0.553582958 #>  [96,]  0.09457118 -0.903869599 #>  [97,] -0.74957548 -0.176414690 #>  [98,]  1.89028643 -1.196545275 #>  [99,]  0.42116926  0.235887216 #> [100,]  0.49989413 -0.953022199 #>"},{"path":"https://bfunovits.github.io/RLDM/reference/est_arma_hrk.html","id":null,"dir":"Reference","previous_headings":"","what":"Hannan, Rissanen, Kavalieris estimation procedure — est_arma_hrk","title":"Hannan, Rissanen, Kavalieris estimation procedure — est_arma_hrk","text":"Estimate (V)ARMA models Hannan, Rissanen Kavalieris procedure, see e.g. (Hannan Rissanen 1982)  (Hannan et al. 1986) .","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/est_arma_hrk.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hannan, Rissanen, Kavalieris estimation procedure — est_arma_hrk","text":"","code":"est_arma_hrk(   y,   e = NULL,   tmpl,   maxit = 1,   tol = 0.001,   trace = TRUE,   p.max = NULL,   ic = c(\"AIC\", \"BIC\", \"max\"),   mean_estimate = c(\"sample.mean\", \"intercept\", \"zero\") )"},{"path":"https://bfunovits.github.io/RLDM/reference/est_arma_hrk.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Hannan, Rissanen, Kavalieris estimation procedure — est_arma_hrk","text":"y sample, .e. \\((N,m)\\) dimensional matrix, \"time series\" object (.e. .matrix(y) return \\((N,m)\\)-dimensional numeric matrix). Missing values (NA, NaN Inf) supported. e (initial) estimate disturbances \\(u_t\\). non NULL e \\((N,m)\\) dimensional matrix, \"time series\" object (.e object may coerced \\((N,m)\\) dimensional matrix .matrix(e)).  NULL procedure computes estimate disturbances fitting \"long\" AR model data, see est_ar_ols().  matrix e may contain missing values (NA, NaN Inf). Note e.g. est_ar_ols returns residuals first \\(p\\) (\\(p\\) refers order fitted AR model) values missing. tmpl model template, see model structures(). Note case implemented, \\(a_0=b_0\\) holds, diagonal entries \\(a_0=b_0\\) equal one fixed elements equal zero. Furthermore square root sigma_L noise covariance matrix asssumed lower triangular matrix without restrictions.  given template coerced template kind. given template comply restrictions, warning message issued. maxit (integer) maximum number iterations tol (numeric) tolerance level trace (boolean) trace=TRUE, tracing information iterations printed. p.max (integer NULL) Maximum order candidate AR models. default choice see . ic (character string) information criterion shall used find optimal AR order. Note ic=\"max\" means AR(p) model p=p.max fitted. Default ic=\"AIC\". mean_estimate Character string giving method used estimate mean \\(\\mu\\). Default mean_estimate = \"sample.mean\". See details .","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/est_arma_hrk.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Hannan, Rissanen, Kavalieris estimation procedure — est_arma_hrk","text":"List components model estimated (V)ARMA model (.e. armamod() object). th vector (free) parameters estimated (V)ARMA model. tmpl (coerced) model template. y.mean estimate mean \\(\\mu\\). residuals residuals model, computed solve_inverse_de(). sigma sample variance \\(S\\) residuals, .e. estimate noise covariance matrix \\(\\Sigma\\). n.valid number \"valid\" observations, .e. observations needed lagged values \\(y_{t-}\\) \\(e_{t-}\\) availiable. ARMA(p,q) model implies number valid observations less equal n.obs -max(p,q). ll Gaussian log likelihood: $$(-1/2)(m \\ln(2\\pi) + m + \\ln\\det(S))$$ \\(S\\) denotes sample variance residuals. iter number iterations. converged (boolean) indicates whether algorithm converged.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/est_arma_hrk.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Hannan, Rissanen, Kavalieris estimation procedure — est_arma_hrk","text":"main idea HRK procedure follows. given estimates, \\(e_t\\) say, disturbances, ARMA model estimated equation $$y_t = -^*_0(y_t+e_t) - a_1 y_{t-1} - \\cdots - a_p y_{t-p} +                 b_1 e_{t-1} + \\cdots + b_q e_{t-q} + v_{t-1}$$ \\(^*_0\\) obtained \\(a_0 = b_0\\) setting diagonal elements equal zero. entries parameter matrices \\(a_i\\) \\(b_i\\) either treated fixed (equal zero) \"free\". Now regression estimated \"componentwise\", .e. component \\(y_t\\) corresponding \"free\" parameters estimated OLS. Given parameter estimates one computes new estimates disturbances, recursively solving ARMA system, see solve_inverse_de(). sample variance residuals used estimate noise covariance matrix \\(\\Sigma\\). procedure may iterated: use \"new\" estimates disturbances (re) estimate ARMA parameters (re) estimate disturbances, ... parameters maxit tol control iterative scheme. iterations stopped maxit iterations \"small\" change estimates. precise, th, th0 denote vector parameter estimates actual round previous round, procedure stops max(abs(th-th0)) <= tol. Note general guarantee iterative scheme converges estimates improved iterating. user may supply \"\" (initial) estimates e disturbances. parameter e missing (NULL) procedure est_arma_hrk computes estimates disturbances fitting \"long\" AR model data. end procedure simply calls est_ar_ols() respective paramaters p.max (controls maximum possible AR order), ic (controls information criterion used select order AR model) mean_estimate (tells est_ar_ols estimate mean \\(\\mu\\)). default maximum order p.max $$\\max(12, 10\\log_{10}(N), (N-1)/(m+1))$$ procedure supports three options estimation mean \\(\\mu = \\mathbf{E} y_t\\). mean_estimate=\"zero\" procedure sets (estimate ) mean equal zero. mean_estimate=\"sample.mean\" procedure simply uses sample mean y estimate. Third option mean_estimate=\"intercept\" uses intercept regression(s) computes estimate mean correspondingly. Note fails estimated AR polynomial unit root, .e. $$\\det \\hat{}(1) = 0.$$ guarantee HRK algorithm returns stable minimum phase ARMA model. particular, estimated model minimum phase recursive computation residuals often yields useless results correspondingly cholesky decomposition sample variance residuals (used estimate noise covariance matrix \\(\\Sigma\\)) fails. case procedure stops error message.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/est_arma_hrk.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Hannan, Rissanen, Kavalieris estimation procedure — est_arma_hrk","text":"Hannan EJ, Rissanen J (1982). “Recursive estimation mixed autoregressive-moving average order.” Biometrika, 69, 81–94. Hannan EJ, Kavalieris L, Mackisack M (1986). “Recursive Estimation Linear Systems.” Biometrika, 73(1), 119-133.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/est_arma_hrk.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hannan, Rissanen, Kavalieris estimation procedure — est_arma_hrk","text":"","code":"# in order to get reproducible results set.seed(4321)  # generate a random VARMA(p=2,q=1) model with m=2 outputs ##################### tmpl = tmpl_arma_pq(m = 2, n = 2, p = 2, q = 1) model = r_model(template = tmpl, bpoles = 1, bzeroes = 1, sd = 0.25) diag(model$sigma_L) = 1 # scale the diagonal entries of sigma_L print(model) #> ARMA model [2,2] with orders p = 2 and q = 1 #> AR polynomial a(z): #>      z^0 [,1]  [,2]    z^1 [,1]      [,2]    z^2 [,1]        [,2] #> [1,]        1     0 -0.10668935 0.1794017 -0.03208932 -0.07429186 #> [2,]        0     1 -0.05590295 0.2103614  0.40233680  0.04900116 #> MA polynomial b(z): #>      z^0 [,1]  [,2]   z^1 [,1]        [,2] #> [1,]        1     0  0.3101866 -0.01680908 #> [2,]        0     1 -0.1796745  0.08609177 #> Left square root of noise covariance Sigma: #>          u[1] u[2] #> u[1] 1.000000    0 #> u[2] 0.284866    1  # generate a sample with 200 observations data = sim(model, n.obs = 200, n.burn_in = 100)  # estimate model with HRK # note: we are cheating here and use the true disturbances! out = est_arma_hrk(data$y, data$u, tmpl) #> HRK estimation of ARMA model: m=2, n.obs=200, p=2, q=1 #> iter |th - th0|  n.val      MSE       ll  #>    1      0.977    198    1.958   -2.754   print(out$model) #> ARMA model [2,2] with orders p = 2 and q = 1 #> AR polynomial a(z): #>      z^0 [,1]  [,2]  z^1 [,1]        [,2]    z^2 [,1]        [,2] #> [1,]        1     0 0.4774058 0.231267694 -0.08031496 -0.05099365 #> [2,]        0     1 0.1309504 0.005178953  0.33292233  0.06794187 #> MA polynomial b(z): #>      z^0 [,1]  [,2]   z^1 [,1]        [,2] #> [1,]        1     0 0.86715882 -0.05585317 #> [2,]        0     1 0.06883826 -0.24833582 #> Left square root of noise covariance Sigma: #>           u[1]      u[2] #> u[1] 0.9772386 0.0000000 #> u[2] 0.3424949 0.9410523 # ll() returns the same logLik value. However, we have to demean the data all.equal(out$ll, ll(out$model, scale(data$y, center = out$y.mean, scale = FALSE),                      'conditional', skip = 2)) #> [1] TRUE  # estimate the model with HRK # use the residuals of a long AR model as estimates for the noise out = est_arma_hrk(data$y, e = NULL, tmpl,                    trace = TRUE, maxit = 10, mean_estimate = 'zero') #> HRK estimation of ARMA model: m=2, n.obs=200, p=2, q=1 #> initial AR estimate of noise p.max=11, p=2, ll=-2.711726 #> iter |th - th0|  n.val      MSE       ll  #>    1      0.939    197    1.865   -2.697   #>    2      0.140    198    1.856   -2.692   #>    3      0.060    198    1.856   -2.692   #>    4      0.018    198    1.856   -2.692   #>    5      0.007    198    1.856   -2.692   #>    6      0.002    198    1.856   -2.692   #>    7      0.002    198    1.856   -2.692   #>    8      0.000    198    1.856   -2.692   #> algorithm converged print(out$model) #> ARMA model [2,2] with orders p = 2 and q = 1 #> AR polynomial a(z): #>      z^0 [,1]  [,2]   z^1 [,1]       [,2]   z^2 [,1]        [,2] #> [1,]        1     0 0.20158389 0.13764630 0.05391753 -0.08392618 #> [2,]        0     1 0.06234842 0.09370431 0.37190127  0.05010730 #> MA polynomial b(z): #>      z^0 [,1]  [,2]     z^1 [,1]       [,2] #> [1,]        1     0  0.615023757 -0.1511000 #> [2,]        0     1 -0.001179974 -0.1500922 #> Left square root of noise covariance Sigma: #>           u[1]      u[2] #> u[1] 0.9230599 0.0000000 #> u[2] 0.3558209 0.9364313 # ll() returns the same logLik value. However, we have to demean the data all.equal(out$ll, ll(out$model, scale(data$y, center = out$y.mean, scale = FALSE),                      'conditional', skip = 2)) #> [1] TRUE  # Generate a random Model in echelon form model (m = 3) ####################### tmpl = tmpl_arma_echelon(nu = c(1,1,1)) model = r_model(template = tmpl, bpoles = 1, bzeroes = 1, sd = 0.25) diag(model$sigma_L) = 1 # scale the diagonal entries of sigma_L print(model) #> ARMA model [3,3] with orders p = 1 and q = 1 #> AR polynomial a(z): #>      z^0 [,1]  [,2]  [,3]   z^1 [,1]        [,2]       [,3] #> [1,]        1     0     0  0.5893418 -0.00553193 -0.2113619 #> [2,]        0     1     0  0.1842932  0.06201503  0.1328532 #> [3,]        0     0     1 -0.1422159  0.23607602  0.3943483 #> MA polynomial b(z): #>      z^0 [,1]  [,2]  [,3]    z^1 [,1]       [,2]      [,3] #> [1,]        1     0     0 -0.07942568 -0.1992309 0.5002033 #> [2,]        0     1     0 -0.29348965  0.1566674 0.1483497 #> [3,]        0     0     1 -0.14925189  0.4185160 0.3153198 #> Left square root of noise covariance Sigma: #>            u[1]      u[2] u[3] #> u[1]  1.0000000 0.0000000    0 #> u[2]  0.2661327 1.0000000    0 #> u[3] -0.4719906 0.1258785    1  # generate a sample with 200 observations data = sim(model, n.obs = 200, n.burn_in = 100) # add mean value(s) data$y = data$y + matrix(1:3, nrow = 200, ncol = 3, byrow = TRUE)  # estimate model with HRK # note: we are cheating here and use the true disturbances! out = est_arma_hrk(data$y, data$u, tmpl,                    trace = FALSE, maxit = 1, mean_estimate = 'sample.mean') print(out$y.mean) #> [1] 0.9511495 1.9436019 2.8487408 print(out$model) #> ARMA model [3,3] with orders p = 1 and q = 1 #> AR polynomial a(z): #>      z^0 [,1]  [,2]  [,3]   z^1 [,1]        [,2]         [,3] #> [1,]        1     0     0  0.6687489 -0.12600713 -0.154716557 #> [2,]        0     1     0  0.1944165 -0.04965131  0.057462781 #> [3,]        0     0     1 -0.3418481  0.50977514  0.007750021 #> MA polynomial b(z): #>      z^0 [,1]  [,2]  [,3]    z^1 [,1]        [,2]        [,3] #> [1,]        1     0     0  0.05047286 -0.31806802  0.52077685 #> [2,]        0     1     0 -0.21348959 -0.01193928  0.04368415 #> [3,]        0     0     1 -0.45130821  0.70739668 -0.11303414 #> Left square root of noise covariance Sigma: #>            u[1]       u[2]    u[3] #> u[1]  0.9644771 0.00000000 0.00000 #> u[2]  0.1932537 0.98300427 0.00000 #> u[3] -0.4325050 0.06192851 1.05045 # ll() returns the same logLik value. However, we have to demean the data all.equal(out$ll, ll(out$model, scale(data$y, center = out$y.mean, scale = FALSE),                      'conditional', skip = 1)) #> [1] TRUE  # estimate the model with HRK # use the residuals of a long AR model as estimates for the noise out = est_arma_hrk(data$y, e = NULL, tmpl,                    maxit = 10, mean_estimate = 'intercept') #> HRK estimation of ARMA model: m=3, n.obs=200, p=1, q=1 #> initial AR estimate of noise p.max=7, p=2, ll=-4.235502 #> iter |th - th0|  n.val      MSE       ll  #>    1      1.051    197    3.200   -4.235   #>    2      0.135    199    3.220   -4.249   #>    3      0.081    199    3.223   -4.251   #>    4      0.048    199    3.220   -4.250   #>    5      0.035    199    3.222   -4.251   #>    6      0.022    199    3.221   -4.250   #>    7      0.015    199    3.222   -4.250   #>    8      0.010    199    3.221   -4.250   #>    9      0.007    199    3.222   -4.250   #>   10      0.005    199    3.221   -4.250   print(out$y.mean) #> [1] 0.9537144 1.9386421 2.8536800 print(out$model) #> ARMA model [3,3] with orders p = 1 and q = 1 #> AR polynomial a(z): #>      z^0 [,1]  [,2]  [,3]   z^1 [,1]         [,2]       [,3] #> [1,]        1     0     0  0.6740053 -0.261126479 -0.3217273 #> [2,]        0     1     0  0.1479565  0.008074719 -0.1286455 #> [3,]        0     0     1 -0.2984776  0.523115301  0.1643308 #> MA polynomial b(z): #>      z^0 [,1]  [,2]  [,3]    z^1 [,1]        [,2]        [,3] #> [1,]        1     0     0  0.05225048 -0.45689436  0.35600140 #> [2,]        0     1     0 -0.25603151  0.04533693 -0.14860902 #> [3,]        0     0     1 -0.41217354  0.72060291  0.04411931 #> Left square root of noise covariance Sigma: #>            u[1]       u[2]     u[3] #> u[1]  0.9625622 0.00000000 0.000000 #> u[2]  0.1902924 0.98177314 0.000000 #> u[3] -0.4307534 0.06340989 1.051195 # ll() returns the same logLik value. However, we have to demean the data all.equal(out$ll, ll(out$model, scale(data$y, center = out$y.mean, scale = FALSE),                      'conditional', skip = 1)) #> [1] TRUE  # We may also use this procedure to estimate AR models ##################### # where some coefficients are fixed = 0 a = dbind(d = 3, diag(2), array(NA_real_, dim = c(2,2,2))) a[1,2,] = 0 # all coefficient matrices are lower triangular, i.e. # y[2t] does not Granger cause y[1t] tmpl = model2template(armamod(sys = lmfd(a=a),                               sigma_L = matrix(NA_real_, nrow = 2, ncol = 2)),                       sigma_L = 'chol') model = r_model(template = tmpl, bpoles = 1, bzeroes = 1, sd = 0.25) diag(model$sigma_L) = 1 # scale the diagonal entries of sigma_L print(model) #> ARMA model [2,2] with orders p = 2 and q = 0 #> AR polynomial a(z): #>      z^0 [,1]  [,2]   z^1 [,1]      [,2]    z^2 [,1]       [,2] #> [1,]        1     0 -0.1836216 0.0000000 -0.04334075 0.00000000 #> [2,]        0     1  0.2345054 0.2220447 -0.54760618 0.04449801 #> MA polynomial b(z): #>      z^0 [,1]  [,2] #> [1,]        1     0 #> [2,]        0     1 #> Left square root of noise covariance Sigma: #>             u[1] u[2] #> u[1]  1.00000000    0 #> u[2] -0.07017046    1  # generate a sample with 200 observations data = sim(model, n.obs = 200, n.burn_in = 100)  # estimate model with HRK out = est_arma_hrk(data$y, NULL, tmpl,                    trace = FALSE, maxit = 1, mean_estimate = 'zero') print(out$y.mean) #> [1] 0 0 print(out$model) #> ARMA model [2,2] with orders p = 2 and q = 0 #> AR polynomial a(z): #>      z^0 [,1]  [,2]   z^1 [,1]    [,2]    z^2 [,1]       [,2] #> [1,]        1     0 -0.1045799 0.00000 -0.04138278 0.00000000 #> [2,]        0     1  0.3202084 0.22883 -0.58485638 0.09887707 #> MA polynomial b(z): #>      z^0 [,1]  [,2] #> [1,]        1     0 #> [2,]        0     1 #> Left square root of noise covariance Sigma: #>             u[1]      u[2] #> u[1]  0.91829065 0.0000000 #> u[2] -0.04809834 0.9383795 # ll() returns the same logLik value. However, we have to demean the data all.equal(out$ll, ll(out$model, scale(data$y, center = out$y.mean, scale = FALSE),                      'conditional', skip = 2)) #> [1] TRUE  # reset the \"seed\" set.seed(NULL)"},{"path":"https://bfunovits.github.io/RLDM/reference/est_arma_hrk3.html","id":null,"dir":"Reference","previous_headings":"","what":"Different version of HRK Procedure — est_arma_hrk3","title":"Different version of HRK Procedure — est_arma_hrk3","text":"See est_arma_hrk. Stage III Hannan-Rissanen-Kavalieris procedure implemented well. function returns best model (since iterations might always improve log-likelihood value) allows returning results different stages HRK procedure.  One notable differences data needs demeaned use Yule-Walker estimation first stage ensure stability implementation stage III otherwise even cumbersome.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/est_arma_hrk3.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Different version of HRK Procedure — est_arma_hrk3","text":"","code":"est_arma_hrk3(   y,   tmpl,   maxit_stage2 = 5,   tol_stage2 = 0.001,   maxit_stage3 = 5,   tol_stage3 = 0.001,   info = TRUE,   trace = FALSE,   p.max = NULL,   ic = c(\"AIC\", \"BIC\", \"max\"),   mean_estimate = c(\"zero\", \"sample.mean\", \"intercept\"),   tol = sqrt(.Machine$double.eps) )"},{"path":"https://bfunovits.github.io/RLDM/reference/est_arma_hrk3.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Different version of HRK Procedure — est_arma_hrk3","text":"y sample, .e. \\((N,m)\\) dimensional matrix, \"time series\" object (.e. .matrix(y) return \\((N,m)\\)-dimensional numeric matrix). Missing values (NA, NaN Inf) supported. tmpl model template, see model structures(). Note case implemented, \\(a_0=b_0\\) holds, diagonal entries \\(a_0=b_0\\) equal one fixed elements equal zero. Furthermore square root sigma_L noise covariance matrix asssumed lower triangular matrix without restrictions.  given template coerced template kind. given template comply restrictions, warning message issued. maxit_stage2, maxit_stage3 Integers. Default stages 5. tol_stage2, tol_stage3 Default set 1e-3. Maximal absolute distance deep parameters adjacent iterations info Boolean. Indicates whether slot extra_info returned list contain tibble additional info model different iterations, e.g., min max absolute value zeros, poles, value objective function etc. trace (boolean) trace=TRUE, tracing information iterations printed. p.max (integer NULL) Maximum order candidate AR models. default choice see . ic (character string) information criterion shall used find optimal AR order. Note ic=\"max\" means AR(p) model p=p.max fitted. Default ic=\"AIC\". mean_estimate Character string giving method used estimate mean \\(\\mu\\). Default mean_estimate = \"sample.mean\". See details . tol Small tolerance, used check whether mean supplied data matrix indeed zero.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/est_arma_hrk3.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Different version of HRK Procedure — est_arma_hrk3","text":"See est_arma_hrk(). list contains additional slots stage_opt Since best stable miniphase model returned, also indicate whether happened stage II stage III. info_tibble Tibble containing relevant info outcome different stages iterations. contain slots y.mean (since mean required zero) converged.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/est_arma_hrk3.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Different version of HRK Procedure — est_arma_hrk3","text":"","code":"data = BQdata_xts set.seed(123) for (pp in 0:2){   for (qq in 0:2){     if (pp + qq == 0){next}     cat(paste0(\"p = \", pp, \" q = \", qq, \"\\n\"))     tmpl = tmpl_arma_pq(m = 2, n = 2,                         p = pp, q = qq)     ff = est_arma_hrk3(data, tmpl = tmpl)   } } #> p = 0 q = 1 #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> p = 0 q = 2 #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> p = 1 q = 0 #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> p = 1 q = 1 #> p = 1 q = 2 #> p = 2 q = 0 #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to max; returning -Inf #> p = 2 q = 1 #> p = 2 q = 2 ff$info_tibble %>% print(n=100) #> # A tibble: 21 × 10 #>    stage iteration flipped min_pole max_pole min_zero max_zero trace log_lik #>    <dbl>     <dbl> <lgl>      <dbl>    <dbl>    <dbl>    <dbl> <dbl>   <dbl> #>  1     1         1 FALSE       1.23     3.13   Inf      Inf    0.945  Inf    #>  2     2         1 FALSE       1.36     2.56     1.49     5.10 0.948   -1.33 #>  3     2         1 TRUE        1.36     2.56     1.49     5.10 0.948   -1.37 #>  4     2         2 FALSE       1.28     1.98     1.51     2.38 0.957   -1.34 #>  5     2         2 TRUE        1.28     1.98     1.51     2.38 0.957   -1.36 #>  6     2         3 FALSE       1.43    25.0      1.37     5.67 0.955   -1.34 #>  7     2         3 TRUE        1.43    25.0      1.37     5.67 0.955   -1.34 #>  8     2         4 FALSE       1.39     2.93     1.40     8.26 0.948   -1.33 #>  9     2         4 TRUE        1.39     2.93     1.40     8.26 0.948   -1.35 #> 10     2         5 FALSE       1.35     2.92     1.17     3.60 0.959   -1.34 #> 11     2         5 TRUE        1.35     2.92     1.17     3.60 0.959   -1.34 #> 12     3         1 FALSE       1.29     2.09     1.47     6.75 0.948   -1.34 #> 13     3         1 TRUE        1.29     2.09     1.47     6.75 0.963   -1.36 #> 14     3         2 FALSE       1.29     4.23     1.65     3.21 0.948   -1.34 #> 15     3         2 TRUE        1.29     4.23     1.65     3.21 0.958   -1.34 #> 16     3         3 FALSE       1.39     2.45     1.64     5.11 0.951   -1.34 #> 17     3         3 TRUE        1.39     2.45     1.64     5.11 0.958   -1.35 #> 18     3         4 FALSE       1.34     5.34     2.02     3.61 0.950   -1.34 #> 19     3         4 TRUE        1.34     5.34     2.02     3.61 0.952   -1.34 #> 20     3         5 FALSE       1.52     3.33     2.91     5.90 0.950   -1.34 #> 21     3         5 TRUE        1.52     3.33     2.91     5.90 0.952   -1.34 #> # ℹ 1 more variable: lndetSigma <dbl>"},{"path":"https://bfunovits.github.io/RLDM/reference/fevardec.html","id":null,"dir":"Reference","previous_headings":"","what":"Forecast Error Variance Decomposition — fevardec","title":"Forecast Error Variance Decomposition — fevardec","text":"Computes Forecast Errors Variance Decomposition given (orthogonalized) impulse response function.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/fevardec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Forecast Error Variance Decomposition — fevardec","text":"","code":"fevardec(obj, h.max = NULL, H = NULL)"},{"path":"https://bfunovits.github.io/RLDM/reference/fevardec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Forecast Error Variance Decomposition — fevardec","text":"obj impresp() object represents (orthogonalized) impulse response function. h.max maximum forecast horizon. default one plus number lags impresp object. H (n x n) (non singular) matrix renders impulse response orthogonalized impulse response. noise \\(u_t\\) transformed \\(H^{-1}u_t\\) impulse response coefficients (\\(k_j \\rightarrow k_j H\\)) (left) square root noise covariance matrix (\\(L \\rightarrow H^{-1}L\\)) transformed correspondingly.  default case H=NULL corresponds identity matrix (.e. transformation).  H='chol', transformation matrix H = t(chol(Sigma)) obtained Choleski decomposition noise covariance \\(\\Sigma\\). H='eigen' symmetric square root \\(\\Sigma\\) (obtained eigenvalue decomposition \\(\\Sigma\\)) used. H='sigma_L' left square root noise covariance, stored object obj, used. orthogonalization schemes may obtained setting \\(H\\) suitable square root \\(\\Sigma\\).  procedure checks whether transformation yields orthogonalized impulse response. , error thrown.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/fevardec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Forecast Error Variance Decomposition — fevardec","text":"fevardec object, .e. list components vd n--n--h.max array contains forecast error variance decomposition: vd[,j,h] percentage variance h-step ahead forecast error -th component due j-th orthogonalized shock. v n--h.max matrix contains forecast error variances: v[,h] variance h-step ahead forecast error -th component. names (m)-dimensional character vector label character string NULL","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/fevardec.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Forecast Error Variance Decomposition — fevardec","text":"","code":"model = stspmod(sys = stsp(A = c(0,0.2,1,-0.5), B = c(1,1,1,-1),                            C = c(1,0,0,1)),                 sigma_L = t(chol(matrix(c(4,2,2,3),nrow=2))),                 names = c('y1','y2'), label = 'test model') fevardec(impresp(model, lag.max=10), H = 'chol', h.max = 5) %>% print(digits = 2, format = 'iz|j') #> test model: Forecast error variance decompositon [2,2] maximum horizon = 5 #>        u[1] u[2] #> h=1 y1 1.00 0.00 #>     y2 0.33 0.67 #> h=2 y1 0.87 0.13 #>     y2 0.33 0.67 #> h=3 y1 0.78 0.22 #>     y2 0.29 0.71 #> h=4 y1 0.74 0.26 #>     y2 0.27 0.73 #> h=5 y1 0.72 0.28 #>     y2 0.26 0.74 fevardec(impresp(model, lag.max=4, H = 'eigen'))            %>% print(digits = 2, format = 'iz|j') #> test model: Forecast error variance decompositon [2,2] maximum horizon = 5 #>        u[1] u[2] #> h=1 y1 0.92 0.08 #>     y2 0.11 0.89 #> h=2 y1 0.66 0.34 #>     y2 0.36 0.64 #> h=3 y1 0.65 0.35 #>     y2 0.31 0.69 #> h=4 y1 0.62 0.38 #>     y2 0.30 0.70 #> h=5 y1 0.60 0.40 #>     y2 0.30 0.70"},{"path":"https://bfunovits.github.io/RLDM/reference/fill_template.html","id":null,"dir":"Reference","previous_headings":"","what":"Connect Deep Parameters with a Model — fill_template","title":"Connect Deep Parameters with a Model — fill_template","text":"fill_template fills given template, .e. essence affine mapping free parameters linear parameters model class specified template, given free (deep) parameters th returns model (e.g. armamod() stspmod()). procedure can used generate random models, see e.g. r_model(), M-estimates, .e. estimation procedures estimate obtained minimizing (maximizing) criterion (e.g. ML GMM estimation).  \"inverse function\" extract_theta extracts free/deep parameters linear parameters model, using information provided template. end procedure first constructs vector \\(\\pi\\) stacked (linear) model parameters determines deep parameters \\(\\theta\\) least squares solution equation system $$(\\pi - h) =  H\\theta$$ residuals non zero, model (exactly) fit model structure. threshold tol used decide whether model fits template . parameter on_error decides case \"significant\" misfit. \"ignore\" procedure ignores misfit, \"warn\" procedure issues warning, \"stop\" procedure stops appropriate error message.  many cases noise covariance explicitly parametrized, since \\(\\Sigma\\) estimated another route. may accomplished fixing sigma_L identity matrix, option sigma_L = \"identity\" tmpl_*** functions. order extract system parameters (e.g. AR MA parameters ARMA model) model sigma_L equal identity, one may use option ignore_sigma_L = TRUE. ignores possible mismatch sigma_L still checks whether system parameters accordance model structure.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/fill_template.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Connect Deep Parameters with a Model — fill_template","text":"","code":"fill_template(th, template)  extract_theta(   model,   template,   tol = sqrt(.Machine$double.eps),   on_error = c(\"ignore\", \"warn\", \"stop\"),   ignore_sigma_L = FALSE )"},{"path":"https://bfunovits.github.io/RLDM/reference/fill_template.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Connect Deep Parameters with a Model — fill_template","text":"th Vector containing free (deep) parameters. template template like listed model structures(), template explicitly specified user model2template(). Essentially, template affine mapping parametrised vector h matrix H connect free (deep) parameters linear parameters model. model model object, .e. armamod(), stspmod(), rmfdmod() object, deep parameters extracted. tol extract_theta, small double specifying tolerance acceptable distance linear parameters H times deep parameters. Default st sqrt(.Machine$double.eps). on_error extract_theta, character string possible choices ignore, warn, stop. Specifies happen distance linear parmameters H times deep parameters, larger specified tol. Default ignore ignore_sigma_L Boolean, default set FALSE. TRUE, linear free parameters pertaining left square root sigma_L error covariance matrix ignored. See also tmpl_sigma_L() model structures() detail.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/fill_template.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Connect Deep Parameters with a Model — fill_template","text":"fill_template returns model object, .e. armamod(), stspmod(), rmfdmod() object, according class template (given parameters th). function extract_theta returns vector free parameters given model template.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/fill_template.html","id":"connection-to-likelihood-estimation","dir":"Reference","previous_headings":"","what":"Connection to Likelihood Estimation","title":"Connect Deep Parameters with a Model — fill_template","text":"functions important likelihood estimation following instances functionality necessary. initial estimate given model (together template), one may use extract_theta extract deep parameters. vector initial free/deep parameter values needs supplied optimizer. optimized deep parameter values need filled model using structure provided template. done fill_template","code":""},{"path":[]},{"path":"https://bfunovits.github.io/RLDM/reference/fill_template.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Connect Deep Parameters with a Model — fill_template","text":"","code":"# Extract deep parameter from ARMA object with ARMA(p,q) template ########## (armamod_obj = test_armamod(dim = c(2,2), degree = c(3,1))) #> ARMA model [2,2] with orders p = 3 and q = 1 #> AR polynomial a(z): #>      z^0 [,1]  [,2]   z^1 [,1]       [,2]  z^2 [,1]      [,2]   z^3 [,1] #> [1,]        1     0  0.4609162 -0.6868529 1.2240818 0.4007715 -0.5558411 #> [2,]        0     1 -1.2650612 -0.4456620 0.3598138 0.1106827  1.7869131 #>            [,2] #> [1,]  0.4978505 #> [2,] -1.9666172 #> MA polynomial b(z): #>      z^0 [,1]  [,2]   z^1 [,1]       [,2] #> [1,]        1     0  0.7013559 -1.0678237 #> [2,]        0     1 -0.4727914 -0.2179749 #> Left square root of noise covariance Sigma: #>          u[1]     u[2] #> u[1] 1.564061 0.000000 #> u[2] 0.212037 1.703367 (tmpl_obj = tmpl_arma_pq(2, 2, 3, 1)) #> $h #>  [1] 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 #>  #> $H #>       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] #>  [1,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #>  [2,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #>  [3,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #>  [4,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #>  [5,]    1    0    0    0    0    0    0    0    0     0     0     0     0 #>  [6,]    0    1    0    0    0    0    0    0    0     0     0     0     0 #>  [7,]    0    0    1    0    0    0    0    0    0     0     0     0     0 #>  [8,]    0    0    0    1    0    0    0    0    0     0     0     0     0 #>  [9,]    0    0    0    0    1    0    0    0    0     0     0     0     0 #> [10,]    0    0    0    0    0    1    0    0    0     0     0     0     0 #> [11,]    0    0    0    0    0    0    1    0    0     0     0     0     0 #> [12,]    0    0    0    0    0    0    0    1    0     0     0     0     0 #> [13,]    0    0    0    0    0    0    0    0    1     0     0     0     0 #> [14,]    0    0    0    0    0    0    0    0    0     1     0     0     0 #> [15,]    0    0    0    0    0    0    0    0    0     0     1     0     0 #> [16,]    0    0    0    0    0    0    0    0    0     0     0     1     0 #> [17,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #> [18,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #> [19,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #> [20,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #> [21,]    0    0    0    0    0    0    0    0    0     0     0     0     1 #> [22,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #> [23,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #> [24,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #> [25,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #> [26,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #> [27,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #> [28,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #>       [,14] [,15] [,16] [,17] [,18] [,19] #>  [1,]     0     0     0     0     0     0 #>  [2,]     0     0     0     0     0     0 #>  [3,]     0     0     0     0     0     0 #>  [4,]     0     0     0     0     0     0 #>  [5,]     0     0     0     0     0     0 #>  [6,]     0     0     0     0     0     0 #>  [7,]     0     0     0     0     0     0 #>  [8,]     0     0     0     0     0     0 #>  [9,]     0     0     0     0     0     0 #> [10,]     0     0     0     0     0     0 #> [11,]     0     0     0     0     0     0 #> [12,]     0     0     0     0     0     0 #> [13,]     0     0     0     0     0     0 #> [14,]     0     0     0     0     0     0 #> [15,]     0     0     0     0     0     0 #> [16,]     0     0     0     0     0     0 #> [17,]     0     0     0     0     0     0 #> [18,]     0     0     0     0     0     0 #> [19,]     0     0     0     0     0     0 #> [20,]     0     0     0     0     0     0 #> [21,]     0     0     0     0     0     0 #> [22,]     1     0     0     0     0     0 #> [23,]     0     1     0     0     0     0 #> [24,]     0     0     1     0     0     0 #> [25,]     0     0     0     1     0     0 #> [26,]     0     0     0     0     1     0 #> [27,]     0     0     0     0     0     0 #> [28,]     0     0     0     0     0     1 #>  #> $class #> [1] \"armamod\" #>  #> $order #> [1] 2 2 3 1 #>  #> $n.par #> [1] 19 #>   extract_theta(armamod_obj, tmpl_obj) #>  [1]  0.4609162 -1.2650612 -0.6868529 -0.4456620  1.2240818  0.3598138 #>  [7]  0.4007715  0.1106827 -0.5558411  1.7869131  0.4978505 -1.9666172 #> [13]  0.7013559 -0.4727914 -1.0678237 -0.2179749  1.5640610  0.2120370 #> [19]  1.7033671   # Fill template with deep parameters ################# (tmpl_obj = tmpl_arma_echelon(nu = c(3,2))) #> $h #>  [1] 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 #>  #> $H #>       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] #>  [1,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #>  [2,]    1    0    0    0    0    0    0    0    0     0     0     0     0 #>  [3,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #>  [4,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #>  [5,]    0    1    0    0    0    0    0    0    0     0     0     0     0 #>  [6,]    0    0    1    0    0    0    0    0    0     0     0     0     0 #>  [7,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #>  [8,]    0    0    0    1    0    0    0    0    0     0     0     0     0 #>  [9,]    0    0    0    0    1    0    0    0    0     0     0     0     0 #> [10,]    0    0    0    0    0    1    0    0    0     0     0     0     0 #> [11,]    0    0    0    0    0    0    1    0    0     0     0     0     0 #> [12,]    0    0    0    0    0    0    0    1    0     0     0     0     0 #> [13,]    0    0    0    0    0    0    0    0    1     0     0     0     0 #> [14,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #> [15,]    0    0    0    0    0    0    0    0    0     1     0     0     0 #> [16,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #> [17,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #> [18,]    1    0    0    0    0    0    0    0    0     0     0     0     0 #> [19,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #> [20,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #> [21,]    0    0    0    0    0    0    0    0    0     0     1     0     0 #> [22,]    0    0    0    0    0    0    0    0    0     0     0     1     0 #> [23,]    0    0    0    0    0    0    0    0    0     0     0     0     1 #> [24,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #> [25,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #> [26,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #> [27,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #> [28,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #> [29,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #> [30,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #> [31,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #> [32,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #> [33,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #> [34,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #> [35,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #> [36,]    0    0    0    0    0    0    0    0    0     0     0     0     0 #>       [,14] [,15] [,16] [,17] [,18] [,19] [,20] [,21] [,22] [,23] #>  [1,]     0     0     0     0     0     0     0     0     0     0 #>  [2,]     0     0     0     0     0     0     0     0     0     0 #>  [3,]     0     0     0     0     0     0     0     0     0     0 #>  [4,]     0     0     0     0     0     0     0     0     0     0 #>  [5,]     0     0     0     0     0     0     0     0     0     0 #>  [6,]     0     0     0     0     0     0     0     0     0     0 #>  [7,]     0     0     0     0     0     0     0     0     0     0 #>  [8,]     0     0     0     0     0     0     0     0     0     0 #>  [9,]     0     0     0     0     0     0     0     0     0     0 #> [10,]     0     0     0     0     0     0     0     0     0     0 #> [11,]     0     0     0     0     0     0     0     0     0     0 #> [12,]     0     0     0     0     0     0     0     0     0     0 #> [13,]     0     0     0     0     0     0     0     0     0     0 #> [14,]     0     0     0     0     0     0     0     0     0     0 #> [15,]     0     0     0     0     0     0     0     0     0     0 #> [16,]     0     0     0     0     0     0     0     0     0     0 #> [17,]     0     0     0     0     0     0     0     0     0     0 #> [18,]     0     0     0     0     0     0     0     0     0     0 #> [19,]     0     0     0     0     0     0     0     0     0     0 #> [20,]     0     0     0     0     0     0     0     0     0     0 #> [21,]     0     0     0     0     0     0     0     0     0     0 #> [22,]     0     0     0     0     0     0     0     0     0     0 #> [23,]     0     0     0     0     0     0     0     0     0     0 #> [24,]     1     0     0     0     0     0     0     0     0     0 #> [25,]     0     1     0     0     0     0     0     0     0     0 #> [26,]     0     0     1     0     0     0     0     0     0     0 #> [27,]     0     0     0     1     0     0     0     0     0     0 #> [28,]     0     0     0     0     1     0     0     0     0     0 #> [29,]     0     0     0     0     0     1     0     0     0     0 #> [30,]     0     0     0     0     0     0     0     0     0     0 #> [31,]     0     0     0     0     0     0     1     0     0     0 #> [32,]     0     0     0     0     0     0     0     0     0     0 #> [33,]     0     0     0     0     0     0     0     1     0     0 #> [34,]     0     0     0     0     0     0     0     0     1     0 #> [35,]     0     0     0     0     0     0     0     0     0     0 #> [36,]     0     0     0     0     0     0     0     0     0     1 #>  #> $class #> [1] \"armamod\" #>  #> $order #> [1] 2 2 3 3 #>  #> $n.par #> [1] 23 #>  #> $nu #> [1] 3 2 #>  # Number of columns of matrix H in affine mapping = number of free parameters (n_par_deep = dim(tmpl_obj$H)[2]) #> [1] 23  fill_template(rnorm(n_par_deep), tmpl_obj) #> ARMA model [2,2] with orders p = 3 and q = 3 #> AR polynomial a(z): #>       z^0 [,1]  [,2]   z^1 [,1]      [,2]  z^2 [,1]      [,2]  z^3 [,1] #> [1,]  1.000000     0 -0.7288912  0.000000 0.8377870 -1.138137 0.4264642 #> [2,] -1.026004     1 -0.6250393 -1.686693 0.1533731  1.253815 0.0000000 #>            [,2] #> [1,] -0.2950715 #> [2,]  0.0000000 #> MA polynomial b(z): #>       z^0 [,1]  [,2]  z^1 [,1]      [,2]    z^2 [,1]       [,2]  z^3 [,1] #> [1,]  1.000000     0 0.8951257 0.8215811  0.55391765 -0.3059627 -0.694707 #> [2,] -1.026004     1 0.8781335 0.6886403 -0.06191171 -0.3804710  0.000000 #>            [,2] #> [1,] -0.2079173 #> [2,]  0.0000000 #> Left square root of noise covariance Sigma: #>           u[1]     u[2] #> u[1] -1.265396 0.000000 #> u[2]  2.168956 1.207962 # Basic example # Create a template tmpl <- tmpl_stsp_ar(m = 2, p = 1) # Generate a random model with this structure th0 <- rnorm(tmpl$n.par, sd = 0.1) model <- fill_template(th0, tmpl) # Extract the \"free\" parameters from the model result <- extract_theta(model, tmpl) result #> [1] -0.112310858 -0.040288484 -0.046665535  0.077996512 -0.008336907 #> [6]  0.025331851 -0.002854676"},{"path":"https://bfunovits.github.io/RLDM/reference/freqresp.html","id":null,"dir":"Reference","previous_headings":"","what":"Frequency Response Function — freqresp","title":"Frequency Response Function — freqresp","text":"Compute frequency response function (also called transfer function) associated VARMA state space model.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/freqresp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Frequency Response Function — freqresp","text":"","code":"freqresp(obj, n.f, ...)  # S3 method for class 'armamod' freqresp(obj, n.f = 128, ...)  # S3 method for class 'stspmod' freqresp(obj, n.f = 128, ...)  # S3 method for class 'impresp' freqresp(obj, n.f = 128, ...)"},{"path":"https://bfunovits.github.io/RLDM/reference/freqresp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Frequency Response Function — freqresp","text":"obj armamod(), stspmod() impresp() object. Note impulse response object result approximation \"true\" frequency response due finite number coefficients. n.f number frequencies. ... used.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/freqresp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Frequency Response Function — freqresp","text":"freqresp object, .e. list slots frr rationalmatrices::zvalues() object. sigma_L (n,n)-dimensional matrix contains left square root noise covariance matrix \\(\\Sigma\\). names (m)-dimensional character vector NULL. optional slot stores names components time series/process. label character string NULL.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/freqresp.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Frequency Response Function — freqresp","text":"frequency response function (transfer function) associated ARMA state space model $$ K(\\lambda) = \\sum_{j=0}^{\\infty} k_j e^{-\\lambda j} $$ \\((k_j \\,|\\, j\\geq 0)\\) impulse response model. See also impresp(). ARMA model frequency response equal $$ K(\\lambda) = (a_0 + a_1 e^{-\\lambda} + \\cdots + a_p e^{-\\lambda p})^{-1} (b_0 + b_1 e^{-\\lambda} + \\cdots + b_q e^{-\\lambda q}) $$ state space model $$ K(\\lambda) = C(e^{\\lambda}I_s - )^{-1}B+D $$ Note \\(K()\\) discrete-time Fourier transform (DTFT) impulse response. impulse response absolutely summable coefficents \\(k_j\\) may reconstructed frequency response via inverse DTFT $$ k_j = \\frac{1}{2\\pi} \\int_{-\\pi}^{\\pi} K(\\lambda) e^{\\lambda j} d\\lambda $$ S3 methods freqresp.* evaluate function grid angular frequencies \\(\\lambda_j = 2\\pi j/N\\), \\(j=0,\\ldots,N-1\\) store result (together sigma_L) freqresp object.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/freqresp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Frequency Response Function — freqresp","text":"","code":"set.seed(3451) # set seed in order to get reproducible results  ### generate random bivariate ARMA(1,1) model # \"bpoles = 1.1\" implies that the poles have moduli larger than 1.1 # and therefore the impulse response coefficients decay with a rate (1.1)^k arma_model = test_armamod(dim = c(2,2), degrees = c(1,1), bpoles = 1.1) # frequency response frr = freqresp(arma_model) # compute the frequency response via the impulse response irf = impresp(arma_model, lag.max = 100) frr1 = freqresp(irf) # since the impulse response quickly decays # the \"truncated\" frequency response should be close to the true frequency response all.equal(frr, frr1) #> [1] TRUE # create an equivalent state space model stsp_model = as.stspmod(arma_model) # of course the state space model has the same frequency response # as the original ARMA model frr1 = freqresp(stsp_model) all.equal(frr, frr1) #> [1] TRUE  # we can also reconstruct the impulse response from the # frequency response, provided the frequency grid is \"fine enough\" n.f = 2^6 frr = freqresp(arma_model, n.f = n.f) # compute the impulse response via the inverse DTFT K = unclass(frr$frr) k1 = Re(apply(K, MARGIN = c(1,2), FUN = fft, inverse = TRUE)) / n.f k1 = aperm(k1, c(2,3,1)) # impulse response irf = impresp(arma_model, lag.max = n.f-1) k = unclass(irf$irf) # compare all.equal(k, k1) #> [1] TRUE  set.seed(NULL) # reset seed # Create a simple model model <- stspmod(sys = test_stsp(dim = c(2,2), s = 2), sigma_L = diag(2))  # Compute impresp result <- impresp(model) result #> Orthogonalized impulse response [2,2] with 12 lags #>      lag=0 [,1]  [,2] lag=1 [,1]      [,2] lag=2 [,1]      [,2] lag=3 [,1] #> [1,]          1     0 2.31922561 0.9184289  3.2725996  1.334717  4.5180896 #> [2,]          0     1 0.05508214 0.1351102 -0.2140766 -0.145617 -0.1453791 #>             [,2] lag=4 [,1]       [,2] lag=5 [,1]       [,2] lag=6 [,1] #> [1,]  1.82274572  6.2889458  2.5476557  8.7268722  3.5297893 12.1239602 #> [2,] -0.02798134 -0.2813503 -0.1299755 -0.3492069 -0.1328716 -0.5067076 #>            [,2] lag=7 [,1]       [,2] lag=8 [,1]       [,2] lag=9 [,1] #> [1,]  4.9066852 16.8360492  6.8122169 23.3833901  9.4621904  32.474899 #> [2,] -0.2094463 -0.6923714 -0.2778591 -0.9675215 -0.3927085  -1.340614 #>            [,2] lag=10 [,1]       [,2] lag=11 [,1]      [,2] lag=12 [,1] #> [1,] 13.1406995   45.102258 18.2504701    62.63902 25.346547   86.994749 #> [2,] -0.5418424   -1.863502 -0.7543867    -2.58723 -1.046738   -3.593655 #>           [,2] #> [1,] 35.202022 #> [2,] -1.454245"},{"path":"https://bfunovits.github.io/RLDM/reference/impresp.html","id":null,"dir":"Reference","previous_headings":"","what":"Impulse Response Function — impresp","title":"Impulse Response Function — impresp","text":"Compute (orthogonalized) impulse response function VARMA model state space model. impulse response coefficients also called Power series parameters system.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/impresp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Impulse Response Function — impresp","text":"","code":"impresp(obj, lag.max, H)  # S3 method for class 'armamod' impresp(obj, lag.max = 12, H = NULL)  # S3 method for class 'rmfdmod' impresp(obj, lag.max = 12, H = NULL)  # S3 method for class 'stspmod' impresp(obj, lag.max = 12, H = NULL)  # S3 method for class 'impresp' impresp(obj, lag.max = NULL, H = NULL)"},{"path":"https://bfunovits.github.io/RLDM/reference/impresp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Impulse Response Function — impresp","text":"obj armamod(), stspmod() object impresp() object. last case may used transform impulse response function different orthogonalization scheme. lag.max Maximum lag impulse response coefficients. parameter ignored case obj impresp object. H (n x n) (non singular) matrix specifies transformation noise. noise \\(u_t\\) transformed \\(H^{-1}u_t\\) impulse response coefficients (\\(k_j \\rightarrow k_j H\\)) (left) square root noise covariance matrix (\\(L \\rightarrow H^{-1}L\\)) transformed correspondingly.  default case H=NULL corresponds identity matrix (.e. transformation).  H='chol', transformation matrix H = t(chol(Sigma)) determined Choleski decomposition noise covariance \\(\\Sigma\\). H='eigen' symmetric square root \\(\\Sigma\\) (obtained eigenvalue decomposition \\(\\Sigma\\)) used. H='sigma_L' left square root noise covariance, stored object obj, used. cases one obtains orthogonalized impulse response function. orthogonalization schemes may obtained setting \\(H\\) suitable square root \\(\\Sigma\\).","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/impresp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Impulse Response Function — impresp","text":"impresp object, .e. list components irf pseries object. sigma_L (n,n)-dimensional matrix contains left square noise covariance matrix. names (n)-dimensional character vector NULL label character string NULL","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/impresp.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Impulse Response Function — impresp","text":"impulse response coefficients \\((k_j \\,|\\, j \\geq 0)\\) define map noise output process. model stable stationary solution ARMA system, respectively state space system, given $$ y_t = \\sum_{j \\geq 0} k_j u_{t-j}. $$ state space system impulse response coefficients $$k_0 = D \\mbox{ }$$ $$k_j = CA^{j-1}B \\mbox{ }j >0.$$ ARMA model coefficients (recursively) computed comparison coefficients equation $$ (a_0 + a_1 z + \\cdots + a_p z^p)(k_0 + k_1 z + k_2 z^2 + \\cdots ) = b_0 + b_1 z + \\cdots + b_q z^q $$ S3 methods impresp.* compute coefficients \\(k_j\\) \\(j = 0,\\cdots,N\\) store result, together left square root (sigma_L) noise covariance \\(\\Sigma\\), impresp object. impresp objects contain complete information underlying model, provided maximum lag \\(N\\) large enough. means one may reconstruct underlying model impulse response object.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/impresp.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Impulse Response Function — impresp","text":"Lütkepohl H (2005). New Introduction Multiple Time Series Analysis. Springer Berlin.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/impresp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Impulse Response Function — impresp","text":"","code":"# IRF from state space model ################################################ model = stspmod(stsp(A = c(0,0.2,1,-0.5), B = c(1,1,1,-1),                      C = c(1,0,0,1)),                 sigma_L = matrix(c(4, 1, 1, 3), 2, 2),                 names = c('y1','y2'), label = 'test model')  # IRF irf = impresp(model, lag.max=10) irf #> test model: Impulse response [2,2] with 10 lags #>      lag=0 [,1]  [,2] lag=1 [,1]  [,2] lag=2 [,1]  [,2] lag=3 [,1]  [,2] #> [1,]          1     0          1     1        1.0  -1.0      -0.30  0.70 #> [2,]          0     1          1    -1       -0.3   0.7       0.35 -0.55 #>      lag=4 [,1]   [,2] lag=5 [,1]    [,2] lag=6 [,1]     [,2] lag=7 [,1] #> [1,]      0.350 -0.550    -0.2350  0.4150    0.18750 -0.31750  -0.140750 #> [2,]     -0.235  0.415     0.1875 -0.3175   -0.14075  0.24175   0.107875 #>           [,2] lag=8 [,1]       [,2]  lag=9 [,1]       [,2] lag=10 [,1] #> [1,]  0.241750  0.1078750 -0.1843750 -0.08208750  0.1405375  0.06261875 #> [2,] -0.184375 -0.0820875  0.1405375  0.06261875 -0.1071438 -0.04772688 #>             [,2] #> [1,] -0.10714375 #> [2,]  0.08167938  # Orthogonalized IRF: Cholesky irf_chol = impresp(model, lag.max = 10, H = 'chol') irf_chol #> test model: Impulse response [2,2] with 10 lags #>      lag=0 [,1]     [,2] lag=1 [,1]      [,2]  lag=2 [,1]      [,2]  lag=3 [,1] #> [1,]   4.123106 0.000000   5.820855  2.667892  2.42535625 -2.667892 -0.04850713 #> [2,]   1.697749 2.667892   2.425356 -2.667892 -0.04850713  1.867524  0.50932481 #>           [,2] lag=4 [,1]      [,2] lag=5 [,1]       [,2] lag=6 [,1]       [,2] #> [1,]  1.867524  0.5093248 -1.467341 -0.2643638  1.1071751  0.2340469 -0.8470557 #> [2,] -1.467341 -0.2643638  1.107175  0.2340469 -0.8470557 -0.1698962  0.6449629 #>      lag=7 [,1]       [,2]  lag=8 [,1]       [,2]  lag=9 [,1]       [,2] #> [1,] -0.1698962  0.6449629  0.13175748 -0.4918926 -0.09985798  0.3749389 #> [2,]  0.1317575 -0.4918926 -0.09985798  0.3749389  0.07628049 -0.2858479 #>      lag=10 [,1]       [,2] #> [1,]  0.07628049 -0.2858479 #> [2,] -0.05811184  0.2179117 print(irf_chol$sigma_L) # Sigma is (approximately equal to) the identity matrix #>            [,1]      [,2] #> [1,]  0.9701425 0.2425356 #> [2,] -0.2425356 0.9701425   # IRF from VARMA model ################################################ model = armamod(sys = test_lmfd(dim = c(2,2), degrees = c(2,1)))  irf = impresp(model) print(irf, digits = 2, format = 'iz|j') #> Orthogonalized impulse response [2,2] with 12 lags #>               [,1]   [,2] #>  lag=0 [1,]  -1.30  -0.66 #>        [2,]  -1.02   0.74 #>  lag=1 [1,]   0.89  -2.16 #>        [2,]  -0.47   0.01 #>  lag=2 [1,]  -1.30   0.43 #>        [2,]  -0.47  -0.82 #>  lag=3 [1,]   1.19  -1.13 #>        [2,]   0.83  -0.98 #>  lag=4 [1,]  -2.11   1.03 #>        [2,]  -1.34   0.88 #>  lag=5 [1,]   2.82  -2.18 #>        [2,]   1.47  -1.24 #>  lag=6 [1,]  -4.01   2.66 #>        [2,]  -2.11   1.26 #>  lag=7 [1,]   5.39  -3.82 #>        [2,]   2.90  -2.05 #>  lag=8 [1,]  -7.52   5.10 #>        [2,]  -4.10   2.78 #>  lag=9 [1,]  10.36  -7.18 #>        [2,]   5.61  -3.92 #> lag=10 [1,] -14.35   9.87 #>        [2,]  -7.76   5.32 #> lag=11 [1,]  19.81 -13.69 #>        [2,]  10.71  -7.40 #> lag=12 [1,] -27.39  18.87 #>        [2,] -14.82  10.20"},{"path":"https://bfunovits.github.io/RLDM/reference/innovation_form.html","id":null,"dir":"Reference","previous_headings":"","what":"Innovation Form state space Model — innovation_form","title":"Innovation Form state space Model — innovation_form","text":"Convert given state space model innovation form, .e. transformed model satisfies \\(D=\\) model stable minimum phase. procedure \"flips\" bad poles zeroes helper functions rationalmatrices::reflect_zeroes() rationalmatrices::reflect_poles(). transformed model equivalent description process terms second order moments. means spectral density changed.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/innovation_form.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Innovation Form state space Model — innovation_form","text":"","code":"innovation_form(model, echelon_form = TRUE, y = NULL)"},{"path":"https://bfunovits.github.io/RLDM/reference/innovation_form.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Innovation Form state space Model — innovation_form","text":"model state space model, .e. object type stspmod(). echelon_form boolean, TRUE innovation form model addition transformed echelon form. y NULL data sample. .matrix(y) return (N,m)-dimensional numeric matrix. NULL noise covariance matrix estimated sample.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/innovation_form.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Innovation Form state space Model — innovation_form","text":"List slots model state space model innovation form. z (complex) vector zeroes innovation form model. z_flipped (boolean) vector indicates zeroes flipped. p (complex) vector poles innovation form model. p_flipped (boolean) vector indicates poles flipped.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/innovation_form.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Innovation Form state space Model — innovation_form","text":"","code":"# in order to get reproducable results set.seed(342)  model = r_model(tmpl_stsp_full(3, 3, 5)) print(model, digits = 4) #> state space model [3,3] with s = 5 states #>         s[1]    s[2]    s[3]    s[4]    s[5]    u[1]    u[2]    u[3] #> s[1] -0.7701 -0.7534  0.4933 -1.2629  0.3608  0.0149  0.8278 -1.1295 #> s[2] -0.9100  2.2148 -0.4970 -2.2051 -1.0721 -0.9960  0.5980 -1.5275 #> s[3]  1.2751  0.9052 -0.7475 -0.5919 -1.6086 -1.1893  0.0486 -1.6221 #> s[4] -0.1740 -1.3902  1.4165  0.8076  0.5328 -0.9149 -0.2580 -0.4574 #> s[5]  0.5116 -0.0054 -0.6111  0.5597 -0.0738  0.0839 -0.3527 -0.6538 #> x[1]  0.1336  1.7917  0.5724  0.5907  0.1006  1.0000  0.0000  0.0000 #> x[2]  1.1534  1.2193  1.4340 -0.4257  0.6177  0.0000  1.0000  0.0000 #> x[3] -1.2113 -0.5287 -1.2432 -0.8186  0.8428  0.0000  0.0000  1.0000 #> Left square root of noise covariance Sigma: #>            u[1]      u[2]     u[3] #> u[1]  0.6968024 0.0000000 0.000000 #> u[2] -0.3246241 0.1801707 0.000000 #> u[3]  0.9493687 0.6805352 1.089781 # the model has two non-minimum phase zeroes and two non-stable poles. z = zeroes(model, print_message = FALSE) abs(z) #> [1] 0.2430920 0.3822571 1.4472231 1.4472231 1.7947154 p = poles(model, print_message = FALSE) abs(p) #> [1] 0.3184163 0.3801766 1.1047541 1.1047541 7.2894009  # convert to innnovation form, by flipping the \"bad\" poles and zeroes. out = innovation_form(model) print(out$model, digits = 4) #> state space model [3,3] with s = 5 states #>         s[1]    s[2]    s[3]    s[4]    s[5]     u[1]     u[2]    u[3] #> s[1]  0.0000  0.0000  0.0000  1.0000  0.0000  -2.1013   0.4187 -3.8366 #> s[2]  0.0000  0.0000  0.0000  0.0000  1.0000  -4.0003  -1.8191 -5.5912 #> s[3]  0.8764 -0.0799  1.0267  0.0449 -0.4833   6.2841   4.3642  4.3778 #> s[4] -1.0675 -0.1793 -2.2047 -2.5517  1.3806 -16.2235 -18.8212 -3.6213 #> s[5] -0.7212 -0.4139 -2.5557 -4.6404  2.3841 -17.7956 -23.0643 -1.8357 #> x[1]  1.0000  0.0000  0.0000  0.0000  0.0000   1.0000   0.0000  0.0000 #> x[2]  0.0000  1.0000  0.0000  0.0000  0.0000   0.0000   1.0000  0.0000 #> x[3]  0.0000  0.0000  1.0000  0.0000  0.0000   0.0000   0.0000  1.0000 #> Left square root of noise covariance Sigma: #>             u[1]       u[2]     u[3] #> u[1]  0.52953545  0.0000000 0.000000 #> u[2] -0.31786378  0.3060925 0.000000 #> u[3]  0.06273688 -1.0192496 1.099613 flip = function(x) {   x[abs(x) < 1] = 1/x[abs(x) < 1]   return(x)} data.frame(poles.inno = out$p, flipped = out$p_flipped,            poles.ori = p[match_vectors(out$p, p)],            zeroes.inno = out$z, flipped = out$z_flipped,            zeroes.ori = z[match_vectors(out$z, flip(z))]) #>              poles.inno flipped             poles.ori          zeroes.inno #> 1  0.6456403-0.8964543i   FALSE  0.6456403-0.8964543i -1.7947154+0.000000i #> 2  0.6456403+0.8964543i   FALSE  0.6456403+0.8964543i  0.8583822-1.165176i #> 3 -7.2894009+0.0000000i   FALSE -7.2894009+0.0000000i  0.8583822+1.165176i #> 4  3.1405429+0.0000000i    TRUE  0.3184163+0.0000000i -4.1136687+0.000000i #> 5 -2.6303566+0.0000000i    TRUE -0.3801766+0.0000000i  2.6160404+0.000000i #>   flipped.1           zeroes.ori #> 1     FALSE -1.7947154+0.000000i #> 2     FALSE  0.8583822-1.165176i #> 3     FALSE  0.8583822+1.165176i #> 4      TRUE -0.2430920+0.000000i #> 5      TRUE  0.3822571+0.000000i  # check that the innovation form model describes the same process, # by checking that the spectral density is not changed! junk = spectrald(model, n.f = 128) junk1 = spectrald(out$model, n.f = 128) all.equal(junk, junk1) #> [1] TRUE  # reset seed set.seed(NULL)"},{"path":"https://bfunovits.github.io/RLDM/reference/is.template.html","id":null,"dir":"Reference","previous_headings":"","what":"Check templates — is.template","title":"Check templates — is.template","text":"Check templates","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/is.template.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check templates — is.template","text":"","code":"is.template(tmpl, class = c(\"any\", \"stspmod\", \"armamod\", \"rmfdmod\"))"},{"path":"https://bfunovits.github.io/RLDM/reference/is.template.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check templates — is.template","text":"tmpl object tested class test specific class","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/is.template.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check templates — is.template","text":"TRUE/FALSE","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/is.template.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check templates — is.template","text":"","code":"is.template(1) #> [1] FALSE is.template(tmpl_llm(), 'armamod') #> [1] FALSE is.template(tmpl_llm(), 'stspmod') #> [1] TRUE"},{"path":"https://bfunovits.github.io/RLDM/reference/kf.html","id":null,"dir":"Reference","previous_headings":"","what":"Kalman Filter — kf","title":"Kalman Filter — kf","text":"functions implement \"standard\" Kalman filter \"square root\" Kalman filter (also called \"square root covariance filter\") time invariant, linear state space systems without exogenous inputs, see e.g. (Anderson Moore 2005) .","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/kf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Kalman Filter — kf","text":"","code":"kf(model, y, method = c(\"kf\", \"kf2\"), P1 = NULL, a1 = NULL)"},{"path":"https://bfunovits.github.io/RLDM/reference/kf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Kalman Filter — kf","text":"model stspmod() object, represents state space model. y sample, .e. \\((N,m)\\) dimensional matrix, \"time series\" object (.e. .matrix(y) return \\((N,m)\\)-dimensional numeric matrix). Missing values (NA, NaN Inf) supported. method Character string. method=\"kf\" standard form Kalman filter used, method=\"kf2\" square root form used. numerical errors outputs depend chosen method. P1 \\((s,s)\\) dimensional covariance matrix error initial state estimate, .e. \\(\\Pi_{1|0}\\). NULL, state covariance \\(P = APA'+B\\Sigma B'\\) used. Note scheme assumes state space model stable, .e. state transition matrix \\(\\) stable. a1 \\(s\\) dimensional vector, holds initial estimate \\(a_{1|0}\\) state time \\(t=1\\).  a1=NULL, zero vector used.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/kf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Kalman Filter — kf","text":"List components e \\((N,m)\\) dimensional matrix standardized one-step ahead prediction errors. \\(t\\)-th row matrix e corresponds $$e_t = \\Sigma_{t|t-1}^{-1/2}\\epsilon_{t|t-1}.$$ model correctly specified standardized residuals white noise unit covariance matrix. may used validaton model. \\((N+1,s)\\) dimensional matrix estimated states. \\(t\\)-th row matrix corresponds \\(a_{t|t-1}\\). Given y , one step ahead predictions \\(y_{t|t-1}\\) may computed yh = \\%*\\% t(C). ll (scaled) Gaussian log likelihood model $$-\\frac{1}{2N}\\sum_{t=1}^{N}\\left(m\\log(2\\pi) + \\log\\det\\Sigma_{t|t-1} +           (y_t - y_{t|t-1})' \\Sigma_{t|t-1}^{-1} (y_t - y_{t|t-1}) \\right).$$ P1 \\((s,s)\\) dimensional covariance matrix error state prediction \\(a_{N+1|N}\\), .e. matrix corresponds \\(\\Pi_{N+1|N}\\).","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/kf.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Kalman Filter — kf","text":"model considered $$a_{t+1} = a_t + Bu_t$$ $$y_t = C a_t + Du_t$$ \\(m\\)-dimensional outputs \\(y_t\\), \\(s\\)-dimensional states \\(a_t\\) \\(n\\)-dimensional disturbances \\(u_t\\). disturbances white noise covariance matrix \\(\\mathbf{E} u_tu_t'=\\Sigma\\). Note disturbances outputs may different dimensions, however, \"wide\" systems (\\(m\\leq n\\)) implemented. Kalman filter recursive scheme compute linear, least squares predictions \\(a_{t+1}\\) \\(y_{t+1}\\) given observations \\(y_t,\\ldots,y_1\\) time \\(t\\). predictions notated \\(a_{t+1|t}\\) \\(y_{t+1|t}\\), prediction error output \\(y_{t+1}\\) \\(\\epsilon_{t+1|t}=(y_{t+1}-y_{t+1|t})\\) corresponding variances prediction errors $$\\Pi_{t+1|t}=\\mathbf{E}(a_{t+1}-a_{t+1|t}) (a_{t+1}-a_{t+1|t})',$$ $$\\Sigma_{t+1|t}=\\mathbf{E}(\\epsilon_{t+1|t} \\epsilon_{t+1|t}').$$ standard form Kalman filter based parameter matrices \\(,C\\), variance \"state disturbances\" \\(Q=\\mathbf{E}(Bu_t (Bu_t)')=(B\\Sigma B')\\), variance \"measurement disturbances\" \\(R=\\mathbf{E}(Du_t (Du_t)')=(D\\Sigma D')\\) covariance \\(S=\\mathbf{E}(Bu_t(Du_t)')=(B\\Sigma D')\\). Furthermore need initial prediction \\(a_{1|0}\\) corresponding error variance \\(\\Pi_{1|0}\\). square root form filter need \"square roots\" \\(\\Pi_{1|0}^{1/2}\\) \\(\\Sigma^{1/2}\\), .e. matrices \\(\\Pi_{1|0} = \\Pi_{1|0}^{1/2} (\\Pi_{1|0}^{1/2})'\\) \\(\\Sigma = \\Sigma^{1/2}(\\Sigma^{1/2})'\\). addition, define \\(H=(D',B')'\\Sigma^{1/2}\\). Kalman filter implemented C++ via RcppArmadillo performance. wrapper function kf takes stspmod() object, describes state space model, calls appropriate internal implementation. Square root Kalman filter: square root \\(\\Pi_{1|0}^{1/2}\\) procedure first tries Cholesky decomposition. fails (since \\(\\Pi_{1|0}^{1/2}\\) (close ) singular), ll_kf tries compute symmetric square root via eigenvalue decomposition \\(\\Pi_{1|0}^{1/2}\\).","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/kf.html","id":"notes","dir":"Reference","previous_headings":"","what":"Notes","title":"Kalman Filter — kf","text":"internal C++ implementations check input parameters, direct use (via .Call()) must done care. procedures accept \"wide\" state space systems (\\(m \\leq n\\)), since \"tall\" systems (\\(m > n\\)) variance prediction errors (\\(\\Sigma_{t+1|t}\\)) singular \\(t\\) larger threshold. now, support models exogenous inputs.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/kf.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Kalman Filter — kf","text":"Anderson BDO, Moore JB (2005). Optimal filtering. Dover Publications Inc., London. Originally published: Englewood Cliffs, Prentice-Hall 1979.","code":""},{"path":[]},{"path":"https://bfunovits.github.io/RLDM/reference/kf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Kalman Filter — kf","text":"","code":"s = 4  # state dimension m = 2  # number of outputs n = 3  # number of inputs, n.obs = 100 # sample size  # generate a (stable) state space model tmpl = tmpl_stsp_full(m, n, s, sigma_L = \"chol\") model = r_model(tmpl, bpoles = 1, sd = 0.5) # generate a sample data = sim(model, n.obs = n.obs, a1 = NA)  # compute Q, R, S and P1 sigma_L = model$sigma_L sigma = tcrossprod(sigma_L) R = model$sys$D %*% sigma %*% t(model$sys$D) S = model$sys$B %*% sigma %*% t(model$sys$D) Q = model$sys$B %*% sigma %*% t(model$sys$B) P1 = lyapunov(model$sys$A, Q)  # call Kalman filter using the wrapper function out = kf(model, data$y, method = 'kf') # Note: kf_cpp is the internal C++ implementation called by kf()  # compute H and square root of P1 H = rbind(model$sys$D, model$sys$B) %*% sigma_L P1_R = chol(P1)  # call square root Kalman filter using wrapper function out_test = kf(model, data$y, method = 'kf2')  # using wrapper function all.equal(out, out_test) #> [1] TRUE  # The one step ahead predictions for y[t] may be computed by yh = out$a %*% t(model$sys$C) # and the (non scaled) prediction errors are uh = data$y - out$a[1:n.obs,] %*% t(model$sys$C)"},{"path":"https://bfunovits.github.io/RLDM/reference/ll.html","id":null,"dir":"Reference","previous_headings":"","what":"Log Likelihood Methods — ll","title":"Log Likelihood Methods — ll","text":"Tools methods computation (conditional exact) Gaussian log-likelihood ARMA, RMFD, state space models. functions serve input optimizers like optim, see ll_theta ll_FUN (latter function factory generates closure serves input).","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/ll.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Log Likelihood Methods — ll","text":"","code":"ll(obj, y, which, ...)  # S3 method for class 'armamod' ll(obj, y, which = c(\"concentrated\", \"conditional\"), skip = 0L, ...)  # S3 method for class 'stspmod' ll(   obj,   y,   which = c(\"concentrated\", \"conditional\", \"kf\", \"kf2\"),   skip = 0L,   P1 = NULL,   a1 = NULL,   tol = 1e-08,   ... )"},{"path":"https://bfunovits.github.io/RLDM/reference/ll.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Log Likelihood Methods — ll","text":"obj Object type armamod(), rmfdmod(), stspmod(). y Data sample given \\((N,m)\\) dimensional matrix, \"time series\" object (sense .matrix(y) return \\((N,m)\\)-dimensional numeric matrix). Missing values (NA, NaN Inf) supported. (character) likelihood compute. ... used. skip (integer) skip initial observations. parameter used, (concentrated) conditional likelihood computed. P1 \\((s,s)\\) dimensional covariance matrix error initial state estimate. NULL state covariance \\(P=APA'+B\\Sigma B'\\) used. parameter used, (exact) likelihood computed via Kalman Filter. See ll_kf() details. a1 \\(s\\) dimensional vector, holds initial estimate state time t=1. a1=NULL, zero vector used. parameter used, (exact) likelihood computed via Kalman Filter. See ll_kf() details. tol (small) tolerance value (zero) used Kalman Filter routines, see ll_kf().","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/ll.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Log Likelihood Methods — ll","text":"(double) (scaled) log Likelihood model.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/ll.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Log Likelihood Methods — ll","text":"procedure three choices ... ARMA model $$a_0 y_t + a_1 y_{t-1} + \\cdots + a_p y_{t-p} = b_0 u_t + b_1 u_{t-1} + \\cdots + b_q u_{t-q}$$ Gaussian noise \\(u_t \\sim N(0,\\Sigma)\\) approximation scaled log likelihood $$ll = -(1/2)(m \\ln(2\\pi) + \\mathrm{tr}(S\\Sigma^{-1}) + \\ln\\det \\Sigma + 2 \\ln\\det (a_0^{-1}b_0)$$ \\(S\\) denotes sample covariance residuals model $$S=\\frac{1}{N-s}\\sum_{t=s+1}^N e_t e_t'$$ residuals computed sample \\(y_t, t=1,\\ldots,N\\) solving (inverse) ARMA system $$b_0 e_t = -b_1 e_{t-1} - \\cdots - b_q e_{t-q} + a_0 y_t + a_1 y_{t-1} + \\cdots + a_p y_{t-p}$$ setting unknown initial values \\(y_t=0\\) \\(e_t=0\\) \\(t\\leq 0\\) equal zero. See e.g. solve_inverse_de(). Note log Likelihood scaled factor \\(1/(N-s)\\) first \\(s\\) observations skipped computing sample covariance matrix. log-likelihood may easily maximized respect noise covariance matrix \\(\\Sigma\\). given \\(S\\), optimal value \\(\\Sigma\\) \\(\\Sigma=S\\). plug maximizer log-likelihood function, obtain \"concentrated\" log likelihood function $$cll = -(1/2)(m \\ln(2\\pi) + m + \\ln\\det S + 2 \\ln\\det (a_0^{-1}b_0)$$ depends sample y ARMA parameter matrices \\(a_i\\) \\(b_i\\). state space models (approximate) log likelihood computed quite analogously.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/ll.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Log Likelihood Methods — ll","text":"precise, functions returns \\(1/(N-s)\\) times (approximate) log likelihood. routines handle case centered data, .e. assumed output process \\((y_t)\\) mean zero! computation concentrated log likelihood assumes model structure impose restrictions noise covariance matrix.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/ll.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Log Likelihood Methods — ll","text":"","code":"# Generate a random model in echelon form model (m = 3) tmpl = tmpl_arma_echelon(nu = c(2,1,1)) model = r_model(template = tmpl, bpoles = 1, bzeroes = 1, sd = 0.25) diag(model$sigma_L) = 1 # scale the diagonal entries of sigma_L print(model) #> ARMA model [3,3] with orders p = 2 and q = 2 #> AR polynomial a(z): #>        z^0 [,1]  [,2]  [,3]      z^1 [,1]        [,2]      [,3]  z^2 [,1] #> [1,]  1.0000000     0     0  2.809781e-02  0.00000000 0.0000000 0.2368095 #> [2,] -0.2058122     1     0 -1.232828e-05  0.16012134 0.5148543 0.0000000 #> [3,]  0.2400545     0     1 -3.648832e-01 -0.07255202 0.3213886 0.0000000 #>            [,2]       [,3] #> [1,] 0.01506865 0.03627626 #> [2,] 0.00000000 0.00000000 #> [3,] 0.00000000 0.00000000 #> MA polynomial b(z): #>        z^0 [,1]  [,2]  [,3]    z^1 [,1]        [,2]        [,3]    z^2 [,1] #> [1,]  1.0000000     0     0  0.51059413  0.12726313 -0.48815420 -0.02162068 #> [2,] -0.2058122     1     0 -0.03275172  0.28332514 -0.03178791  0.00000000 #> [3,]  0.2400545     0     1  0.26679625 -0.03455263 -0.07685430  0.00000000 #>             [,2]       [,3] #> [1,] -0.05334791 -0.1318354 #> [2,]  0.00000000  0.0000000 #> [3,]  0.00000000  0.0000000 #> Left square root of noise covariance Sigma: #>           u[1]       u[2] u[3] #> u[1] 1.0000000 0.00000000    0 #> u[2] 0.2116848 1.00000000    0 #> u[3] 0.1853631 0.07356894    1 # extract the corresponding free/deep parameters th = extract_theta(model, tmpl)  # generate a sample with 50 observations y = sim(model, n.obs = 50, n.burn_in = 100)$y  # conditional log likelihood # the following statements return the same ll value! ll(model, y, which = 'conditional', skip = 0) #> [1] -4.492098 ll_theta(th, template= tmpl, y, which = 'conditional', skip = 0) #> [1] -4.492098 llfun = ll_FUN(tmpl, y, which = 'conditional', skip = 0) llfun(th) #> [1] -4.492098  # concentrated, conditional log likelihood # the following statements return the same ll value! ll(model, y, which = 'concentrated', skip = 0) #> [1] -4.399176 ll_theta(th, template= tmpl, y, which = 'concentrated', skip = 0) #> [1] -4.399176 llfun = ll_FUN(tmpl, y, which = 'concentrated', skip = 0) llfun(th) #> [1] -4.399176"},{"path":"https://bfunovits.github.io/RLDM/reference/ll_FUN.html","id":null,"dir":"Reference","previous_headings":"","what":"Log Likelihood Function Factory — ll_FUN","title":"Log Likelihood Function Factory — ll_FUN","text":"Creates function similar ll_theta() faster memory efficient. model structure (template) data (y) encoded within generated closure (function plus enclosing environment). generated function calls compiled C/C++ code (see RcppArmadillo-package) hence much faster calling ll_theta(th, template, y, ...).","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/ll_FUN.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Log Likelihood Function Factory — ll_FUN","text":"","code":"ll_FUN(   template,   y,   which = c(\"concentrated\", \"conditional\", \"kf\", \"gr_concentrated\"),   skip = 0L,   tol = 1e-08,   err = NA_real_ )"},{"path":"https://bfunovits.github.io/RLDM/reference/ll_FUN.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Log Likelihood Function Factory — ll_FUN","text":"template model template, see model structures. y sample, .e. \\((N,m)\\) dimensional matrix, \"time series\" object (.e. .matrix(y) return \\((N,m)\\)-dimensional numeric matrix). Missing values (NA, NaN Inf) supported. (string) Determines type ll function. skip (integer) skip initial observations. NULL skip set \\(0\\) state space models \\(\\max(p,q)\\) ARMA models. parameter used cases \"concentrated\", \"conditional\" \"gr_concentrated\" tol (double) tolerance used ll_kf(). err (double) return value case \"kf\", computation initial state covariance fails.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/ll_FUN.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Log Likelihood Function Factory — ll_FUN","text":"function, llfun(th) say, computes log-likelihood given deep parameters th. function may used ML estimation model. Function fn(th)","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/ll_FUN.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Log Likelihood Function Factory — ll_FUN","text":"","code":"# Generate a random model in echelon form model (m = 3) tmpl = tmpl_stsp_echelon(nu = c(2,1,1)) model = r_model(template = tmpl, bpoles = 1, bzeroes = 1, sd = 0.25) diag(model$sigma_L) = 1 # scale the diagonal entries of sigma_L print(model) #> state space model [3,3] with s = 4 states #>            s[1]        s[2]       s[3]        s[4]        u[1]        u[2] #> s[1]  0.0000000  0.00000000  0.0000000  1.00000000 -0.17320930  0.09682150 #> s[2] -0.3306545  0.01350771 -0.1972378 -0.03578361  0.04348014 -0.41792942 #> s[3] -0.3057982 -0.05233582 -0.2495277  0.09318245 -0.08048530 -0.41472250 #> s[4] -0.1700720 -0.02146930  0.3660467 -0.24492897  0.06221162 -0.03184861 #> x[1]  1.0000000  0.00000000  0.0000000  0.00000000  1.00000000  0.00000000 #> x[2]  0.0000000  1.00000000  0.0000000  0.00000000  0.00000000  1.00000000 #> x[3]  0.0000000  0.00000000  1.0000000  0.00000000  0.00000000  0.00000000 #>            u[3] #> s[1]  0.2189791 #> s[2] -0.1172880 #> s[3] -0.1764870 #> s[4]  0.2875431 #> x[1]  0.0000000 #> x[2]  0.0000000 #> x[3]  1.0000000 #> Left square root of noise covariance Sigma: #>            u[1]       u[2] u[3] #> u[1]  1.0000000  0.0000000    0 #> u[2] -0.1510780  1.0000000    0 #> u[3]  0.1920143 -0.1237398    1 # extract the corresponding free/deep parameters th = extract_theta(model, tmpl)  # generate a sample with 50 observations y = sim(model, n.obs = 50)$y  # conditional log likelihood # the following statements return the same ll value! ll(model, y, 'conditional') #> [1] -4.115462 ll_theta(th, tmpl, y, 'conditional') #> [1] -4.115462 fn = ll_FUN(tmpl, y, 'conditional') fn(th) #> [1] -4.115462  # concentrated conditional log likelihood # the following statements return the same ll value! ll(model, y, 'concentrated') #> [1] -4.05168 ll_theta(th, tmpl, y, 'concentrated') #> [1] -4.05168 fn = ll_FUN(tmpl, y, 'concentrated') fn(th) #> [1] -4.05168 # for this case, we may also compute the (analytic) gradient gr = ll_FUN(tmpl, y, 'gr_concentrated') gr(th) #>  [1] -0.035510378  0.034818042 -0.084387036 -0.055252781 -0.168681470 #>  [6]  0.090886282 -0.107272572 -0.106298495  0.097460089  0.009128784 #> [11] -0.104673766  0.006148398  0.361105630  0.433500029 -0.145044069 #> [16] -0.071968044 -0.008647779  0.221878944 -0.295283813  0.051167458 #> [21] -0.020214612 -0.053694750 -0.001739417 -0.014929199  0.000000000 #> [26]  0.000000000  0.000000000  0.000000000  0.000000000  0.000000000  # log likelihood (via Kalman filter) # the following statements return the same ll value! ll(model, y, 'kf2') #> [1] -4.124856 ll_theta(th, tmpl, y, 'kf2') #> [1] -4.124856 ll(model, y, 'kf') #> [1] -4.124856 ll_theta(th, tmpl, y, 'kf') #> [1] -4.124856 fn = ll_FUN(tmpl, y, 'kf') fn(th) #> [1] -4.124856"},{"path":"https://bfunovits.github.io/RLDM/reference/ll_kf.html","id":null,"dir":"Reference","previous_headings":"","what":"Gaussian log Likelihood of a State Space Model — ll_kf","title":"Gaussian log Likelihood of a State Space Model — ll_kf","text":"routines compute log Likelihood time invariant, linear state space models form $$a_{t+1} = a_t + Bu_t$$ $$y_t = C a_t + Du_t$$ \\(m\\)-dimensional outputs \\(y_t\\), \\(s\\)-dimensional states \\(a_t\\) \\(n\\)-dimensional disturbances \\(u_t\\). disturbances white noise covariance matrix \\(\\mathbf{E} u_t u_t'=\\Sigma\\). Note disturbances outputs may different dimensions, however, \"wide\" systems (\\(m\\leq n\\)) implemented. Gaussian log likelihood (case Gaussian disturbances \\(u_t\\sim N(0,\\Sigma)\\) \\(a_1\\sim N(a_{1|0},\\Pi_{1|0})\\)) computed standard Kalman Filter square root Kalman filter, see kf(). Kalman filter recursive scheme compute linear, least squares predictions \\(a_{t+1}\\) \\(y_{t+1}\\) given observations \\(y_t,\\ldots,y_1\\) time \\(t\\). predictions notated \\(a_{t+1|t}\\) \\(y_{t+1|t}\\), prediction error output \\(y_{t+1}\\) \\(\\epsilon_{t+1|t}=(y_{t+1}-y_{t+1|t})\\) corresponding variances prediction errors $$\\Pi_{t+1|t}=\\mathbf{E}(a_{t+1}-a_{t+1|t}) (a_{t+1}-a_{t+1|t})',$$ $$\\Sigma_{t+1|t}=\\mathbf{E}(\\epsilon_{t+1|t} \\epsilon_{t+1|t}').$$ standard form Kalman filter based parameter matrices \\(,C\\), variance \"state disturbances\" \\(Q=\\mathbf{E}(Bu_t (Bu_t)')=(B\\Sigma B')\\), variance \"measurement disturbances\" \\(R=\\mathbf{E}(Du_t (Du_t)')=(D\\Sigma D')\\) covariance \\(S=\\mathbf{E}(Bu_t(Du_t)')=(B\\Sigma D')\\). Furthermore need initial prediction \\(a_{1|0}\\) corresponding error variance \\(\\Pi_{1|0}\\). square root form filter need \"square roots\" \\(\\Pi_{1|0}^{1/2}\\) \\(\\Sigma^{1/2}\\), .e. matrices \\(\\Pi_{1|0} = \\Pi_{1|0}^{1/2} (\\Pi_{1|0}^{1/2})'\\) \\(\\Sigma = \\Sigma^{1/2}(\\Sigma^{1/2})'\\). addition, define \\(H=(D',B')'\\Sigma^{1/2}\\). (scaled) Gaussian log Likelihood model may expressed $$\\frac{-1}{2N}\\sum_{t=1}^{N}\\left(m\\log(2\\pi) + \\log\\det\\Sigma_{t|t-1} +           (y_t - y_{t|t-1})' \\Sigma_{t|t-1}^{-1} (y_t - y_{t|t-1}) \\right).$$","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/ll_kf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Gaussian log Likelihood of a State Space Model — ll_kf","text":"","code":"ll_kf(model, y, method = c(\"kf\", \"kf2\"), P1 = NULL, a1 = NULL, tol = 0)"},{"path":"https://bfunovits.github.io/RLDM/reference/ll_kf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Gaussian log Likelihood of a State Space Model — ll_kf","text":"model stspmod() object, represents state space model. y sample, .e. \\((N,m)\\) dimensional matrix, \"time series\" object (.e. .matrix(y) return \\((N,m)\\)-dimensional numeric matrix). Missing values (NA, NaN Inf) supported. method Character string. method=\"kf\" ll_kf calls internal C++ implementation (\"standard form\" Kalman filter) method=\"kf2\" \"square root\" form Kalman filter used, .e. internal square root implementation called. numerical errors outputs depend chosen method. P1 \\((s,s)\\) dimensional covariance matrix error initial state estimate, .e. \\(\\Pi_{1|0}\\). NULL, state covariance \\(P = APA'+B\\Sigma B'\\) used. Note scheme assumes state space model stable, .e. state transition matrix \\(\\) stable. a1 \\(s\\) dimensional vector, holds initial estimate \\(a_{1|0}\\) state time \\(t=1\\).  a1=NULL, zero vector used. tol (small) tolerance value (zero). order speed computations, algorithm(s) switch constant Kalman gain significant change state error covariance. behavior controlled parameter tol may switched setting tol=0.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/ll_kf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Gaussian log Likelihood of a State Space Model — ll_kf","text":"(double) Gaussian log Likelihood model.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/ll_kf.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Gaussian log Likelihood of a State Space Model — ll_kf","text":"core routines internal C++ implementations (ll_kf_cpp ll_kf2_cpp) RcppArmadillo implementations standard square root Kalman filter. function ll_kf wrapper function, extracts necessary parameters stspmod() object, computes initial covariance matrix P1 initial state estimate a1 (provided) calls internal C++ implementations. Square root Kalman filter: square root \\(\\Pi_{1|0}^{1/2}\\) procedure first tries Cholesky decomposition. fails (since \\(\\Pi_{1|0}^{1/2}\\) (close ) singular), ll_kf tries compute symmetric square root via eigenvalue decomposition \\(\\Pi_{1|0}^{1/2}\\).","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/ll_kf.html","id":"notes","dir":"Reference","previous_headings":"","what":"Notes","title":"Gaussian log Likelihood of a State Space Model — ll_kf","text":"procedures accept \"wide\" state space systems (\\(m \\leq n\\)), since \"tall\" systems (\\(m > n\\)) variance prediction errors (\\(\\Sigma_{t+1|t}\\)) singular \\(t\\) larger threshold.","code":""},{"path":[]},{"path":"https://bfunovits.github.io/RLDM/reference/ll_kf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Gaussian log Likelihood of a State Space Model — ll_kf","text":"","code":"s = 4  # state dimension m = 2  # number of outputs n = m  # number of inputs (square case m=n) n.obs = 100 # sample size  # generate a (stable) state space model (in innovation form) tmpl = tmpl_stsp_full(m, n, s, sigma_L = \"chol\") model = r_model(tmpl, bpoles = 1, sd = 0.5) # generate a sample data = sim(model, n.obs = n.obs, a1 = NA)  # compute Q, R, S and P1 sigma_L = model$sigma_L sigma = tcrossprod(sigma_L) R = model$sys$D %*% sigma %*% t(model$sys$D) S = model$sys$B %*% sigma %*% t(model$sys$D) Q = model$sys$B %*% sigma %*% t(model$sys$B) P1 = lyapunov(model$sys$A, Q)  # compute H and square root of P1 H = rbind(model$sys$D, model$sys$B) %*% sigma_L P1_R = chol(P1)  # compute logLikelihood (via Kalman Filter) ll = ll_kf(model, data$y)  # compute logLikelihood (via square root Kalman Filter) ll_test = ll_kf(model, data$y, method = 'kf2') all.equal(ll, ll_test) #> [1] TRUE  # Note: ll_kf_cpp and ll_kf2_cpp are internal C++ implementations # called via .Call() by ll_kf()  # call the \"full\" kf routines out = kf(model, data$y) all.equal(ll, out$ll) #> [1] TRUE out = kf(model, data$y, method = 'kf2') all.equal(ll, out$ll) #> [1] TRUE"},{"path":"https://bfunovits.github.io/RLDM/reference/ll_pfilter.html","id":null,"dir":"Reference","previous_headings":"","what":"Particle Filter Approximation of Log-Likelihood — ll_pfilter","title":"Particle Filter Approximation of Log-Likelihood — ll_pfilter","text":"Approximates log-likelihood state space model using particle filters. function useful nonlinear/non-Gaussian models exact Kalman filter likelihood available.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/ll_pfilter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Particle Filter Approximation of Log-Likelihood — ll_pfilter","text":"","code":"ll_pfilter(   model,   y,   N_particles = 1000,   filter_type = c(\"sir\", \"apf\", \"optimal\"),   resampling = c(\"systematic\", \"multinomial\", \"stratified\"),   ess_threshold = 0.5,   N_runs = 10,   ... )  # S3 method for class 'stspmod' ll_pfilter(   model,   y,   N_particles = 1000,   filter_type = c(\"sir\", \"apf\", \"optimal\"),   resampling = c(\"systematic\", \"multinomial\", \"stratified\"),   ess_threshold = 0.5,   N_runs = 10,   ... )"},{"path":"https://bfunovits.github.io/RLDM/reference/ll_pfilter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Particle Filter Approximation of Log-Likelihood — ll_pfilter","text":"model stspmod() object, represents state space model. nonlinear models, additional parameters may required. y sample, .e. \\((N,m)\\) dimensional matrix, \"time series\" object (.e. .matrix(y) return \\((N,m)\\)-dimensional numeric matrix). Missing values (NA, NaN Inf) supported. N_particles Number particles use (default: 1000). filter_type Type particle filter use likelihood approximation. Options: \"sir\" (default), \"apf\". resampling Resampling method: \"multinomial\", \"systematic\" (default), \"stratified\". ess_threshold Effective sample size threshold triggering resampling (default: 0.5). Resampling occurs ESS < ess_threshold * N_particles. N_runs Number independent particle filter runs average (default: 10). Averaging reduces variance likelihood estimator. ... Additional arguments passed filter implementations.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/ll_pfilter.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Particle Filter Approximation of Log-Likelihood — ll_pfilter","text":"Particle filter approximation log-likelihood (scaled \\(1/N\\)).","code":""},{"path":[]},{"path":"https://bfunovits.github.io/RLDM/reference/ll_pfilter.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Particle Filter Approximation of Log-Likelihood — ll_pfilter","text":"","code":"# Linear Gaussian example: compare particle filter likelihood with Kalman filter set.seed(123) s = 2 m = 1 n = m n.obs = 100  tmpl = tmpl_stsp_full(m, n, s, sigma_L = \"chol\") model = r_model(tmpl, bpoles = 1, sd = 0.5) data = sim(model, n.obs = n.obs)  # Kalman filter likelihood (exact) ll_exact = ll_kf(model, data$y)  # Particle filter likelihood approximation ll_approx = ll_pfilter(model, data$y, N_particles = 1000, N_runs = 5)  # Compare (should be close for linear Gaussian model with enough particles) cat(\"Exact (Kalman):\", ll_exact, \"\\n\") #> Exact (Kalman): -0.2533242  cat(\"Approx (PF):\", ll_approx, \"\\n\") #> Approx (PF): -33.54036  cat(\"Difference:\", ll_approx - ll_exact, \"\\n\") #> Difference: -33.28704"},{"path":"https://bfunovits.github.io/RLDM/reference/ll_theta.html","id":null,"dir":"Reference","previous_headings":"","what":"Log-likelihood Given Deep Parameters — ll_theta","title":"Log-likelihood Given Deep Parameters — ll_theta","text":"See ll_FUN(). template template filled deep parameters th. Subsequently, S3 method ll() called class provided template value scaled log-likelihood function returned, see ll().","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/ll_theta.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Log-likelihood Given Deep Parameters — ll_theta","text":"","code":"ll_theta(   th,   template,   y,   which = c(\"concentrated\", \"conditional\", \"kf\", \"kf2\"),   ... )"},{"path":"https://bfunovits.github.io/RLDM/reference/ll_theta.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Log-likelihood Given Deep Parameters — ll_theta","text":"th Vector deep parameter template model template, see model structures. y Data sample given \\((N,m)\\) dimensional matrix, \"time series\" object (sense .matrix(y) return \\((N,m)\\)-dimensional numeric matrix). Missing values (NA, NaN Inf) supported. (character) likelihood compute. ... used.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/ll_theta.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Log-likelihood Given Deep Parameters — ll_theta","text":"Value log-likelihood given deep/free parameter vector th model structure defined via template. Note function simply calls ll(fill_template(th, template), y, , ...).","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/ll_theta.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Log-likelihood Given Deep Parameters — ll_theta","text":"","code":"# Basic example set.seed(123) # Create a template tmpl <- tmpl_stsp_ar(m = 1, p = 1) # Generate random parameters and data th <- rnorm(tmpl$n.par, sd = 0.1) model <- fill_template(th, tmpl) y <- sim(model, n.obs = 50)$y # Compute log-likelihood result <- ll_theta(th, tmpl, y) result #> [1] 2.442574"},{"path":"https://bfunovits.github.io/RLDM/reference/local_model_structures.html","id":null,"dir":"Reference","previous_headings":"","what":"Local Model Structures — local model structures","title":"Local Model Structures — local model structures","text":"Parametrization \"local\" model classes, particular, \"Data Driven Local Coordinates\" detailed (McKelvey et al. 2004)  (Ribarits et al. 2005) .","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/local_model_structures.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Local Model Structures — local model structures","text":"","code":"tmpl_DDLC(   model,   balance = c(\"none\", \"lyapunov\", \"minimum phase\"),   sigma_L = c(\"chol\", \"symm\", \"identity\") )  tmpl_GRAM(   model,   balance = c(\"lyapunov\", \"minimum phase\"),   sigma_L = c(\"chol\", \"symm\", \"identity\") )"},{"path":"https://bfunovits.github.io/RLDM/reference/local_model_structures.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Local Model Structures — local model structures","text":"model stspmod() object, represents state space model. case \\(m = n > 0\\) implemented, .e. output process noise process must dimension. balance (character string) balance = \"lyapunov\" balance = \"minimum phase\" reference model first balanced respective scheme. sigma_L (character string) determines form (left) square root noise covariance \\(\\Sigma\\). choice \"chol\" gives lower triangular matrix, \"symm\" gives symmetric matrix \"identity\" corresponds (fixed) identity matrix.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/local_model_structures.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Local Model Structures — local model structures","text":"Model template, .e. list slots h \\(((m+s)^2 + m^2)\\)-dimensional vector, H \\(((m+s)^2 + m^2, k)\\)-dimensional matrix, class = \"stspmod\"  order = c(m,m,s) n.par number free parameters \\(=k\\). See also model structures() details.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/local_model_structures.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Local Model Structures — local model structures","text":"function tmpl_DDLC tmpl_GRAM construct model templates describe models neighborhood given reference model. first step reference state space model transformed \\(D=\\) eventually (depending parameter \"balance\") balanced. state space models described quadruple \\((,B,C,D=)\\) matrices may embedded \\((s^2+2ms)\\)-dimensional euclidean space. Note parameter matrices uniqely determined ACF spectral density process, .e. inherent non identifiablity problem. minimal models \"equivalence class\" models, represent ACF given set models may obtained state transformation \\((,B,C,D) \\rightarrow (TAT^{-1}, TB, CT^{-1}, D)\\). DDLC parametrization now considers models, \\((,B,C,D=)\\), contained \\(2ms\\)-dimensional subspace, orthogonal \\(s^2\\)-dimensional tangent space set equivalent models. routine tmpl_GRAM considers \\(2ms\\)-dimensional subspace, models close reference models \"approximately\" balanced. schemes may fail \"non-generic\" models. tmpl_DDLC issues warning message tmpl_GRAM throws error, cases \\(2ms\\)-dimensional subspace well defined. Note also parametrization left square root L=sigma_L noise covariance \"local\", .e. th = 0 corresponds (balanced) reference model.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/local_model_structures.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Local Model Structures — local model structures","text":"McKelvey T, Helmersson , Ribarits T (2004). “Data driven local coordinates multivariable linear systems application system identification.” Automatica, 40(9), 1629 - 1635. doi:10.1016/j.automatica.2004.04.015 . Ribarits T, Deistler M, Hanzon B (2005). “analysis separable least squares data driven local coordinates maximum likelihood estimation linear systems.” Automatica, 41(3), 531 - 544. doi:10.1016/j.automatica.2004.11.014 . .","code":""},{"path":[]},{"path":"https://bfunovits.github.io/RLDM/reference/local_model_structures.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Local Model Structures — local model structures","text":"","code":"# create a random state space model with m outputs and s states m = 3 s = 6 tmpl = tmpl_stsp_full(m, n = m, s, sigma_L = 'symm') model = r_model(tmpl, bpoles = 1.1, bzeroes = 1.1, sd = 1/s) model                              # note that sigma_L is symmetric #> state space model [3,3] with s = 6 states #>             s[1]         s[2]        s[3]          s[4]        s[5] #> s[1]  0.22810038 -0.055534564 -0.38486148  0.0009606976  0.19146794 #> s[2] -0.03762850 -0.169762564  0.16762309  0.0642134002  0.16558398 #> s[3]  0.25274510 -0.178631871 -0.11820013 -0.0617766720  0.09139949 #> s[4] -0.25812547  0.050588107 -0.11466810  0.1073960914  0.03978862 #> s[5]  0.09743562  0.074701630  0.17092856 -0.0367477603 -0.10465101 #> s[6]  0.02064237  0.008834038 -0.04746217  0.0552969940  0.22677541 #> x[1]  0.03599026  0.153711245 -0.20345295  0.1828065022 -0.10004326 #> x[2]  0.06327325  0.341680781  0.03021725  0.0725302485  0.36455550 #> x[3] -0.08372058 -0.081838528 -0.02314856 -0.0543219309  0.25543510 #>              s[6]        u[1]         u[2]        u[3] #> s[1] -0.039283393 -0.27799032 -0.009260328 -0.17068813 #> s[2] -0.171070150 -0.06337109  0.086567867  0.01960777 #> s[3] -0.118401094  0.15316610  0.050192227 -0.15791244 #> s[4]  0.042813952 -0.09589116  0.017612699 -0.08175957 #> s[5] -0.041115313  0.10132739 -0.106784335 -0.04268203 #> s[6] -0.057923767 -0.26964712 -0.141617391  0.30731033 #> x[1] -0.158603095  1.00000000  0.000000000  0.00000000 #> x[2] -0.007504621  0.00000000  1.000000000  0.00000000 #> x[3] -0.130817412  0.00000000  0.000000000  1.00000000 #> Left square root of noise covariance Sigma: #>             u[1]        u[2]        u[3] #> u[1] -0.10865832  0.03923110  0.01299347 #> u[2]  0.03923110 -0.16030944 -0.01188468 #> u[3]  0.01299347 -0.01188468  0.24075848 model$sigma_L %*% t(model$sigma_L) # noise covariance Sigma #>              [,1]          [,2]          [,3] #> [1,]  0.013514539 -0.0107063230  0.0012501911 #> [2,] -0.010706323  0.0273794407 -0.0004463629 #> [3,]  0.001250191 -0.0004463629  0.0582747200  # tmpl_DDLC #############################################  # create a DDLC parametrization of a neighborhood of this model tmpl = tmpl_DDLC(model, balance = 'lyapunov', sigma_L = 'chol') # for th = 0, we get the original model (in balanced form) model = fill_template(numeric(tmpl$n.par), tmpl) model                                # note that sigma_L is lower triangular #> state space model [3,3] with s = 6 states #>              s[1]        s[2]        s[3]        s[4]         s[5]         s[6] #> s[1] -0.064661766  0.18619951 -0.04318071 -0.17202978  0.253906306 -0.076100374 #> s[2]  0.275723790  0.11737018 -0.14304339  0.06000027  0.100610290  0.077762879 #> s[3]  0.358223002  0.48027697 -0.26498561 -0.46889184  0.043217844  0.071453155 #> s[4]  0.330470893 -0.04986929 -0.03038608  0.46324068  0.393537483  0.079834550 #> s[5]  0.002009161  0.03913030 -0.09086275 -0.38870772 -0.403955644  0.029803395 #> s[6]  0.049097366 -0.07760024 -0.01908435  0.02608798 -0.233184431  0.037951160 #> x[1] -0.112607848  0.17572840 -0.11764560  0.07836283 -0.027493985 -0.005326004 #> x[2]  0.037424445  0.16302370  0.18757076  0.01716231 -0.008866448  0.001644150 #> x[3]  0.290069184  0.01187126 -0.04095417  0.03446329 -0.028281324 -0.017928036 #>              u[1]        u[2]         u[3] #> s[1]  0.308544263 -0.07662291 -0.094612681 #> s[2] -0.048161017  0.09271023 -0.231556907 #> s[3] -0.036822480 -0.09910174  0.041234039 #> s[4]  0.049012589  0.06298434  0.066822342 #> s[5]  0.027331928  0.08964440  0.028577613 #> s[6]  0.003982739 -0.01410939 -0.003641561 #> x[1]  1.000000000  0.00000000  0.000000000 #> x[2]  0.000000000  1.00000000  0.000000000 #> x[3]  0.000000000  0.00000000  1.000000000 #> Left square root of noise covariance Sigma: #>             u[1]        u[2]      u[3] #> u[1]  0.11625205 0.000000000 0.0000000 #> u[2] -0.09209578 0.137469300 0.0000000 #> u[3]  0.01075414 0.003957598 0.2411294 model$sigma_L %*% t(model$sigma_L)  # however Sigma is the same as above #>              [,1]          [,2]          [,3] #> [1,]  0.013514539 -0.0107063230  0.0012501911 #> [2,] -0.010706323  0.0273794407 -0.0004463629 #> [3,]  0.001250191 -0.0004463629  0.0582747200  #' apply a \"small\" state transformation T = (diag(s)+eps*X) eps = sqrt(.Machine$double.eps) sys = model$sys d_sys = state_trafo(sys, diag(s) + matrix(rnorm(s^2, sd = eps), nrow = s, ncol = s)) d_pi = (as.vector(unclass(d_sys) - unclass(sys)))/eps # The vector d_pi is (close to) an element of the tangent space # of the set of models, which are generated by a state transformation # of the reference model  # by construction d_pi is (close to) orthogonal to tmpl$H max(abs(d_pi %*% tmpl$H[1:((m+s)^2), , drop = FALSE])) #> [1] 4.688126e-08  # the tmpl_DDLC routine may fail in some exceptional cases m = 1 s = 3 model = stspmod(sys = stsp(A = matrix(0, nrow = s, ncol = s),                            B = matrix(rnorm(m*s), nrow = s, ncol = m),                            C = matrix(rnorm(m*s), nrow = m, ncol = s),                            D = diag(m)),                 sigma_L = diag(m))  # For this model \"tmpl_DLLC\" issues a warning. junk = tmpl_DDLC(model, sigma_L = 'chol', balance = 'none') #> Warning: The tangent space of the equivalence class does not have dimension s^2=9 (sv[1]=0.830143005877842, sv[9]=8.1569392940462e-18)  # tmpl_GRAM ############################################# model = fill_template(numeric(tmpl$n.par), tmpl)  tmpl = tmpl_GRAM(model, sigma_L = 'chol') model = fill_template(numeric(tmpl$n.par), tmpl)  # check grammians gr = grammians(model$sys, 'lyapunov') P = gr$P Q = gr$Q # P=Q=diag() should hold! print(round(cbind(P, P-Q), 6)) #>          [,1]    [,2]     [,3]    [,4]     [,5]     [,6] [,7] [,8] [,9] [,10] #> [1,] 0.115428 0.00000 0.000000 0.00000 0.000000 0.000000    0    0    0     0 #> [2,] 0.000000 0.07583 0.000000 0.00000 0.000000 0.000000    0    0    0     0 #> [3,] 0.000000 0.00000 0.056626 0.00000 0.000000 0.000000    0    0    0     0 #> [4,] 0.000000 0.00000 0.000000 0.03377 0.000000 0.000000    0    0    0     0 #> [5,] 0.000000 0.00000 0.000000 0.00000 0.018269 0.000000    0    0    0     0 #> [6,] 0.000000 0.00000 0.000000 0.00000 0.000000 0.002003    0    0    0     0 #>      [,11] [,12] #> [1,]     0     0 #> [2,]     0     0 #> [3,]     0     0 #> [4,]     0     0 #> [5,]     0     0 #> [6,]     0     0  # now consider a model close to the reference model d_th = rnorm(tmpl$n.par, sd = eps) d_model = fill_template(d_th, tmpl) d_sys = d_model$sys gr = grammians(d_sys, 'lyapunov') d_P = gr$P - P d_Q = gr$Q - Q  # the \"disturbed\" system should still be approximately balanced! print(round(cbind(d_P, d_P - d_Q)/eps, 6) ) #>          [,1]    [,2]    [,3]     [,4]     [,5]    [,6] [,7] [,8] [,9] [,10] #> [1,] 0.518699 0.00000 0.00000 0.000000 0.000000 0.00000    0    0    0     0 #> [2,] 0.000000 0.01248 0.00000 0.000000 0.000000 0.00000    0    0    0     0 #> [3,] 0.000000 0.00000 0.26115 0.000000 0.000000 0.00000    0    0    0     0 #> [4,] 0.000000 0.00000 0.00000 0.321089 0.000000 0.00000    0    0    0     0 #> [5,] 0.000000 0.00000 0.00000 0.000000 0.215754 0.00000    0    0    0     0 #> [6,] 0.000000 0.00000 0.00000 0.000000 0.000000 0.01704    0    0    0     0 #>      [,11] [,12] #> [1,]     0     0 #> [2,]     0     0 #> [3,]     0     0 #> [4,]     0     0 #> [5,]     0     0 #> [6,]     0     0 # Create a template tmpl <- tmpl_GRAM() #> Error in tmpl_GRAM(): argument \"model\" is missing, with no default tmpl #> $h #>  [1] -0.064661766  0.275723790  0.358223002  0.330470893  0.002009161 #>  [6] -0.049097366  0.112607848 -0.037424445 -0.290069184  0.186199515 #> [11]  0.117370182  0.480276973 -0.049869286  0.039130298  0.077600241 #> [16] -0.175728398 -0.163023698 -0.011871260 -0.043180706 -0.143043395 #> [21] -0.264985611 -0.030386079 -0.090862747  0.019084350  0.117645603 #> [26] -0.187570755  0.040954173 -0.172029784  0.060000273 -0.468891844 #> [31]  0.463240680 -0.388707717 -0.026087977 -0.078362832 -0.017162315 #> [36] -0.034463289  0.253906306  0.100610290  0.043217844  0.393537483 #> [41] -0.403955644  0.233184431  0.027493985  0.008866448  0.028281324 #> [46]  0.076100374 -0.077762879 -0.071453155 -0.079834550 -0.029803395 #> [51]  0.037951160 -0.005326004  0.001644150 -0.017928036 -0.308544263 #> [56]  0.048161017  0.036822480 -0.049012589 -0.027331928  0.003982739 #> [61]  1.000000000  0.000000000  0.000000000  0.076622906 -0.092710234 #> [66]  0.099101744 -0.062984339 -0.089644397 -0.014109393  0.000000000 #> [71]  1.000000000  0.000000000  0.094612681  0.231556907 -0.041234039 #> [76] -0.066822342 -0.028577613 -0.003641561  0.000000000  0.000000000 #> [81]  1.000000000  0.116252050 -0.092095778  0.010754142  0.000000000 #> [86]  0.137469300  0.003957598  0.000000000  0.000000000  0.241129438 #>  #> $H #>                [,1]         [,2]          [,3]         [,4]          [,5] #>  [1,] -0.0320775435 -0.026218296 -0.0200211349 -0.019049501  0.0134578820 #>  [2,]  0.0130280727 -0.028594641  0.0194578236 -0.007536202 -0.0102511885 #>  [3,] -0.0413621801 -0.050827033  0.0578872906 -0.082184027  0.0234497716 #>  [4,]  0.1138494100  0.006758779 -0.0473455644 -0.004011415  0.0325000486 #>  [5,] -0.0348384220 -0.017963746  0.1206676937 -0.003037007 -0.0568786715 #>  [6,] -0.0736519225 -0.009849491 -0.0942065780 -0.049152049  0.0582449991 #>  [7,] -0.0373204138 -0.033110240 -0.0477358341 -0.020377735  0.0016509173 #>  [8,]  0.0258004551  0.019585906  0.0588206665 -0.004430165 -0.0103657309 #>  [9,]  0.0131979625 -0.032666138  0.0535060621 -0.039184977 -0.0109536250 #> [10,]  0.0165814421  0.036122119 -0.0752949745  0.178594000 -0.1134465119 #> [11,] -0.0226244567 -0.016953386 -0.0135579862 -0.017981851  0.0100355137 #> [12,] -0.0329831334 -0.022110605  0.0306027470 -0.011558124 -0.0001632070 #> [13,] -0.0175921071 -0.028646541 -0.0070830786 -0.005261088 -0.0395555458 #> [14,]  0.0512340728  0.023351286 -0.0228697353 -0.023062005  0.0379756079 #> [15,] -0.0872041966 -0.019035167  0.1747337497 -0.084998933 -0.0530132133 #> [16,] -0.0651565396  0.056696347 -0.0045922422  0.059655399 -0.0087104352 #> [17,]  0.0338685222 -0.005953459 -0.0689014772  0.025657406  0.0211653950 #> [18,] -0.0410271430  0.009072018  0.0120103732  0.009063297  0.0043853070 #> [19,]  0.0364924486  0.038567550  0.1559485155 -0.008265579  0.0072096311 #> [20,] -0.0972629027 -0.048916096 -0.0235808736 -0.009761456 -0.0127807886 #> [21,]  0.0248144782  0.089849577  0.0767508696  0.058595562  0.0101935013 #> [22,] -0.1896346390  0.004794213 -0.0134544240 -0.090919766  0.1621914407 #> [23,]  0.0944126510 -0.162400563 -0.1294625263 -0.083067009 -0.0037628795 #> [24,] -0.1072840477  0.089025556  0.1329822669  0.017071430  0.0291863410 #> [25,] -0.0555458191  0.031479927  0.0729907878  0.005279750 -0.0127656865 #> [26,] -0.0148627589  0.048484929  0.0366245716  0.025354689 -0.0148847691 #> [27,] -0.0599016648 -0.011238027 -0.0333185993 -0.001223594  0.0080566888 #> [28,]  0.0595128356  0.006328575  0.2400902194 -0.149434626  0.0654026977 #> [29,]  0.0697699784 -0.132243383  0.4887487941 -0.346820527  0.0982084828 #> [30,] -0.2859973734 -0.082093805 -0.1332454242 -0.088422818 -0.0105752241 #> [31,]  0.1550936229 -0.014680457  0.1948120407 -0.127237367  0.0839594935 #> [32,] -0.1884702896 -0.093640571  0.0281934672 -0.091979167 -0.0455248837 #> [33,] -0.0668561897 -0.090923870  0.1267262443 -0.200669503  0.1250379940 #> [34,] -0.0163519284 -0.015092862  0.0726353181 -0.066530314  0.0030625931 #> [35,]  0.0204226312 -0.023787240 -0.0235197336 -0.029672668  0.0129623432 #> [36,]  0.0256542237  0.011333783  0.0481666432 -0.016273705  0.0066144274 #> [37,]  0.7740017923 -0.001196252 -0.0792369290 -0.003762180  0.0106892689 #> [38,] -0.0296447252  0.912175802 -0.0144002448 -0.092825613  0.0168513238 #> [39,]  0.0068275550  0.024827237  0.6136626021  0.205888514 -0.0753570933 #> [40,] -0.0706674778 -0.100300509  0.1456908109  0.782518006  0.0869344796 #> [41,]  0.0242894731  0.017060103 -0.0321862885  0.071004400  0.9332298263 #> [42,] -0.0830448991 -0.017873621 -0.0990278580 -0.019861418  0.0692966169 #> [43,]  0.0619247277  0.042681260  0.0325287038  0.033943679 -0.0181490711 #> [44,]  0.0009118513  0.011406042  0.0247254005  0.020255863 -0.0082541491 #> [45,]  0.0173562826  0.070471488  0.0551390300  0.047488368 -0.0050505297 #> [46,] -0.0522371743  0.133767754  0.1562856943  0.082314819 -0.0487826873 #> [47,] -0.1285573133  0.040674015 -0.0007584865 -0.003198409  0.0695586226 #> [48,] -0.0227295575 -0.042732010 -0.0738183722 -0.034568978  0.0412753142 #> [49,] -0.1425471362  0.096927403  0.0723080032  0.032728509  0.0448842425 #> [50,]  0.0522184830 -0.053815752 -0.0518189179 -0.025003282 -0.0048589024 #> [51,] -0.0022033001  0.002466610  0.0022637963  0.001303245  0.0002222052 #> [52,] -0.0136593514  0.009835120 -0.0067731433  0.010263608  0.0021408252 #> [53,]  0.0114621996  0.005568853  0.0049057533  0.006424574 -0.0048611919 #> [54,] -0.0260607828  0.008535708 -0.0132289909  0.003254443  0.0133179530 #> [55,]  0.0329440134 -0.005337429  0.0540701107 -0.009350317 -0.0165895534 #> [56,]  0.0043212602 -0.002822616  0.0052467542 -0.006506324 -0.0051831670 #> [57,] -0.0173518004 -0.012728154 -0.0093112159  0.008745093 -0.0141139198 #> [58,]  0.0081438283 -0.006670613  0.0223876332 -0.004309978  0.0058387484 #> [59,] -0.0864432697 -0.020061822 -0.0199836921 -0.034887727  0.0140199142 #> [60,]  0.0216371229  0.001600597 -0.0010533574  0.014789241  0.0004895186 #> [61,]  0.0000000000  0.000000000  0.0000000000  0.000000000  0.0000000000 #> [62,]  0.0000000000  0.000000000  0.0000000000  0.000000000  0.0000000000 #> [63,]  0.0000000000  0.000000000  0.0000000000  0.000000000  0.0000000000 #> [64,] -0.0209310258  0.001437301 -0.0181764813 -0.003876376  0.0123022885 #> [65,] -0.0186318562  0.009967336 -0.0017796748  0.004689252  0.0133704228 #> [66,] -0.1060984622 -0.024762432 -0.0282421988 -0.043033061  0.0154751199 #> [67,] -0.0061084898  0.005465699  0.0365469572 -0.027398472  0.0316453388 #> [68,] -0.1980307945 -0.070377881 -0.0200920144 -0.100547618 -0.0061084398 #> [69,] -0.0077797573  0.001731849 -0.0277299910  0.003859747  0.0364862304 #> [70,]  0.0000000000  0.000000000  0.0000000000  0.000000000  0.0000000000 #> [71,]  0.0000000000  0.000000000  0.0000000000  0.000000000  0.0000000000 #> [72,]  0.0000000000  0.000000000  0.0000000000  0.000000000  0.0000000000 #> [73,] -0.0110688169 -0.004748061 -0.0104992114  0.001583468  0.0075868526 #> [74,]  0.0063319425 -0.044953405  0.0415655686 -0.047656656 -0.0114647238 #> [75,] -0.0120911382 -0.009045255  0.0310556360 -0.031490781  0.0043267601 #> [76,] -0.0453742006 -0.028294056  0.0078478056 -0.019588258  0.0058278265 #> [77,] -0.0436379504 -0.002716990  0.0074644700 -0.052085788  0.0001021097 #> [78,] -0.0028070648 -0.012166823 -0.0006754442  0.009785259  0.0104789295 #> [79,]  0.0000000000  0.000000000  0.0000000000  0.000000000  0.0000000000 #> [80,]  0.0000000000  0.000000000  0.0000000000  0.000000000  0.0000000000 #> [81,]  0.0000000000  0.000000000  0.0000000000  0.000000000  0.0000000000 #> [82,]  0.0000000000  0.000000000  0.0000000000  0.000000000  0.0000000000 #> [83,]  0.0000000000  0.000000000  0.0000000000  0.000000000  0.0000000000 #> [84,]  0.0000000000  0.000000000  0.0000000000  0.000000000  0.0000000000 #> [85,]  0.0000000000  0.000000000  0.0000000000  0.000000000  0.0000000000 #> [86,]  0.0000000000  0.000000000  0.0000000000  0.000000000  0.0000000000 #> [87,]  0.0000000000  0.000000000  0.0000000000  0.000000000  0.0000000000 #> [88,]  0.0000000000  0.000000000  0.0000000000  0.000000000  0.0000000000 #> [89,]  0.0000000000  0.000000000  0.0000000000  0.000000000  0.0000000000 #> [90,]  0.0000000000  0.000000000  0.0000000000  0.000000000  0.0000000000 #>                [,6]          [,7]          [,8]         [,9]        [,10] #>  [1,] -3.830125e-02 -0.0540720032 -8.733644e-05  0.062502200  0.041125114 #>  [2,]  1.735514e-03  0.0006725068 -2.275826e-02  0.052108959  0.042743274 #>  [3,] -4.678892e-02 -0.0638428275  5.397229e-03  0.075739271  0.110093534 #>  [4,]  8.666539e-03 -0.0079889628  1.888473e-03  0.161405517  0.133072751 #>  [5,] -1.338359e-02  0.0145548490 -7.337227e-03 -0.020451228 -0.005845581 #>  [6,] -8.313279e-02 -0.0360656957 -7.260945e-03  0.059389153 -0.221025353 #>  [7,] -5.730296e-02  0.0923400697  1.650614e-01  0.138033784  0.059124531 #>  [8,] -1.663459e-02 -0.3118804013 -1.559075e-01 -0.117043429  0.052184399 #>  [9,]  3.663626e-03  0.0672276361  2.165505e-02 -0.033490596  0.052353594 #> [10,] -4.709773e-02  0.0269181031  9.933100e-02  0.020382289  0.003082738 #> [11,] -2.564512e-02  0.0218724479  1.169078e-02  0.022798633  0.041298651 #> [12,] -1.387071e-02 -0.0110738637 -1.144369e-02  0.071494117  0.042843686 #> [13,]  1.539698e-02  0.0203754586  3.674748e-02  0.006344502  0.099069209 #> [14,] -4.529459e-02 -0.0283630044  9.452439e-03  0.047380264 -0.090735410 #> [15,]  4.526498e-02  0.0447286196 -1.341126e-01  0.064006531  0.049665621 #> [16,]  3.553714e-03  0.0351226255  1.764886e-01 -0.064873709 -0.135301149 #> [17,] -5.326227e-02 -0.0026029374 -2.034019e-01  0.122141826  0.139889762 #> [18,]  4.460511e-02  0.0989629805  9.275276e-02  0.011568824 -0.096219905 #> [19,] -1.253098e-02 -0.7075295247 -1.365223e-01 -0.280043793 -0.052192441 #> [20,]  4.776520e-03 -0.0556810463  4.513150e-01 -0.059279089 -0.142929339 #> [21,]  1.461944e-02  0.3229128966 -9.309918e-02 -0.608739171 -0.093066558 #> [22,] -3.852706e-01  0.0113119541  1.298034e-01 -0.155336517  0.333195332 #> [23,] -4.332062e-02  0.0211476549 -2.103167e-02  0.042686410  0.102269261 #> [24,] -2.706515e-02 -0.0071494477 -2.364193e-01  0.319631521 -0.643161635 #> [25,]  4.808714e-02 -0.0688675302  2.012998e-01 -0.143013641 -0.157188141 #> [26,]  3.497520e-02  0.0930389218  1.146703e-01 -0.260821252 -0.174356639 #> [27,] -8.696457e-03  0.2649027871  2.608814e-01  0.017066992 -0.065116947 #> [28,] -3.496911e-03 -0.1780661019  5.034364e-01  0.149653785 -0.034032705 #> [29,]  4.642671e-02  0.2656541854 -1.756339e-01  0.055883106 -0.037353628 #> [30,] -6.666227e-02 -0.0624744995 -1.464786e-01  0.035249688 -0.058796571 #> [31,]  1.763142e-02  0.0506228656 -5.537280e-02  0.062591070  0.039005251 #> [32,] -3.631855e-03  0.0582394094 -9.894032e-02  0.060197454  0.062189861 #> [33,] -1.723129e-01  0.0469614283 -4.551162e-02 -0.140198988  0.193946705 #> [34,]  2.794149e-02  0.0031289144 -4.271989e-03 -0.196170715 -0.072708039 #> [35,] -2.905190e-02 -0.0166036865 -8.543622e-02  0.086594423  0.097778004 #> [36,]  3.658892e-02  0.0401212029 -7.636441e-02 -0.121622665 -0.074979575 #> [37,] -9.398731e-02  0.0116100095  1.949684e-02 -0.011666170 -0.066407527 #> [38,] -3.079210e-02  0.0322364537 -1.714158e-02  0.051170515  0.112584909 #> [39,] -8.722194e-04 -0.0679175985  1.576184e-01  0.082775345  0.117477603 #> [40,] -7.750614e-02  0.0591426803 -8.653577e-02  0.021522850  0.074812948 #> [41,]  7.775488e-02 -0.0173449468  1.028972e-02  0.013071626 -0.046909390 #> [42,]  8.029846e-01 -0.0538275128  4.125867e-02 -0.018050600  0.173608421 #> [43,]  3.376127e-03  0.0446431489  1.715460e-02  0.076474182  0.018638572 #> [44,] -1.726727e-02 -0.0342870045  7.858818e-02 -0.045914988 -0.026706133 #> [45,] -9.520745e-03  0.0190959862  1.626954e-02  0.103460879  0.074082792 #> [46,]  1.818068e-01  0.0006135795 -5.652276e-03  0.112654858  0.182335143 #> [47,] -1.963719e-01 -0.0237383070 -5.592491e-03  0.023608476  0.072975963 #> [48,] -1.520254e-01 -0.1502680726  1.297941e-01  0.058202002 -0.096802999 #> [49,] -9.778471e-02  0.0604489946 -8.114326e-02  0.014735572 -0.024878540 #> [50,] -5.481073e-03 -0.0411814784  4.586744e-02 -0.009494442  0.083731690 #> [51,] -5.893449e-05  0.0006942146 -7.957759e-04  0.000974737 -0.006423976 #> [52,] -1.855705e-02  0.0134018235  3.495285e-02  0.007780810  0.007756172 #> [53,]  3.596696e-03 -0.0444544140 -3.246510e-02  0.007204077  0.011373753 #> [54,] -4.076186e-02 -0.0032713788  1.488360e-02 -0.015045944 -0.018907769 #> [55,]  1.918741e-02  0.0100575396 -5.639118e-02 -0.118283425  0.005304526 #> [56,]  4.064821e-03 -0.0011350570  1.366268e-02  0.008193908  0.003908293 #> [57,]  7.306743e-03  0.0122723248  6.628550e-03  0.042580323  0.008859126 #> [58,] -4.020659e-03 -0.0101243433  2.202946e-02 -0.048768146 -0.026089075 #> [59,]  1.897752e-02  0.0066670056 -2.027553e-02 -0.022390688 -0.011284543 #> [60,]  6.938555e-03  0.0011520272 -1.518411e-04  0.003582129  0.007437450 #> [61,]  0.000000e+00  0.0000000000  0.000000e+00  0.000000000  0.000000000 #> [62,]  0.000000e+00  0.0000000000  0.000000e+00  0.000000000  0.000000000 #> [63,]  0.000000e+00  0.0000000000  0.000000e+00  0.000000000  0.000000000 #> [64,] -3.683059e-03 -0.0123550669  1.915925e-02  0.032553486 -0.006392843 #> [65,]  3.835746e-03  0.0126022834 -1.334442e-02 -0.002832858 -0.025672592 #> [66,]  1.687464e-02 -0.0731298405  2.475111e-02  0.104002110 -0.015458663 #> [67,]  1.110845e-02  0.0149013509 -1.879747e-02 -0.070144966 -0.046291859 #> [68,]  3.687831e-02 -0.0417446139 -6.917151e-03 -0.086359843 -0.040156045 #> [69,] -2.975595e-02 -0.0052651267  8.532623e-03 -0.005565353 -0.015399208 #> [70,]  0.000000e+00  0.0000000000  0.000000e+00  0.000000000  0.000000000 #> [71,]  0.000000e+00  0.0000000000  0.000000e+00  0.000000000  0.000000000 #> [72,]  0.000000e+00  0.0000000000  0.000000e+00  0.000000000  0.000000000 #> [73,] -2.097087e-03 -0.0054976265  1.625671e-02  0.034095034 -0.006917228 #> [74,]  2.724878e-02 -0.0434995707  3.066628e-02 -0.005210160  0.005066182 #> [75,]  2.638680e-02 -0.0003638713  1.025650e-02 -0.065231048 -0.046880462 #> [76,]  5.801172e-03 -0.0215942771  2.593684e-03 -0.112305969 -0.042863434 #> [77,]  1.685753e-02 -0.0005899293  1.624529e-03 -0.018198859 -0.013357701 #> [78,] -7.413943e-03  0.0005319968 -1.050291e-03  0.001762997 -0.009451640 #> [79,]  0.000000e+00  0.0000000000  0.000000e+00  0.000000000  0.000000000 #> [80,]  0.000000e+00  0.0000000000  0.000000e+00  0.000000000  0.000000000 #> [81,]  0.000000e+00  0.0000000000  0.000000e+00  0.000000000  0.000000000 #> [82,]  0.000000e+00  0.0000000000  0.000000e+00  0.000000000  0.000000000 #> [83,]  0.000000e+00  0.0000000000  0.000000e+00  0.000000000  0.000000000 #> [84,]  0.000000e+00  0.0000000000  0.000000e+00  0.000000000  0.000000000 #> [85,]  0.000000e+00  0.0000000000  0.000000e+00  0.000000000  0.000000000 #> [86,]  0.000000e+00  0.0000000000  0.000000e+00  0.000000000  0.000000000 #> [87,]  0.000000e+00  0.0000000000  0.000000e+00  0.000000000  0.000000000 #> [88,]  0.000000e+00  0.0000000000  0.000000e+00  0.000000000  0.000000000 #> [89,]  0.000000e+00  0.0000000000  0.000000e+00  0.000000000  0.000000000 #> [90,]  0.000000e+00  0.0000000000  0.000000e+00  0.000000000  0.000000000 #>              [,11]         [,12]         [,13]         [,14]         [,15] #>  [1,] -0.036912198 -0.0365241887 -0.0115745859 -5.354776e-03  2.438326e-04 #>  [2,]  0.016219588  0.0124724037  0.0194256739 -9.236278e-03  6.582399e-04 #>  [3,] -0.030506508  0.0397240849 -0.0342472556  5.962751e-03  6.267557e-04 #>  [4,]  0.024571787  0.1104564340 -0.0084669847  2.785976e-03  6.460429e-04 #>  [5,] -0.019214846 -0.0824706562  0.0250690784 -1.692522e-02  1.337137e-04 #>  [6,]  0.064346920  0.0076204152  0.0258670442  1.510755e-02  1.969879e-03 #>  [7,] -0.060840261 -0.0869206156 -0.0059060407 -1.576994e-02 -1.077825e-04 #>  [8,] -0.005627958 -0.0277863496  0.0206866543 -1.603949e-02  5.665311e-04 #>  [9,]  0.026273449 -0.0418581424  0.0638468397 -3.288263e-02  1.160982e-03 #> [10,] -0.085665578 -0.1083046151 -0.0335359005 -8.588622e-04 -1.583147e-04 #> [11,]  0.010801459  0.0287161711  0.0040251843 -2.032971e-03  9.897713e-05 #> [12,] -0.016865694  0.1169872188 -0.0766577559  3.801578e-02  3.062678e-04 #> [13,] -0.009055165 -0.0205963614  0.0219069551 -2.105802e-02  2.557767e-04 #> [14,]  0.043880503  0.0241675576  0.0188049761  5.508072e-03  1.991740e-03 #> [15,] -0.223736985 -0.0753751482 -0.2062038177  5.664281e-02 -1.932339e-03 #> [16,] -0.042479235  0.0670550910 -0.1132968787  6.257912e-02 -2.312615e-03 #> [17,] -0.056730044  0.0263821805 -0.0499952120  5.646715e-03  2.153107e-04 #> [18,]  0.032982770  0.1280025868 -0.0565111358  4.666906e-02 -8.810594e-04 #> [19,] -0.021533421 -0.0462319877 -0.0074351155  1.608224e-03 -5.702282e-04 #> [20,]  0.052473410 -0.1977985898  0.1438894789 -6.038969e-02  5.993169e-04 #> [21,] -0.033028681  0.0015784673 -0.0561503832  2.893695e-02 -1.750618e-03 #> [22,] -0.472289042 -0.3492909685 -0.2597768042  7.360536e-03 -1.798049e-03 #> [23,]  0.127777746 -0.5540169800  0.4809142078 -2.529157e-01  7.062729e-03 #> [24,] -0.181168375 -0.3742614451 -0.1171297355  6.021797e-02 -8.320315e-03 #> [25,]  0.032599395  0.0559920568 -0.0278103130  3.381176e-02 -1.227159e-03 #> [26,]  0.007804148 -0.0672378889  0.0123624427  5.463260e-03 -1.274704e-03 #> [27,] -0.025381205 -0.0335540450 -0.0225020924  9.994340e-03 -9.244990e-04 #> [28,] -0.044559394  0.0640022290 -0.0940143852  4.520222e-02 -1.392849e-03 #> [29,]  0.055006472  0.0377354248  0.0398398371 -3.952671e-03  8.508643e-04 #> [30,] -0.070052857 -0.0134500888 -0.0808568597  3.389375e-02  1.085682e-05 #> [31,] -0.023438633 -0.0982446238  0.0363196259 -3.217900e-02  8.584594e-04 #> [32,]  0.017946764  0.1317218797 -0.0439541199  2.289700e-02  7.308143e-04 #> [33,]  0.040859752  0.1013670522  0.0174584821 -1.153137e-02  2.053092e-03 #> [34,]  0.031265692 -0.0807304306  0.0673819492 -2.617236e-02  1.553786e-04 #> [35,] -0.017355193 -0.0440852737  0.0257259013 -2.510424e-02  7.979194e-04 #> [36,]  0.030956424 -0.0064315003  0.0238766723 -1.306169e-03 -1.206879e-04 #> [37,] -0.135390996 -0.0283162754 -0.1483917735  5.517590e-02 -2.232744e-03 #> [38,]  0.040339651 -0.0474652155  0.0950715016 -5.139847e-02  2.523194e-03 #> [39,]  0.042682561 -0.0431550908  0.0969526114 -5.295006e-02  2.253587e-03 #> [40,] -0.010436702 -0.0213562263  0.0159183332 -1.626620e-02  1.352804e-03 #> [41,]  0.039444499  0.0197532658  0.0222305784  2.547127e-04 -1.554136e-04 #> [42,] -0.146353317 -0.1402563420 -0.0466663963 -2.136613e-02  7.549976e-04 #> [43,]  0.003348204  0.0139802823 -0.0006254118  2.304430e-04  2.394350e-04 #> [44,] -0.039987400 -0.0067222455 -0.0462348802  1.805222e-02 -8.382088e-04 #> [45,]  0.013213835  0.0010467585  0.0290614337 -1.796365e-02  9.943645e-04 #> [46,]  0.020482691 -0.1134900826 -0.0758211256  9.967963e-02 -7.929554e-03 #> [47,]  0.693643467 -0.1550517371 -0.2386115945  5.437882e-02 -3.172538e-03 #> [48,] -0.153802158  0.2939026539  0.2149448698 -1.586389e-01  7.558379e-04 #> [49,] -0.251604406  0.2091149952  0.5931654151  1.721587e-01 -5.583396e-03 #> [50,]  0.064985003 -0.1544397764  0.1784076565  9.082092e-01  2.899583e-03 #> [51,] -0.003841325  0.0005793689 -0.0059328491  2.838711e-03  9.998506e-01 #> [52,]  0.009368391 -0.0095691114  0.0060510678 -6.831653e-03 -3.112549e-04 #> [53,] -0.006817454  0.0003436071  0.0052192299 -7.338030e-03  3.441853e-04 #> [54,]  0.030199743  0.0128961386  0.0200398936 -2.327361e-03 -8.490593e-04 #> [55,]  0.033663061 -0.0270943467  0.0541847017 -2.244570e-02  8.162673e-04 #> [56,]  0.012033073 -0.0096769982  0.0194007393 -8.451188e-03  3.519191e-04 #> [57,]  0.013523213  0.0165747655  0.0075067547 -1.345357e-03  3.250426e-04 #> [58,] -0.006208843 -0.0251065752  0.0026043687 -1.502048e-03 -9.372444e-05 #> [59,]  0.023117448  0.0091976558  0.0183832749 -3.596397e-03  1.247255e-04 #> [60,] -0.008609075 -0.0049809375 -0.0052605109  5.844900e-04  2.834424e-04 #> [61,]  0.000000000  0.0000000000  0.0000000000  0.000000e+00  0.000000e+00 #> [62,]  0.000000000  0.0000000000  0.0000000000  0.000000e+00  0.000000e+00 #> [63,]  0.000000000  0.0000000000  0.0000000000  0.000000e+00  0.000000e+00 #> [64,] -0.007362446  0.0187284204 -0.0202331888  1.015277e-02 -3.124245e-04 #> [65,] -0.011735070  0.0427139400 -0.0422824353  2.253878e-02 -7.238648e-04 #> [66,]  0.014865848  0.1304740845 -0.0614475283  3.968439e-02 -6.490104e-04 #> [67,]  0.006415405 -0.0146348616  0.0062666247  4.716229e-05 -1.160156e-04 #> [68,]  0.029357445  0.0204653578  0.0131309570  2.169381e-03 -3.997082e-04 #> [69,]  0.026888970  0.0125199780  0.0204694150 -3.389128e-03 -3.500079e-04 #> [70,]  0.000000000  0.0000000000  0.0000000000  0.000000e+00  0.000000e+00 #> [71,]  0.000000000  0.0000000000  0.0000000000  0.000000e+00  0.000000e+00 #> [72,]  0.000000000  0.0000000000  0.0000000000  0.000000e+00  0.000000e+00 #> [73,] -0.007498157  0.0123580734 -0.0164501004  7.999409e-03 -2.814295e-04 #> [74,]  0.057023937 -0.0427682888  0.0885528205 -3.668134e-02  1.338346e-03 #> [75,]  0.026444733 -0.0089068376  0.0250612023 -4.984797e-03 -2.468289e-05 #> [76,]  0.007202721 -0.0450826373  0.0244541467 -9.945018e-03  5.014835e-05 #> [77,]  0.018251528  0.0024876415  0.0163872308 -3.876209e-03  1.099231e-05 #> [78,]  0.004405026  0.0011063995  0.0031233696  2.193557e-04 -1.607569e-04 #> [79,]  0.000000000  0.0000000000  0.0000000000  0.000000e+00  0.000000e+00 #> [80,]  0.000000000  0.0000000000  0.0000000000  0.000000e+00  0.000000e+00 #> [81,]  0.000000000  0.0000000000  0.0000000000  0.000000e+00  0.000000e+00 #> [82,]  0.000000000  0.0000000000  0.0000000000  0.000000e+00  0.000000e+00 #> [83,]  0.000000000  0.0000000000  0.0000000000  0.000000e+00  0.000000e+00 #> [84,]  0.000000000  0.0000000000  0.0000000000  0.000000e+00  0.000000e+00 #> [85,]  0.000000000  0.0000000000  0.0000000000  0.000000e+00  0.000000e+00 #> [86,]  0.000000000  0.0000000000  0.0000000000  0.000000e+00  0.000000e+00 #> [87,]  0.000000000  0.0000000000  0.0000000000  0.000000e+00  0.000000e+00 #> [88,]  0.000000000  0.0000000000  0.0000000000  0.000000e+00  0.000000e+00 #> [89,]  0.000000000  0.0000000000  0.0000000000  0.000000e+00  0.000000e+00 #> [90,]  0.000000000  0.0000000000  0.0000000000  0.000000e+00  0.000000e+00 #>               [,16]         [,17]         [,18]         [,19]         [,20] #>  [1,]  0.0196641071 -0.0263810647  0.0346844514 -0.1370355512  0.7119394397 #>  [2,] -0.0058197175  0.0279754483  0.0048183862  0.1146612830  0.0505018847 #>  [3,]  0.0940552188 -0.0064510588  0.0679264242  0.1899268478 -0.0878819532 #>  [4,] -0.0792038876 -0.0871221101 -0.1514361832  0.0017632450  0.0263149988 #>  [5,]  0.1020069802  0.1290031081  0.2008296478 -0.1459980760 -0.0567786153 #>  [6,]  0.0494602531 -0.1692575154  0.0358583040 -0.0069352117 -0.0374904534 #>  [7,]  0.0407826733 -0.0208352752 -0.0003614762 -0.0818730783 -0.0515510962 #>  [8,]  0.0761012726 -0.0237080567  0.0148029639 -0.0522211309  0.0152049684 #>  [9,]  0.0023921187  0.0126664900 -0.0333086835  0.4544755785  0.0267703754 #> [10,]  0.0703485091  0.1383708481  0.2655595291 -0.0319155901  0.0698876296 #> [11,] -0.0137635064 -0.0299988126 -0.0044351620  0.0787835913  0.0122069872 #> [12,]  0.0649658831 -0.0132078646  0.0483219946  0.0048324841 -0.0068596843 #> [13,]  0.0078734217  0.0377313767  0.1063799041  0.1877003610  0.0575330104 #> [14,]  0.0213070774 -0.2189442128 -0.1048946460 -0.1992742116 -0.0458261265 #> [15,] -0.2190428731  0.4284064742 -0.1715859049 -0.0584638090 -0.0538680932 #> [16,]  0.0348913542  0.0063548666  0.0721340555  0.1980534165 -0.1046779156 #> [17,]  0.0177639910 -0.0853760470  0.0170043071  0.0658073623 -0.0783143341 #> [18,] -0.0298781752  0.0437555107  0.0285429492  0.1002744866  0.0415291401 #> [19,] -0.0141199536 -0.0601939428  0.0033033419  0.0026789121 -0.0427363564 #> [20,] -0.0031403217  0.0206375604  0.1172542297 -0.1870580353 -0.0135668715 #> [21,] -0.0595157884 -0.1242187243 -0.0429268607 -0.1999794355  0.0546153595 #> [22,]  0.1264186078 -0.2878231235 -0.0391488489  0.0457262257 -0.0216773288 #> [23,] -0.0484358209  0.0522561539 -0.1452859051 -0.0152891362 -0.0825332490 #> [24,] -0.1352405089 -0.0584036314 -0.1504251823  0.0744683137  0.0382286721 #> [25,]  0.0116959945  0.0544467463  0.0218238310 -0.0627704806  0.0087438383 #> [26,] -0.0522850036  0.0201560953  0.0023944550  0.2102701561  0.0213398220 #> [27,] -0.0319070020  0.0022458316 -0.0060814517  0.0229613560 -0.0377509014 #> [28,] -0.0444423018  0.0041888488 -0.1298122278  0.0045870515  0.0284611881 #> [29,]  0.5036416264 -0.1409657405 -0.0454254103 -0.0798038022  0.0091166516 #> [30,]  0.2847250538  0.2413610692  0.4032375113 -0.0438801098 -0.0179680290 #> [31,] -0.3825127791 -0.0428419242  0.6896649211  0.0117011168 -0.0262785493 #> [32,] -0.4949232363 -0.4785504805  0.0481374212 -0.0798848503 -0.0073138586 #> [33,] -0.2915835068  0.3839965167 -0.1841496523 -0.1005628738  0.0073717473 #> [34,]  0.0036175432  0.0247395886 -0.0149295075  0.0703856643  0.0532684532 #> [35,]  0.0025237173 -0.0109757370 -0.0245291116  0.0118909104  0.0204735331 #> [36,] -0.0073841976  0.0040757628  0.0367711438 -0.0082223304 -0.0124918127 #> [37,]  0.0679691338 -0.0129635346  0.0608754064  0.0023934878 -0.0025061746 #> [38,]  0.0415726947  0.0284871768  0.0017612203 -0.0346939562 -0.0114432748 #> [39,] -0.0224534660 -0.0822789500  0.0426222770  0.0227267451 -0.0314389455 #> [40,]  0.0732176220 -0.0058354152 -0.0473099340 -0.0501529339 -0.0143606787 #> [41,] -0.0427200902  0.1117961401  0.0380652112  0.0161394104  0.0071095408 #> [42,]  0.0862042948 -0.1910789308  0.0105836976 -0.0059755932 -0.0072333111 #> [43,]  0.0131676275  0.0320591658  0.0523926297 -0.0239322312 -0.0115092836 #> [44,]  0.0098157435 -0.0023637717  0.0400753723  0.0099872689  0.0008537806 #> [45,]  0.0055146510 -0.0040994774  0.0061392346 -0.0088129022  0.0657326720 #> [46,] -0.0598351154  0.1114210496 -0.0696529972  0.0424659498  0.0317864433 #> [47,]  0.0617232209 -0.1331721201  0.0598591895  0.0624182513  0.0078075478 #> [48,]  0.0101105780 -0.0674615872 -0.0636978516  0.0954002062  0.0036440463 #> [49,]  0.0405029200 -0.0783407453  0.0872219623  0.0231852740  0.0125426460 #> [50,] -0.0093659646  0.0021949249 -0.0309959565 -0.0001850479 -0.0076965255 #> [51,] -0.0005575702  0.0001029011 -0.0003150329  0.0018808171  0.0007596866 #> [52,] -0.0029136510 -0.0070670427 -0.0068216635  0.0075906170 -0.0043610364 #> [53,] -0.0003267753  0.0047859517 -0.0022135983 -0.0080843769  0.0040220961 #> [54,]  0.0057974095 -0.0267909054  0.0056835702  0.0066988413  0.0176088166 #> [55,]  0.0011758299  0.0188209844 -0.0147575969  0.4990987402  0.1195198548 #> [56,]  0.0019733632  0.0190067461  0.0016700076  0.0212926396  0.4494060225 #> [57,]  0.0404757106  0.0343434901  0.0213583975 -0.0252839597 -0.0119117351 #> [58,] -0.0046535656  0.0070043897  0.0035494297 -0.0711712330  0.0439034659 #> [59,]  0.0145112691  0.0138321488 -0.0172481792 -0.0345132127  0.0181412638 #> [60,]  0.0051461014  0.0043766637  0.0037141305 -0.0090796647 -0.0062242483 #> [61,]  0.0000000000  0.0000000000  0.0000000000  0.0000000000  0.0000000000 #> [62,]  0.0000000000  0.0000000000  0.0000000000  0.0000000000  0.0000000000 #> [63,]  0.0000000000  0.0000000000  0.0000000000  0.0000000000  0.0000000000 #> [64,]  0.0088675880 -0.0036692026 -0.0055784991  0.0866030467 -0.1662244425 #> [65,]  0.0211960385 -0.0156695318  0.0152142525  0.0198000812  0.0414705990 #> [66,]  0.0932855486  0.0543689256  0.0028203956 -0.1523840174 -0.0636944962 #> [67,] -0.0323019514 -0.0106807079  0.0249352224  0.0069667217 -0.0636011177 #> [68,]  0.0192927507  0.0518194691 -0.0275466672  0.1281014755 -0.0240159722 #> [69,]  0.0156471816 -0.0366601615  0.0031968530  0.0164744255  0.0016007324 #> [70,]  0.0000000000  0.0000000000  0.0000000000  0.0000000000  0.0000000000 #> [71,]  0.0000000000  0.0000000000  0.0000000000  0.0000000000  0.0000000000 #> [72,]  0.0000000000  0.0000000000  0.0000000000  0.0000000000  0.0000000000 #> [73,]  0.0079599267 -0.0069352192 -0.0014148273  0.0595867363  0.3622473094 #> [74,] -0.0094171479  0.0571457247 -0.0298638044 -0.2386634472  0.0526129998 #> [75,]  0.0295321266  0.0076584919 -0.0303819249 -0.0285454917 -0.0983566649 #> [76,] -0.0281578740  0.0210997275  0.0078209100  0.0674651463  0.0913432215 #> [77,]  0.0294962044  0.0072368550 -0.0314421649  0.0521268795  0.0658897505 #> [78,]  0.0062577474 -0.0139664243 -0.0009092707  0.0046475365  0.0027507373 #> [79,]  0.0000000000  0.0000000000  0.0000000000  0.0000000000  0.0000000000 #> [80,]  0.0000000000  0.0000000000  0.0000000000  0.0000000000  0.0000000000 #> [81,]  0.0000000000  0.0000000000  0.0000000000  0.0000000000  0.0000000000 #> [82,]  0.0000000000  0.0000000000  0.0000000000  0.0000000000  0.0000000000 #> [83,]  0.0000000000  0.0000000000  0.0000000000  0.0000000000  0.0000000000 #> [84,]  0.0000000000  0.0000000000  0.0000000000  0.0000000000  0.0000000000 #> [85,]  0.0000000000  0.0000000000  0.0000000000  0.0000000000  0.0000000000 #> [86,]  0.0000000000  0.0000000000  0.0000000000  0.0000000000  0.0000000000 #> [87,]  0.0000000000  0.0000000000  0.0000000000  0.0000000000  0.0000000000 #> [88,]  0.0000000000  0.0000000000  0.0000000000  0.0000000000  0.0000000000 #> [89,]  0.0000000000  0.0000000000  0.0000000000  0.0000000000  0.0000000000 #> [90,]  0.0000000000  0.0000000000  0.0000000000  0.0000000000  0.0000000000 #>               [,21]         [,22]         [,23]         [,24] [,25] [,26] [,27] #>  [1,]  0.0773322377  6.098192e-02  3.962782e-02 -0.0233181011     0     0     0 #>  [2,] -0.7215401995 -3.395936e-02 -8.726662e-02 -0.0502632883     0     0     0 #>  [3,]  0.1216161674 -1.966300e-01  4.489666e-03 -0.1518920658     0     0     0 #>  [4,]  0.0952841605 -5.192438e-01 -9.958776e-02 -0.0243135534     0     0     0 #>  [5,] -0.0846284959 -1.059638e-01 -1.261099e-01  0.0071135778     0     0     0 #>  [6,] -0.0312122979 -1.776919e-02  1.506375e-02 -0.0467350769     0     0     0 #>  [7,]  0.0192336864  1.712124e-02  5.052927e-01 -0.0225958414     0     0     0 #>  [8,] -0.1025141578 -1.141680e-01 -5.536176e-02  0.0278124040     0     0     0 #>  [9,]  0.0682339150  2.774042e-02  6.909087e-02 -0.0479629188     0     0     0 #> [10,]  0.2257115508 -2.620661e-01  3.052969e-01 -0.0068069069     0     0     0 #> [11,]  0.0357285390 -1.190197e-02  5.885180e-04  0.8820335506     0     0     0 #> [12,] -0.0168647316 -3.550744e-02 -5.311391e-03 -0.2095769809     0     0     0 #> [13,]  0.1355222599 -6.690305e-02  3.876161e-02  0.2249362413     0     0     0 #> [14,] -0.0443832364  1.589539e-01 -4.909933e-02  0.2093140633     0     0     0 #> [15,] -0.0299605077 -9.435374e-02 -2.647202e-03  0.0532130384     0     0     0 #> [16,] -0.2009905688 -1.607195e-01  1.789527e-01  0.0435488767     0     0     0 #> [17,]  0.1251887985  1.198534e-01 -6.106198e-02 -0.0402599999     0     0     0 #> [18,] -0.0637358269 -8.398895e-02 -2.051619e-01  0.0644932434     0     0     0 #> [19,]  0.0631800484 -1.216352e-01  2.628780e-01  0.0420437163     0     0     0 #> [20,]  0.1237657603 -2.047523e-01 -4.497047e-01  0.0020704491     0     0     0 #> [21,]  0.0429856779 -5.445692e-02  2.664191e-02 -0.0395837816     0     0     0 #> [22,] -0.0826948101 -3.058523e-02 -1.336756e-01  0.0095025270     0     0     0 #> [23,] -0.1633744700 -8.102290e-02  1.021179e-01  0.0028957813     0     0     0 #> [24,]  0.0558384275 -5.331221e-02 -2.560066e-02  0.0009165543     0     0     0 #> [25,] -0.1987670146 -2.739634e-01  5.618495e-02  0.0345459542     0     0     0 #> [26,] -0.0603975334  6.837766e-02  6.688683e-02  0.0100893549     0     0     0 #> [27,]  0.0452648354  9.933406e-05  2.227913e-01 -0.0163749220     0     0     0 #> [28,]  0.0375847958  2.998175e-01  1.808881e-02 -0.0398334668     0     0     0 #> [29,]  0.0359523514 -1.555266e-01  8.901880e-02  0.0515199607     0     0     0 #> [30,] -0.0308291210  1.788596e-01 -1.037710e-01  0.0004741967     0     0     0 #> [31,] -0.0410239523  4.988569e-02  2.714463e-02  0.0295377167     0     0     0 #> [32,] -0.0003431674 -1.117822e-01  2.049424e-02 -0.0330493199     0     0     0 #> [33,]  0.0223739466 -1.666061e-02  5.042656e-03  0.0031931020     0     0     0 #> [34,]  0.0584210900  1.495828e-01  1.936728e-02  0.0168431454     0     0     0 #> [35,]  0.0812703626  1.519291e-01 -1.275474e-01  0.0096359064     0     0     0 #> [36,] -0.0169325715  1.963555e-02 -1.163069e-01  0.0329818339     0     0     0 #> [37,] -0.0299439458 -1.010326e-02 -9.853977e-02  0.0110463234     0     0     0 #> [38,] -0.0045439144  2.175849e-02 -2.965331e-02  0.0045902391     0     0     0 #> [39,] -0.0215464787  1.173112e-01 -5.582808e-02 -0.0275404119     0     0     0 #> [40,] -0.0128870440  4.592178e-02 -4.920716e-02  0.0347377043     0     0     0 #> [41,]  0.0198743211 -4.473224e-02  4.054920e-02 -0.0102998646     0     0     0 #> [42,] -0.0211416100  3.055948e-02 -9.478819e-03  0.0012913877     0     0     0 #> [43,]  0.0016221612 -8.488087e-03 -1.410978e-02  0.0310987901     0     0     0 #> [44,] -0.0049241004 -7.845221e-02  5.880770e-02  0.0297312059     0     0     0 #> [45,] -0.0053995384 -4.402002e-02  4.152760e-02 -0.0048955711     0     0     0 #> [46,] -0.0007883620 -5.763985e-02 -2.775486e-02  0.0282700978     0     0     0 #> [47,] -0.0050751925 -2.917530e-02  2.218876e-02 -0.0165521027     0     0     0 #> [48,] -0.0102928278  4.122618e-02 -5.004192e-03 -0.0007379441     0     0     0 #> [49,] -0.0001439723 -6.811931e-02  2.220725e-02 -0.0126388731     0     0     0 #> [50,] -0.0019525655  3.576130e-02 -5.185757e-03  0.0015008389     0     0     0 #> [51,]  0.0006326722 -1.690309e-03  3.304949e-04  0.0001956211     0     0     0 #> [52,]  0.0085253197  4.341613e-03  1.840448e-02 -0.0234484652     0     0     0 #> [53,]  0.0098893187  8.665537e-03  1.463590e-02 -0.0117522210     0     0     0 #> [54,]  0.0135752458  2.644056e-02 -5.133768e-03 -0.0045899436     0     0     0 #> [55,]  0.1147881847 -3.047430e-02 -1.680290e-01 -0.0280268939     0     0     0 #> [56,] -0.0573940290 -6.147540e-02 -1.512680e-03  0.0133708354     0     0     0 #> [57,]  0.1336590277 -1.087234e-01 -6.179842e-02 -0.0051835459     0     0     0 #> [58,]  0.0180468734  1.537703e-01  1.852819e-02  0.0143581618     0     0     0 #> [59,] -0.0418410551  5.320539e-02  6.904581e-02  0.0077654605     0     0     0 #> [60,] -0.0104163852  2.528389e-04  1.526281e-02  0.0048508625     0     0     0 #> [61,]  0.0000000000  0.000000e+00  0.000000e+00  0.0000000000     1     0     0 #> [62,]  0.0000000000  0.000000e+00  0.000000e+00  0.0000000000     0     1     0 #> [63,]  0.0000000000  0.000000e+00  0.000000e+00  0.0000000000     0     0     1 #> [64,]  0.1822004977 -1.511747e-01 -1.794845e-01 -0.0101081170     0     0     0 #> [65,] -0.1363458959  3.730638e-03  4.204257e-02  0.0066523925     0     0     0 #> [66,] -0.1221823182 -9.727349e-02  4.764608e-05  0.1177159147     0     0     0 #> [67,]  0.0046898367  1.874437e-02 -1.010309e-01 -0.0096995356     0     0     0 #> [68,]  0.0544087224  4.747633e-02 -3.006157e-02 -0.0085787455     0     0     0 #> [69,]  0.0053027651  2.265068e-02  8.695826e-03  0.0140643664     0     0     0 #> [70,]  0.0000000000  0.000000e+00  0.000000e+00  0.0000000000     0     0     0 #> [71,]  0.0000000000  0.000000e+00  0.000000e+00  0.0000000000     0     0     0 #> [72,]  0.0000000000  0.000000e+00  0.000000e+00  0.0000000000     0     0     0 #> [73,] -0.0862073214 -1.473791e-01 -3.937417e-02 -0.0202133199     0     0     0 #> [74,]  0.1396819684 -8.301667e-03 -4.290089e-02 -0.0272518919     0     0     0 #> [75,]  0.1522944151  2.683730e-02 -4.421273e-02 -0.0665569352     0     0     0 #> [76,]  0.1150663252  8.301538e-02 -6.603182e-02 -0.0026906112     0     0     0 #> [77,] -0.0033354542 -1.277141e-02  3.702563e-03 -0.0202490975     0     0     0 #> [78,] -0.0161792607  1.225186e-02  5.355898e-03 -0.0145815030     0     0     0 #> [79,]  0.0000000000  0.000000e+00  0.000000e+00  0.0000000000     0     0     0 #> [80,]  0.0000000000  0.000000e+00  0.000000e+00  0.0000000000     0     0     0 #> [81,]  0.0000000000  0.000000e+00  0.000000e+00  0.0000000000     0     0     0 #> [82,]  0.0000000000  0.000000e+00  0.000000e+00  0.0000000000     0     0     0 #> [83,]  0.0000000000  0.000000e+00  0.000000e+00  0.0000000000     0     0     0 #> [84,]  0.0000000000  0.000000e+00  0.000000e+00  0.0000000000     0     0     0 #> [85,]  0.0000000000  0.000000e+00  0.000000e+00  0.0000000000     0     0     0 #> [86,]  0.0000000000  0.000000e+00  0.000000e+00  0.0000000000     0     0     0 #> [87,]  0.0000000000  0.000000e+00  0.000000e+00  0.0000000000     0     0     0 #> [88,]  0.0000000000  0.000000e+00  0.000000e+00  0.0000000000     0     0     0 #> [89,]  0.0000000000  0.000000e+00  0.000000e+00  0.0000000000     0     0     0 #> [90,]  0.0000000000  0.000000e+00  0.000000e+00  0.0000000000     0     0     0 #>               [,28]         [,29]         [,30]         [,31]         [,32] #>  [1,]  0.2142659937 -1.737106e-01 -0.0745676829 -0.0218749908 -0.0090369837 #>  [2,]  0.2066646278  3.073178e-02  0.3294616818  0.1476057515 -0.0292779984 #>  [3,] -0.1436039345 -1.900376e-01  0.1966511550 -0.1007165619 -0.0684325246 #>  [4,] -0.1395959606  3.382769e-02  0.1680497006  0.0788844901 -0.0781733516 #>  [5,]  0.0165516129  1.745886e-02  0.2018491910 -0.0143965727 -0.0014911793 #>  [6,]  0.0116850221  7.228733e-03  0.0785824822 -0.0573849200  0.0698342700 #>  [7,]  0.2000492523  9.694813e-02  0.1254299615  0.0494921189 -0.3407922462 #>  [8,]  0.0139105918  2.566046e-01 -0.0369374128  0.1259681940  0.1688542660 #>  [9,] -0.0840700006  7.389832e-02  0.2015190875  0.2318800491 -0.2302142197 #> [10,] -0.0747346434  1.430907e-01  0.1167608161  0.3724815026  0.4765709219 #> [11,]  0.0141104288 -3.534864e-03  0.0747016104  0.0152023168 -0.0093397705 #> [12,] -0.0357029216  2.595379e-02 -0.1225257874  0.1169761457 -0.0659941897 #> [13,]  0.0018544198  4.276811e-02  0.0547530585 -0.2712744694 -0.0147903586 #> [14,]  0.0200398177 -2.902531e-02  0.0535485075  0.4431277935 -0.0558607094 #> [15,] -0.0023246203  2.031585e-02 -0.0142568630 -0.0127302348 -0.0337925388 #> [16,] -0.0272550548  5.807528e-02 -0.2550436870  0.0146346219  0.1109709412 #> [17,] -0.0252553813  1.192180e-01  0.1941894561 -0.1319096161  0.1493132405 #> [18,] -0.1131706317 -2.624193e-01 -0.1341291923 -0.1092274335  0.0938867170 #> [19,]  0.0312565938 -1.107809e-01  0.0176269083 -0.0596141691 -0.1972007126 #> [20,] -0.1070948894  2.398201e-01  0.0404466324  0.0018647562 -0.2350184464 #> [21,]  0.1017777452 -3.159801e-02  0.4524708244 -0.0931815212  0.1209958376 #> [22,] -0.0512208461 -5.074837e-02 -0.0882859026 -0.0348686008  0.0238076316 #> [23,] -0.0017251168 -1.350836e-01 -0.0983522767 -0.0114373601  0.1915080555 #> [24,] -0.0237300321  1.027688e-02  0.1223246428 -0.0127511628 -0.0083856678 #> [25,]  0.0073603909 -1.221062e-01 -0.1527806738  0.0190468631 -0.0324967031 #> [26,] -0.0329723236  1.422488e-02 -0.2371335306  0.0934849897 -0.0114016966 #> [27,]  0.0513305969 -1.128411e-01  0.0608128183 -0.0358638663 -0.2686376082 #> [28,]  0.0385626417  3.815273e-02  0.1482338530  0.0883201586  0.3531268080 #> [29,] -0.0173807127  6.273255e-02 -0.1815620350  0.0664514108  0.0224706526 #> [30,] -0.0141856525 -6.561371e-02  0.0008759065  0.2575607535 -0.1618601206 #> [31,]  0.0311176960 -4.255859e-02 -0.0006634016 -0.0943337632 -0.0082075726 #> [32,] -0.0462560836  6.509576e-02 -0.1486489970  0.2574860646 -0.0360173032 #> [33,] -0.0137875570  4.057513e-02 -0.0795691691  0.2010932609 -0.0311127350 #> [34,]  0.0219635732  1.464831e-02  0.0492059715  0.0647564182 -0.0879433691 #> [35,] -0.0120253861  6.579876e-02  0.0505459804 -0.0071195764  0.0040857082 #> [36,] -0.0432390891 -1.309476e-02 -0.0915896898 -0.0018831652  0.0674418261 #> [37,] -0.0316445554 -2.421632e-02 -0.0472843166  0.1091216807 -0.1917515345 #> [38,] -0.0093295048 -2.716291e-03 -0.0558307767  0.0724714765 -0.0740953757 #> [39,]  0.0116119434 -4.781351e-02  0.0676534358 -0.0754161799 -0.0077731723 #> [40,] -0.0124811771 -1.140162e-02 -0.1041298936  0.1116192565 -0.1166171155 #> [41,] -0.0008818958  3.276211e-02  0.0281995062  0.0031024310  0.0331320294 #> [42,] -0.0043724695 -2.168264e-02  0.0158587434  0.0813587626 -0.0071060180 #> [43,] -0.0114902186 -2.333203e-03 -0.0132465541 -0.0142021589  0.1086372588 #> [44,] -0.0023842412 -2.973109e-02 -0.0212170848 -0.0094655266 -0.0148430362 #> [45,]  0.0296567652 -9.198477e-03  0.0400450706  0.0183780909 -0.0289611892 #> [46,] -0.0211163419 -2.376800e-02  0.0329024300  0.0406955960 -0.0436100873 #> [47,] -0.0058279210 -1.963108e-02  0.0532345335 -0.0227290355  0.0091747641 #> [48,] -0.0056269059 -3.601790e-02  0.1127472046 -0.0076150413  0.0292795306 #> [49,] -0.0076216647 -5.957546e-03  0.0013148385 -0.0123204000 -0.0153673285 #> [50,]  0.0045163518 -9.985075e-04  0.0103931850 -0.0022465677  0.0135841133 #> [51,] -0.0001790442  7.506936e-05  0.0011203940 -0.0020188392 -0.0005029606 #> [52,]  0.0039596135  1.857814e-02  0.0354425262  0.0122500196  0.0040010932 #> [53,]  0.0040948953  1.279186e-02  0.0026009529  0.0109825346  0.0211218846 #> [54,]  0.0014551402  5.639395e-03 -0.0103578689 -0.0115034254  0.0336240448 #> [55,]  0.0487829993  5.925382e-02  0.0539440952  0.2265634555 -0.0192211456 #> [56,] -0.1430386928  8.108958e-02  0.0287133901 -0.0071214904 -0.0501406326 #> [57,]  0.2153199212 -7.696675e-02  0.0368285298  0.0996486776  0.0276999953 #> [58,] -0.1409611395  2.853134e-02  0.0164855008  0.0442771529 -0.0149346276 #> [59,] -0.2111027929  5.950682e-02  0.0385304482 -0.0366790529 -0.0082844744 #> [60,] -0.0357829682  8.042685e-03  0.0038106092  0.0045888358 -0.0040454312 #> [61,]  0.0000000000  0.000000e+00  0.0000000000  0.0000000000  0.0000000000 #> [62,]  0.0000000000  0.000000e+00  0.0000000000  0.0000000000  0.0000000000 #> [63,]  0.0000000000  0.000000e+00  0.0000000000  0.0000000000  0.0000000000 #> [64,]  0.7703105759  1.033787e-02 -0.1147579202 -0.0005154195  0.0482061414 #> [65,]  0.0360174449  6.197489e-01 -0.0433872537 -0.2058547789 -0.0304872884 #> [66,] -0.0558291046 -1.042090e-01  0.2408722276 -0.0340465315 -0.0079730419 #> [67,]  0.0633141804 -1.231922e-01  0.0554009431  0.1948193839  0.0314227020 #> [68,]  0.0274533225 -5.420331e-02  0.0756844987  0.0046669140  0.0561180785 #> [69,] -0.0124669030 -7.376493e-03 -0.0016175318  0.0006263501  0.0097622671 #> [70,]  0.0000000000  0.000000e+00  0.0000000000  0.0000000000  0.0000000000 #> [71,]  0.0000000000  0.000000e+00  0.0000000000  0.0000000000  0.0000000000 #> [72,]  0.0000000000  0.000000e+00  0.0000000000  0.0000000000  0.0000000000 #> [73,]  0.0601516041 -1.308254e-01 -0.0125269290 -0.0300642614  0.0244172224 #> [74,]  0.0455800562  1.185830e-01  0.0211940083  0.0347298237 -0.1775045670 #> [75,] -0.1225905849 -1.979954e-01  0.0237560981  0.0843062951  0.0025382114 #> [76,] -0.0087453419  1.768557e-01 -0.0251972708  0.0523053424 -0.0474809420 #> [77,]  0.0516736289  2.313651e-01 -0.0383014386 -0.0848900428 -0.0123592369 #> [78,]  0.0150409248  3.170671e-02 -0.0062834939 -0.0148440129  0.0006171389 #> [79,]  0.0000000000  0.000000e+00  0.0000000000  0.0000000000  0.0000000000 #> [80,]  0.0000000000  0.000000e+00  0.0000000000  0.0000000000  0.0000000000 #> [81,]  0.0000000000  0.000000e+00  0.0000000000  0.0000000000  0.0000000000 #> [82,]  0.0000000000  0.000000e+00  0.0000000000  0.0000000000  0.0000000000 #> [83,]  0.0000000000  0.000000e+00  0.0000000000  0.0000000000  0.0000000000 #> [84,]  0.0000000000  0.000000e+00  0.0000000000  0.0000000000  0.0000000000 #> [85,]  0.0000000000  0.000000e+00  0.0000000000  0.0000000000  0.0000000000 #> [86,]  0.0000000000  0.000000e+00  0.0000000000  0.0000000000  0.0000000000 #> [87,]  0.0000000000  0.000000e+00  0.0000000000  0.0000000000  0.0000000000 #> [88,]  0.0000000000  0.000000e+00  0.0000000000  0.0000000000  0.0000000000 #> [89,]  0.0000000000  0.000000e+00  0.0000000000  0.0000000000  0.0000000000 #> [90,]  0.0000000000  0.000000e+00  0.0000000000  0.0000000000  0.0000000000 #>               [,33] [,34] [,35] [,36]         [,37]        [,38]        [,39] #>  [1,] -3.632073e-04     0     0     0 -0.4995015275 -0.235061091 -0.008644725 #>  [2,] -3.599680e-02     0     0     0 -0.1044417410  0.126361681  0.121212837 #>  [3,] -8.180294e-02     0     0     0 -0.0722342182 -0.002541018 -0.635134495 #>  [4,] -1.154674e-02     0     0     0 -0.1617639924  0.009511386  0.196934864 #>  [5,] -8.632867e-02     0     0     0 -0.0215736930 -0.103216069  0.249148517 #>  [6,] -6.551112e-02     0     0     0  0.0082615419 -0.038883031  0.033075324 #>  [7,] -2.426753e-02     0     0     0  0.1159784075 -0.132025747  0.043041379 #>  [8,]  6.876893e-02     0     0     0 -0.0134366996 -0.086803862 -0.071279522 #>  [9,] -1.648721e-03     0     0     0 -0.1459886133 -0.027360260  0.013819670 #> [10,] -7.288609e-02     0     0     0  0.0031661033  0.154278152  0.041237416 #> [11,] -2.609598e-01     0     0     0 -0.0252570053  0.006927166 -0.101490816 #> [12,]  2.962375e-01     0     0     0 -0.0130909866  0.044466649 -0.037609895 #> [13,]  7.131444e-01     0     0     0 -0.0003128046  0.176380921  0.247070586 #> [14,]  4.567294e-01     0     0     0  0.0406010754 -0.127382569 -0.245180296 #> [15,]  6.436904e-02     0     0     0  0.0021211792 -0.168313162 -0.067047347 #> [16,]  9.119418e-02     0     0     0 -0.0947865293 -0.315711456 -0.049618766 #> [17,]  3.352753e-02     0     0     0  0.0055131475 -0.386676704  0.003112216 #> [18,]  4.023423e-02     0     0     0 -0.1329277511  0.117554282 -0.094750500 #> [19,] -1.266770e-02     0     0     0  0.0192659522 -0.053224838  0.084623753 #> [20,] -1.110110e-02     0     0     0  0.0069183092 -0.306874790 -0.004872325 #> [21,]  1.198425e-01     0     0     0 -0.0148884096 -0.029209191 -0.207371116 #> [22,] -1.843357e-02     0     0     0 -0.0024997103  0.155735625  0.087197565 #> [23,]  1.170744e-01     0     0     0 -0.0319453449 -0.063618117 -0.175570110 #> [24,]  4.021413e-02     0     0     0 -0.0303715121  0.114879568 -0.008381368 #> [25,]  5.918688e-02     0     0     0 -0.0566336827  0.152636184 -0.116175119 #> [26,] -3.863341e-02     0     0     0 -0.0706370161 -0.038002290  0.087253057 #> [27,] -1.739159e-02     0     0     0  0.0272095788 -0.011527035  0.040238092 #> [28,]  1.936233e-02     0     0     0  0.0313252348  0.032543308 -0.039493982 #> [29,] -3.404090e-02     0     0     0  0.0146230769 -0.063658067  0.067899841 #> [30,]  5.761319e-02     0     0     0  0.0151336833  0.050479305 -0.149408105 #> [31,]  2.575809e-02     0     0     0  0.0090476418 -0.025920471 -0.040689016 #> [32,] -2.640791e-02     0     0     0  0.0149491334  0.002507280 -0.006432661 #> [33,]  2.715552e-02     0     0     0  0.0228062744 -0.014785187 -0.021906049 #> [34,] -3.046668e-02     0     0     0 -0.0059357958  0.044518009  0.043962410 #> [35,] -4.568875e-02     0     0     0  0.0377914591  0.033253939  0.082271082 #> [36,] -3.191995e-03     0     0     0  0.0124168331  0.053106727  0.073675090 #> [37,]  3.348092e-03     0     0     0 -0.0158296450  0.027725485 -0.049792909 #> [38,]  2.565459e-03     0     0     0  0.0121035560 -0.026839914 -0.026295474 #> [39,]  2.730156e-03     0     0     0  0.0169267920  0.007555053 -0.030864112 #> [40,]  1.402864e-02     0     0     0  0.0160979916 -0.031072250 -0.049515006 #> [41,]  1.108096e-02     0     0     0 -0.0031423730  0.004829572  0.026337058 #> [42,] -1.785719e-02     0     0     0  0.0042914966  0.040666207 -0.033642637 #> [43,]  2.079105e-02     0     0     0  0.0159094541  0.027577151 -0.017622474 #> [44,]  1.405697e-02     0     0     0 -0.0163436996  0.004415418  0.008742270 #> [45,]  1.067854e-02     0     0     0 -0.0512936795 -0.001127811 -0.023103964 #> [46,]  4.240152e-02     0     0     0 -0.0543789588  0.024369462 -0.058615878 #> [47,] -9.615161e-03     0     0     0 -0.0170139390  0.075711787  0.015030033 #> [48,]  2.216560e-02     0     0     0 -0.0250656811  0.079199890 -0.040646845 #> [49,] -1.495043e-02     0     0     0 -0.0152581627  0.043795261  0.027485161 #> [50,]  4.321649e-03     0     0     0  0.0079385736 -0.007799914 -0.009019050 #> [51,] -5.905079e-04     0     0     0 -0.0007755330  0.001458591  0.001158956 #> [52,] -7.535531e-03     0     0     0  0.0046899852 -0.008320060  0.001072806 #> [53,] -9.313770e-03     0     0     0  0.0067682001  0.002350495  0.008973614 #> [54,] -7.349449e-05     0     0     0 -0.0121976015 -0.023407778  0.009300464 #> [55,]  2.082301e-02     0     0     0  0.0365809650 -0.050017078  0.001185707 #> [56,] -1.912499e-03     0     0     0  0.3648586874  0.052090077 -0.063903557 #> [57,]  5.010068e-02     0     0     0 -0.1167470014  0.038029589  0.057833818 #> [58,] -2.869496e-03     0     0     0 -0.1868569698  0.006278668  0.064584816 #> [59,]  1.954229e-02     0     0     0 -0.0774214082  0.010099303  0.004688449 #> [60,]  1.303395e-02     0     0     0 -0.0013666679  0.012752416 -0.009533363 #> [61,]  0.000000e+00     0     0     0  0.0000000000  0.000000000  0.000000000 #> [62,]  0.000000e+00     0     0     0  0.0000000000  0.000000000  0.000000000 #> [63,]  0.000000e+00     0     0     0  0.0000000000  0.000000000  0.000000000 #> [64,]  1.919279e-03     0     0     0  0.0547423610  0.031406338 -0.084782490 #> [65,]  4.109983e-02     0     0     0 -0.1315506660  0.007382237 -0.172459871 #> [66,]  1.108490e-01     0     0     0  0.0304803859 -0.076375553  0.059577859 #> [67,] -6.746421e-02     0     0     0  0.0387510349 -0.090078773  0.216161574 #> [68,] -3.905476e-03     0     0     0 -0.0054044679 -0.052199365  0.073059398 #> [69,]  2.091681e-02     0     0     0 -0.0022645238 -0.017155942 -0.015676911 #> [70,]  0.000000e+00     1     0     0  0.0000000000  0.000000000  0.000000000 #> [71,]  0.000000e+00     0     1     0  0.0000000000  0.000000000  0.000000000 #> [72,]  0.000000e+00     0     0     1  0.0000000000  0.000000000  0.000000000 #> [73,]  1.281964e-02     0     0     0  0.6327158451 -0.122704102 -0.022487159 #> [74,] -3.673117e-02     0     0     0 -0.0427024172  0.516128551 -0.058694739 #> [75,]  6.878912e-02     0     0     0 -0.0009130452 -0.096683806  0.180827360 #> [76,] -4.753037e-02     0     0     0  0.0740947329  0.096512906 -0.048013135 #> [77,]  6.475992e-03     0     0     0  0.0027442696  0.047474430 -0.082565059 #> [78,]  2.161574e-02     0     0     0 -0.0156643086  0.009790510 -0.010609174 #> [79,]  0.000000e+00     0     0     0  0.0000000000  0.000000000  0.000000000 #> [80,]  0.000000e+00     0     0     0  0.0000000000  0.000000000  0.000000000 #> [81,]  0.000000e+00     0     0     0  0.0000000000  0.000000000  0.000000000 #> [82,]  0.000000e+00     0     0     0  0.0000000000  0.000000000  0.000000000 #> [83,]  0.000000e+00     0     0     0  0.0000000000  0.000000000  0.000000000 #> [84,]  0.000000e+00     0     0     0  0.0000000000  0.000000000  0.000000000 #> [85,]  0.000000e+00     0     0     0  0.0000000000  0.000000000  0.000000000 #> [86,]  0.000000e+00     0     0     0  0.0000000000  0.000000000  0.000000000 #> [87,]  0.000000e+00     0     0     0  0.0000000000  0.000000000  0.000000000 #> [88,]  0.000000e+00     0     0     0  0.0000000000  0.000000000  0.000000000 #> [89,]  0.000000e+00     0     0     0  0.0000000000  0.000000000  0.000000000 #> [90,]  0.000000e+00     0     0     0  0.0000000000  0.000000000  0.000000000 #>               [,40]         [,41]         [,42] [,43] [,44] [,45] [,46] [,47] #>  [1,] -0.0073668259 -0.0232267263  2.582062e-02     0     0     0     0     0 #>  [2,] -0.3512977460  0.1071443150  4.447313e-02     0     0     0     0     0 #>  [3,] -0.0756372022 -0.1062549233  1.958488e-01     0     0     0     0     0 #>  [4,]  0.3522393201  0.0040181130 -7.135193e-02     0     0     0     0     0 #>  [5,]  0.4490875006  0.0622188853  9.886438e-03     0     0     0     0     0 #>  [6,]  0.0811250302  0.0031568767  3.589779e-02     0     0     0     0     0 #>  [7,]  0.0111908818 -0.1941588457 -4.478045e-02     0     0     0     0     0 #>  [8,]  0.0015915752 -0.5407022158 -3.115621e-02     0     0     0     0     0 #>  [9,]  0.0386517226 -0.0162778864 -1.371537e-02     0     0     0     0     0 #> [10,] -0.2034549192  0.2065981164  9.326384e-02     0     0     0     0     0 #> [11,] -0.0405864043 -0.0412916180 -2.845722e-01     0     0     0     0     0 #> [12,] -0.0524752170  0.0524254761 -7.740911e-01     0     0     0     0     0 #> [13,] -0.1486708264 -0.0919444937  1.375793e-01     0     0     0     0     0 #> [14,]  0.1311419603  0.1687436896  2.797228e-01     0     0     0     0     0 #> [15,] -0.0220479010  0.0289269451  8.956679e-02     0     0     0     0     0 #> [16,]  0.1246375701 -0.0819359035 -2.266642e-02     0     0     0     0     0 #> [17,] -0.0748077223  0.2316525024 -7.862386e-02     0     0     0     0     0 #> [18,]  0.0217328047  0.3327184203 -1.392540e-02     0     0     0     0     0 #> [19,] -0.0882887514  0.3866222224 -3.857122e-02     0     0     0     0     0 #> [20,] -0.3778538495  0.0263831005 -3.064009e-02     0     0     0     0     0 #> [21,]  0.0136781899 -0.0330778959 -2.032586e-01     0     0     0     0     0 #> [22,]  0.0560930324  0.0127762735  4.064211e-02     0     0     0     0     0 #> [23,]  0.1593524241  0.1189837393 -1.509448e-01     0     0     0     0     0 #> [24,] -0.0338050866 -0.0724184193 -8.668130e-02     0     0     0     0     0 #> [25,]  0.0846064395 -0.1570376589  4.132957e-02     0     0     0     0     0 #> [26,]  0.0759714777 -0.0375352441  8.261532e-02     0     0     0     0     0 #> [27,]  0.0280150397  0.2142302923 -1.307829e-02     0     0     0     0     0 #> [28,]  0.0960561139  0.0079991807 -1.137452e-01     0     0     0     0     0 #> [29,] -0.1645105549  0.0893511155  4.914105e-02     0     0     0     0     0 #> [30,]  0.1355112690  0.0447297023 -1.066817e-01     0     0     0     0     0 #> [31,]  0.0727667208 -0.0576721960  6.358722e-03     0     0     0     0     0 #> [32,] -0.0695627906  0.0383411517  3.358130e-02     0     0     0     0     0 #> [33,] -0.0486878222  0.0588268035  1.114209e-03     0     0     0     0     0 #> [34,]  0.0238566593 -0.0480308032  5.951946e-02     0     0     0     0     0 #> [35,] -0.0380289268 -0.0332992043  5.717325e-02     0     0     0     0     0 #> [36,]  0.0013959168  0.0915063253  1.237872e-02     0     0     0     0     0 #> [37,]  0.0031348609 -0.0042469096 -4.166180e-03     0     0     0     0     0 #> [38,] -0.0168742673  0.0432625993 -4.358372e-03     0     0     0     0     0 #> [39,]  0.0918350304 -0.0060693549 -1.356331e-02     0     0     0     0     0 #> [40,]  0.0115959957  0.0206812211  2.319433e-02     0     0     0     0     0 #> [41,] -0.0341670668 -0.0128737418  5.811154e-03     0     0     0     0     0 #> [42,]  0.0357477613  0.0269277408 -1.304114e-02     0     0     0     0     0 #> [43,] -0.0100173239  0.0122173461 -1.671871e-02     0     0     0     0     0 #> [44,] -0.0205234961  0.0646066529 -4.577992e-03     0     0     0     0     0 #> [45,] -0.0054757570 -0.0460165159 -1.635420e-02     0     0     0     0     0 #> [46,]  0.0014453039 -0.0142342308 -3.998692e-02     0     0     0     0     0 #> [47,]  0.0109608181 -0.0155080753 -9.426899e-03     0     0     0     0     0 #> [48,]  0.0571798341 -0.0241747267 -5.638300e-02     0     0     0     0     0 #> [49,] -0.0204802313 -0.0064762724  1.437906e-02     0     0     0     0     0 #> [50,]  0.0154860467  0.0006725011 -7.922468e-03     0     0     0     0     0 #> [51,] -0.0008653109 -0.0013852365 -4.810713e-04     0     0     0     0     0 #> [52,] -0.0013286714 -0.0123186693  8.179260e-03     0     0     0     0     0 #> [53,] -0.0038040443 -0.0077147656  1.293574e-02     0     0     0     0     0 #> [54,]  0.0097596250 -0.0016383387  7.591095e-04     0     0     0     0     0 #> [55,]  0.0674812650  0.0204197631  2.197459e-03     0     0     0     0     0 #> [56,]  0.1104371316  0.0430967786 -1.749901e-05     0     0     0     0     0 #> [57,]  0.0211088595 -0.0206805901  2.736871e-02     0     0     0     0     0 #> [58,]  0.0418658878 -0.0135152502  4.835609e-04     0     0     0     0     0 #> [59,] -0.0198454692 -0.0030103141  1.997730e-02     0     0     0     0     0 #> [60,] -0.0145086172  0.0050439990  1.053774e-02     0     0     0     0     0 #> [61,]  0.0000000000  0.0000000000  0.000000e+00     0     0     0     0     0 #> [62,]  0.0000000000  0.0000000000  0.000000e+00     0     0     0     0     0 #> [63,]  0.0000000000  0.0000000000  0.000000e+00     0     0     0     0     0 #> [64,]  0.0515753692  0.0587321483  2.291015e-02     0     0     0     0     0 #> [65,]  0.2428491330  0.2695621371  7.512959e-02     0     0     0     0     0 #> [66,]  0.1546287455  0.0007604720  1.080485e-01     0     0     0     0     0 #> [67,]  0.0944344870 -0.0153115151 -1.166111e-02     0     0     0     0     0 #> [68,]  0.0161619371 -0.0344923438  9.777529e-03     0     0     0     0     0 #> [69,] -0.0088995687 -0.0031524290  2.004992e-02     0     0     0     0     0 #> [70,]  0.0000000000  0.0000000000  0.000000e+00     0     0     0     0     0 #> [71,]  0.0000000000  0.0000000000  0.000000e+00     0     0     0     0     0 #> [72,]  0.0000000000  0.0000000000  0.000000e+00     0     0     0     0     0 #> [73,]  0.0424072649  0.0135503404 -4.202377e-03     0     0     0     0     0 #> [74,]  0.0479594520 -0.0124279571  5.780619e-03     0     0     0     0     0 #> [75,]  0.0095441470 -0.1019187577  4.461284e-02     0     0     0     0     0 #> [76,]  0.1727574212  0.0532202610  7.464803e-03     0     0     0     0     0 #> [77,]  0.0437166410  0.0918074673  1.721007e-02     0     0     0     0     0 #> [78,] -0.0045404339  0.0133034803  8.777888e-03     0     0     0     0     0 #> [79,]  0.0000000000  0.0000000000  0.000000e+00     1     0     0     0     0 #> [80,]  0.0000000000  0.0000000000  0.000000e+00     0     1     0     0     0 #> [81,]  0.0000000000  0.0000000000  0.000000e+00     0     0     1     0     0 #> [82,]  0.0000000000  0.0000000000  0.000000e+00     0     0     0     1     0 #> [83,]  0.0000000000  0.0000000000  0.000000e+00     0     0     0     0     1 #> [84,]  0.0000000000  0.0000000000  0.000000e+00     0     0     0     0     0 #> [85,]  0.0000000000  0.0000000000  0.000000e+00     0     0     0     0     0 #> [86,]  0.0000000000  0.0000000000  0.000000e+00     0     0     0     0     0 #> [87,]  0.0000000000  0.0000000000  0.000000e+00     0     0     0     0     0 #> [88,]  0.0000000000  0.0000000000  0.000000e+00     0     0     0     0     0 #> [89,]  0.0000000000  0.0000000000  0.000000e+00     0     0     0     0     0 #> [90,]  0.0000000000  0.0000000000  0.000000e+00     0     0     0     0     0 #>       [,48] [,49] [,50] [,51] #>  [1,]     0     0     0     0 #>  [2,]     0     0     0     0 #>  [3,]     0     0     0     0 #>  [4,]     0     0     0     0 #>  [5,]     0     0     0     0 #>  [6,]     0     0     0     0 #>  [7,]     0     0     0     0 #>  [8,]     0     0     0     0 #>  [9,]     0     0     0     0 #> [10,]     0     0     0     0 #> [11,]     0     0     0     0 #> [12,]     0     0     0     0 #> [13,]     0     0     0     0 #> [14,]     0     0     0     0 #> [15,]     0     0     0     0 #> [16,]     0     0     0     0 #> [17,]     0     0     0     0 #> [18,]     0     0     0     0 #> [19,]     0     0     0     0 #> [20,]     0     0     0     0 #> [21,]     0     0     0     0 #> [22,]     0     0     0     0 #> [23,]     0     0     0     0 #> [24,]     0     0     0     0 #> [25,]     0     0     0     0 #> [26,]     0     0     0     0 #> [27,]     0     0     0     0 #> [28,]     0     0     0     0 #> [29,]     0     0     0     0 #> [30,]     0     0     0     0 #> [31,]     0     0     0     0 #> [32,]     0     0     0     0 #> [33,]     0     0     0     0 #> [34,]     0     0     0     0 #> [35,]     0     0     0     0 #> [36,]     0     0     0     0 #> [37,]     0     0     0     0 #> [38,]     0     0     0     0 #> [39,]     0     0     0     0 #> [40,]     0     0     0     0 #> [41,]     0     0     0     0 #> [42,]     0     0     0     0 #> [43,]     0     0     0     0 #> [44,]     0     0     0     0 #> [45,]     0     0     0     0 #> [46,]     0     0     0     0 #> [47,]     0     0     0     0 #> [48,]     0     0     0     0 #> [49,]     0     0     0     0 #> [50,]     0     0     0     0 #> [51,]     0     0     0     0 #> [52,]     0     0     0     0 #> [53,]     0     0     0     0 #> [54,]     0     0     0     0 #> [55,]     0     0     0     0 #> [56,]     0     0     0     0 #> [57,]     0     0     0     0 #> [58,]     0     0     0     0 #> [59,]     0     0     0     0 #> [60,]     0     0     0     0 #> [61,]     0     0     0     0 #> [62,]     0     0     0     0 #> [63,]     0     0     0     0 #> [64,]     0     0     0     0 #> [65,]     0     0     0     0 #> [66,]     0     0     0     0 #> [67,]     0     0     0     0 #> [68,]     0     0     0     0 #> [69,]     0     0     0     0 #> [70,]     0     0     0     0 #> [71,]     0     0     0     0 #> [72,]     0     0     0     0 #> [73,]     0     0     0     0 #> [74,]     0     0     0     0 #> [75,]     0     0     0     0 #> [76,]     0     0     0     0 #> [77,]     0     0     0     0 #> [78,]     0     0     0     0 #> [79,]     0     0     0     0 #> [80,]     0     0     0     0 #> [81,]     0     0     0     0 #> [82,]     0     0     0     0 #> [83,]     0     0     0     0 #> [84,]     1     0     0     0 #> [85,]     0     0     0     0 #> [86,]     0     1     0     0 #> [87,]     0     0     1     0 #> [88,]     0     0     0     0 #> [89,]     0     0     0     0 #> [90,]     0     0     0     1 #>  #> $class #> [1] \"stspmod\" #>  #> $order #> m n s  #> 3 3 6  #>  #> $n.par #> [1] 51 #>   # Use the template with fill_template() # filled <- fill_template(tmpl, theta = rnorm(tmpl$n.par))"},{"path":"https://bfunovits.github.io/RLDM/reference/model_structures.html","id":null,"dir":"Reference","previous_headings":"","what":"Model Structures — model structures","title":"Model Structures — model structures","text":"tools define implement model structures model parameters represented affine function free (deep) parameters. example consider multivariate ARMA models. AR coefficients \\(a_k\\), MA coefficients \\(b_k\\) (left) square root noise covariance matrix, \\(L\\) say, vectorized stacked (long) parameter vector $$\\pi = (\\mbox{vec}(a_1)',\\ldots,\\mbox{vec}(a_p)',              \\mbox{vec}(b_1)',\\ldots,\\mbox{vec}(b_q)',\\mbox{vec}(L)')'$$ parameter vector written $$\\pi = h + H\\theta$$ \\(\\theta\\) represents free parameters. course matrix \\(H\\) assumed full column rank. parameterization scheme quite flexible. particular, ARMA state space models echelon form may represented scheme.  Templates related tools mainly used estimation generation (random) models simulations testing.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/model_structures.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Model Structures — model structures","text":"","code":"model2template(   model,   sigma_L = c(\"as_given\", \"chol\", \"symm\", \"identity\", \"full_normalized\") )  tmpl_arma_pq(   m,   n,   p,   q,   sigma_L = c(\"chol\", \"symm\", \"identity\", \"full_normalized\") )  tmpl_arma_echelon(   nu,   n = length(nu),   sigma_L = c(\"chol\", \"symm\", \"identity\", \"full_normalized\") )  tmpl_rmfd_pq(   m,   n,   p,   q,   sigma_L = c(\"chol\", \"symm\", \"identity\", \"full_normalized\") )  tmpl_rmfd_echelon(   nu,   m = length(nu),   sigma_L = c(\"chol\", \"symm\", \"identity\", \"full_normalized\") )  tmpl_stsp_full(   m,   n,   s,   sigma_L = c(\"chol\", \"symm\", \"identity\", \"full_normalized\") )  tmpl_stsp_ar(m, p, sigma_L = c(\"chol\", \"symm\", \"identity\", \"full_normalized\"))  tmpl_stsp_echelon(   nu,   n = length(nu),   sigma_L = c(\"chol\", \"symm\", \"identity\", \"full_normalized\") )"},{"path":"https://bfunovits.github.io/RLDM/reference/model_structures.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Model Structures — model structures","text":"model armamod(), rmfdmod() stspmod() object. sigma_L (character string) determines form (left) square root noise covariance \\(\\Sigma\\). choice \"chol\" gives lower triangular matrix, \"symm\" gives symmetric matrix \"identity\" corresponds fixed (identity) matrix.  procedure model2template additional option \"as_given\" means structure square root sigma_L completely determined sigma_L slot given model. m output dimension n input dimension (= number shocks = dimension noise process) p order AR polynomial ARMA models, respectively order right factor polynomial \\(c(z)\\) RMFD model. q order MA polynomial ARMA models, respectively order left factor polynomial \\(d(z)\\) RMFD model. nu vector Kronecker indices. ARMA models Kronecker indices describe basis rows RMFD models basis columns Hankel matrix impulse response coefficients. s state dimension state space models.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/model_structures.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Model Structures — model structures","text":"functions model2template tmpl_*** return model template.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/model_structures.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Model Structures — model structures","text":"functions model2template tmpl_*** generate model \"templates\" represent certain model structures, model parameters affine functions free, respectively deep, parameters. template contains information model structure following slots h, H represent vector \\(h\\) marix \\(H\\) described . (vector \\(\\pi\\) stacked model parameters represented \\(\\pi = h +H \\theta\\) \\(\\theta\\) vector deep parameters.) class=[\"armamod\"|\"rmfdmod\"|\"stspmod\"]: determines whether template parametrizes ARMA, RMFD state space models. order: integer vector contains dimensions orders model. ARMA RMFD models order = c(m,n,p,q) state space models order = c(m,n,s). n.par: number free parameters, .e. dimension vector \\(\\theta\\). nu: optional slot contains Kronecker indices \\(\\nu\\). model2template: function model2template() takes armamod(), rmfdmod(), stspmod() object free parameters coded NA's, NaN's Inf's constructs corresponding model template. parametrization (left) square root, \\(L\\) say, noise covariance \\(\\Sigma = LL'\\) following choices possible: case sigma_L = \"as_given\" slot model$sigma_L given model used construct template: NA entries considered free entries fixed. choice sigma_L = \"chol\" first entries model$sigma_L diagonal set zero template constructed . case sigma_L = \"symm\" matrix  model$sigma_L first replaced symmetric one template constructed (according NA's) square root L=sigma_L always symmetric. choice sigma_L = \"identity\" sets matrix L = sigma_L identity matrix. Finally, choice sigma_L = \"full_normalized\" sets diagonal elements equal ones elements NAs L = sigma_L. tmpl_:* functions tmpl_*** implement following model structures: tmpl_arma_pq ARMA models (armamod()) prescribed orders \\((p,q\\)). tmpl_arma_echelon ARMA models (armamod()) echelon form, given Kronecker indices \\(\\nu\\). tmpl_rmfd_pq RMFD models (rmfdmod()) prescribed orders \\((p,q\\)). tmpl_rmfd_echelon RMFD models (rmfdmod()) echelon form, Kronecker indices \\(\\nu\\). Note RMFD models Kronecker indices refer basis column space Hankel matrix impulse response coefficients. tmpl_stsp_full Fully parametrized state space models (stspmod()) given state space dimension \\(s\\), .e. models entry matrices \\(,B,C\\) considered non-fixed. tmpl_stsp_echelon State space models (stspmod()) echelon form, given Kronecker indices \\(\\nu\\). tmpl_state space_ar State space model representations (stspmod()) AR models given order \\(p\\). \"square\" case \\(m=n\\) implemented. model structures impulse response (transfer function) scaled \\((m,n)\\)-dimensional lag zero coefficient, \\(k_0\\) say, form \\(m=n\\) \\(k_0\\) \\(m\\)-dimensional identity matrix. \\(m<n\\) first \\(m\\) columns \\(k_0\\) form \\(m\\)-dimensional identity matrix remaining columns zero. \\(m>n\\) first \\(n\\) rows \\(k_0\\) form \\(n\\)-dimensional identity matrix remaining rows free. parametrization (left) square root \\(L\\) noise covariance \\(\\Sigma = LL'\\) following choices possible: sigma_L=\"chol\" matrix \\(L\\) lower triangular (entries main diagonal considered free entries diagonal zero). sigma_L=\"symm\" matrix \\(L\\) symmetric (entries main diagonal considered free entries diagonal \\(L=L'\\) holds). sigma_L=\"identity\" matrix \\(L\\) fixed \\(n\\)-dimensional identity matrix. sigma_L=\"full_normalized\" diagonal elements matrix \\(L\\) fixed ones elements free.","code":""},{"path":[]},{"path":"https://bfunovits.github.io/RLDM/reference/model_structures.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Model Structures — model structures","text":"","code":"# ###################################################### # construct a template from a model # ######################################################  # Let us consider scalar ARMA(5,1) models # for quarterly data with a strong seasonal component. # In order to have parsimonious models we want a[2]=a[3]=0: model = armamod(lmfd(a = c(1,NA,0,0,NA,NA), b = c(1,NA))) tmpl = model2template(model)  # Let's see how the \"free\" parameters are mapped to the model parameters print(cbind(tmpl$h, tmpl$H)) #>       [,1] [,2] [,3] [,4] [,5] #>  [1,]    1    0    0    0    0 #>  [2,]    0    1    0    0    0 #>  [3,]    0    0    0    0    0 #>  [4,]    0    0    0    0    0 #>  [5,]    0    0    1    0    0 #>  [6,]    0    0    0    1    0 #>  [7,]    1    0    0    0    0 #>  [8,]    0    0    0    0    1 #>  [9,]    1    0    0    0    0 th = -(1:tmpl$n.par) fill_template(th, tmpl) #> ARMA model [1,1] with orders p = 5 and q = 1 #> AR polynomial a(z): #>      z^0 [,1] z^1 [,1] z^2 [,1] z^3 [,1] z^4 [,1] z^5 [,1] #> [1,]        1       -1        0        0       -2       -3 #> MA polynomial b(z): #>      z^0 [,1] z^1 [,1] #> [1,]        1       -4 #> Left square root of noise covariance Sigma: #>      u[1] #> u[1]    1  # Generate a random model with this structure th0 = rnorm(tmpl$n.par, sd = 0.1) model = fill_template(th0, tmpl)  # Extract the \"free\" parameters from the model th = extract_theta(model, tmpl) all.equal(th, th0) #> [1] TRUE  # This model structure fixes sigma_L = 1. # If we change sigma_L = 2 then the model does not fit to the template. model$sigma_L = 2 # the default choice on_error = 'ignore', tells # extract_theta to ignore this misfit: th = extract_theta(model, tmpl, on_error = 'ignore') # with on_error = 'warn' we get a warning and # with on_error = 'stop' would throw an error. th = extract_theta(model, tmpl, on_error = 'warn') #> Warning: model does not match template. max(abs(res)) = 1 # We may also \"ignore\" sigma_L th = extract_theta(model, tmpl, on_error = 'stop', ignore_sigma_L=TRUE)  # If the orders/class of template and model does not fit if (FALSE) { # \\dontrun{ model = armamod(lmfd(a = c(1,1), b = c(1,1))) extract_theta(model, tmpl) model = stspmod(stsp(D = 1)) extract_theta(model, tmpl) } # }  # ###################################################### # the parameter \"sigma_L\" # ######################################################  # consider a state space model (with 1 state) for a 3-dimensional process model = stspmod(stsp(A = 1, B = c(1,0,0), C = c(1,1,1), D = diag(3)))  # We may specify an arbitrary structure for the left square root (L = sigma_L) # of the noise covariance Sigma. Any NA entry is considered as a \"free\" parameter. L = matrix(c(0, NA, 1, 0, 2, 3, NA, 1, 1), nrow = 3, ncol = 3) L #>      [,1] [,2] [,3] #> [1,]    0    0   NA #> [2,]   NA    2    1 #> [3,]    1    3    1 # L has 2 NA entries and thus we get a model structure with 2 free parameters. model$sigma_L = L  tmpl = model2template(model, sigma_L = 'as_given') th = -(1:tmpl$n.par) fill_template(th, tmpl) #> state space model [3,3] with s = 1 states #>      s[1] u[1] u[2] u[3] #> s[1]    1    1    0    0 #> x[1]    1    1    0    0 #> x[2]    1    0    1    0 #> x[3]    1    0    0    1 #> Left square root of noise covariance Sigma: #>      u[1] u[2] u[3] #> u[1]    0    0   -2 #> u[2]   -1    2    1 #> u[3]    1    3    1  # The choice sigma_L = 'chol' forces L to be lower triangular. # In the case considered here, we get a model structure with 1 free parameter. tmpl = model2template(model, sigma_L = 'chol') th = -(1:tmpl$n.par) fill_template(th, tmpl) #> state space model [3,3] with s = 1 states #>      s[1] u[1] u[2] u[3] #> s[1]    1    1    0    0 #> x[1]    1    1    0    0 #> x[2]    1    0    1    0 #> x[3]    1    0    0    1 #> Left square root of noise covariance Sigma: #>      u[1] u[2] u[3] #> u[1]    0    0    0 #> u[2]   -1    2    0 #> u[3]    1    3    1  # The choice sigma_L = 'symm' forces L = sigma_L to be symmetric. # In the case considered here we thus get a model structure with 2 free parameters. tmpl = model2template(model, sigma_L = 'symm') th = -(1:tmpl$n.par) fill_template(th, tmpl) #> state space model [3,3] with s = 1 states #>      s[1] u[1] u[2] u[3] #> s[1]    1    1    0    0 #> x[1]    1    1    0    0 #> x[2]    1    0    1    0 #> x[3]    1    0    0    1 #> Left square root of noise covariance Sigma: #>      u[1] u[2] u[3] #> u[1]    0   -1   -2 #> u[2]   -1    2    2 #> u[3]   -2    2    1  # The choice sigma_L = 'identity' set L equal to the identity matrix, # i.e. sigma_L is fixed. tmpl = model2template(model, sigma_L = 'identity') th = numeric(0) fill_template(th, tmpl) #> state space model [3,3] with s = 1 states #>      s[1] u[1] u[2] u[3] #> s[1]    1    1    0    0 #> x[1]    1    1    0    0 #> x[2]    1    0    1    0 #> x[3]    1    0    0    1 #> Left square root of noise covariance Sigma: #>      u[1] u[2] u[3] #> u[1]    1    0    0 #> u[2]    0    1    0 #> u[3]    0    0    1 tmpl$n.par # there are no free parameters: tmpl$n.par = 0 #> [1] 0  # The choice sigma_L = 'full_normalized' sets the diagonal elements of L equal to ones, # and leaves all other elements free. tmpl = model2template(model, sigma_L = 'full_normalized') th = -(1:tmpl$n.par) fill_template(th, tmpl) #> state space model [3,3] with s = 1 states #>      s[1] u[1] u[2] u[3] #> s[1]    1    1    0    0 #> x[1]    1    1    0    0 #> x[2]    1    0    1    0 #> x[3]    1    0    0    1 #> Left square root of noise covariance Sigma: #>      u[1] u[2] u[3] #> u[1]    1   -3   -5 #> u[2]   -1    1   -6 #> u[3]   -2   -4    1   # ###################################################### # ARMA(p,q) models # ######################################################  m = 2 # output dimension p = 1 # AR order q = 1 # MA order  # model structure with lower triangular sigma_L tmpl = tmpl_arma_pq(m, n = m, p, q, sigma_L = \"chol\") th = rnorm(tmpl$n.par) th = -(1:tmpl$n.par) fill_template(th, tmpl) #> ARMA model [2,2] with orders p = 1 and q = 1 #> AR polynomial a(z): #>      z^0 [,1]  [,2] z^1 [,1]  [,2] #> [1,]        1     0       -1    -3 #> [2,]        0     1       -2    -4 #> MA polynomial b(z): #>      z^0 [,1]  [,2] z^1 [,1]  [,2] #> [1,]        1     0       -5    -7 #> [2,]        0     1       -6    -8 #> Left square root of noise covariance Sigma: #>      u[1] u[2] #> u[1]   -9    0 #> u[2]  -10  -11  # model structure with symmetric sigma_L tmpl = tmpl_arma_pq(m, n = m, p, q, sigma_L = \"symm\") fill_template(th, tmpl) #> ARMA model [2,2] with orders p = 1 and q = 1 #> AR polynomial a(z): #>      z^0 [,1]  [,2] z^1 [,1]  [,2] #> [1,]        1     0       -1    -3 #> [2,]        0     1       -2    -4 #> MA polynomial b(z): #>      z^0 [,1]  [,2] z^1 [,1]  [,2] #> [1,]        1     0       -5    -7 #> [2,]        0     1       -6    -8 #> Left square root of noise covariance Sigma: #>      u[1] u[2] #> u[1]   -9  -10 #> u[2]  -10  -11  # model structure with sigma_L = I tmpl = tmpl_arma_pq(m, n = m, p, q, sigma_L = \"identity\") # here the number of free paramaters is of course (by 3) smaller # than for the above model structures! fill_template(th[1:(length(th)-3)], tmpl) #> ARMA model [2,2] with orders p = 1 and q = 1 #> AR polynomial a(z): #>      z^0 [,1]  [,2] z^1 [,1]  [,2] #> [1,]        1     0       -1    -3 #> [2,]        0     1       -2    -4 #> MA polynomial b(z): #>      z^0 [,1]  [,2] z^1 [,1]  [,2] #> [1,]        1     0       -5    -7 #> [2,]        0     1       -6    -8 #> Left square root of noise covariance Sigma: #>      u[1] u[2] #> u[1]    1    0 #> u[2]    0    1  # Create a template tmpl <- tmpl_arma_echelon() #> Error in tmpl_arma_echelon(): argument \"nu\" is missing, with no default tmpl #> $h #>  [1] 1 0 0 1 0 0 0 0 1 0 0 1 0 0 0 0 1 0 0 1 #>  #> $H #>       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] #>  [1,]    0    0    0    0    0    0    0    0 #>  [2,]    0    0    0    0    0    0    0    0 #>  [3,]    0    0    0    0    0    0    0    0 #>  [4,]    0    0    0    0    0    0    0    0 #>  [5,]    1    0    0    0    0    0    0    0 #>  [6,]    0    1    0    0    0    0    0    0 #>  [7,]    0    0    1    0    0    0    0    0 #>  [8,]    0    0    0    1    0    0    0    0 #>  [9,]    0    0    0    0    0    0    0    0 #> [10,]    0    0    0    0    0    0    0    0 #> [11,]    0    0    0    0    0    0    0    0 #> [12,]    0    0    0    0    0    0    0    0 #> [13,]    0    0    0    0    1    0    0    0 #> [14,]    0    0    0    0    0    1    0    0 #> [15,]    0    0    0    0    0    0    1    0 #> [16,]    0    0    0    0    0    0    0    1 #> [17,]    0    0    0    0    0    0    0    0 #> [18,]    0    0    0    0    0    0    0    0 #> [19,]    0    0    0    0    0    0    0    0 #> [20,]    0    0    0    0    0    0    0    0 #>  #> $class #> [1] \"armamod\" #>  #> $order #> [1] 2 2 1 1 #>  #> $n.par #> [1] 8 #>   # Use the template with fill_template() # filled <- fill_template(tmpl, theta = rnorm(tmpl$n.par))  # ###################################################### # RMFD(p,q) models y[t] = d(z) c(z)^-1 e[t] # ######################################################  m = 2 # output dimension p = 1 # order of c(z) q = 1 # order of d(z)  # model structure with lower triangular sigma_L tmpl = tmpl_rmfd_pq(m, n = m, p, q, sigma_L = \"chol\") th = rnorm(tmpl$n.par) th = -(1:tmpl$n.par) fill_template(th, tmpl) #> RMFD model [2,2] with orders p = 1 and q = 1 #> right factor polynomial c(z): #>      z^0 [,1]  [,2] z^1 [,1]  [,2] #> [1,]        1     0       -1    -5 #> [2,]        0     1       -2    -6 #> left factor polynomial d(z): #>      z^0 [,1]  [,2] z^1 [,1]  [,2] #> [1,]        1     0       -3    -7 #> [2,]        0     1       -4    -8 #> Left square root of noise covariance Sigma: #>      u[1] u[2] #> u[1]   -9    0 #> u[2]  -10  -11  # model structure with symmetric sigma_L tmpl = tmpl_rmfd_pq(m, n = m, p, q, sigma_L = \"symm\") fill_template(th, tmpl) #> RMFD model [2,2] with orders p = 1 and q = 1 #> right factor polynomial c(z): #>      z^0 [,1]  [,2] z^1 [,1]  [,2] #> [1,]        1     0       -1    -5 #> [2,]        0     1       -2    -6 #> left factor polynomial d(z): #>      z^0 [,1]  [,2] z^1 [,1]  [,2] #> [1,]        1     0       -3    -7 #> [2,]        0     1       -4    -8 #> Left square root of noise covariance Sigma: #>      u[1] u[2] #> u[1]   -9  -10 #> u[2]  -10  -11  # model structure with sigma_L = I tmpl = tmpl_rmfd_pq(m, n = m, p, q, sigma_L = \"identity\") # here the number of free paramaters is of course (by 3) smaller # than for the above model structures! fill_template(th[1:(length(th)-3)], tmpl) #> RMFD model [2,2] with orders p = 1 and q = 1 #> right factor polynomial c(z): #>      z^0 [,1]  [,2] z^1 [,1]  [,2] #> [1,]        1     0       -1    -5 #> [2,]        0     1       -2    -6 #> left factor polynomial d(z): #>      z^0 [,1]  [,2] z^1 [,1]  [,2] #> [1,]        1     0       -3    -7 #> [2,]        0     1       -4    -8 #> Left square root of noise covariance Sigma: #>      u[1] u[2] #> u[1]    1    0 #> u[2]    0    1  # Create a template tmpl <- tmpl_rmfd_echelon() #> Error in tmpl_rmfd_echelon(): argument \"nu\" is missing, with no default tmpl #> $h #>  [1] 1 0 0 0 1 0 0 0 0 1 0 0 0 1 0 0 1 0 0 1 #>  #> $H #>       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] #>  [1,]    0    0    0    0    0    0    0    0 #>  [2,]    0    0    0    0    0    0    0    0 #>  [3,]    1    0    0    0    0    0    0    0 #>  [4,]    0    1    0    0    0    0    0    0 #>  [5,]    0    0    0    0    0    0    0    0 #>  [6,]    0    0    0    0    0    0    0    0 #>  [7,]    0    0    1    0    0    0    0    0 #>  [8,]    0    0    0    1    0    0    0    0 #>  [9,]    0    0    0    0    0    0    0    0 #> [10,]    0    0    0    0    0    0    0    0 #> [11,]    0    0    0    0    1    0    0    0 #> [12,]    0    0    0    0    0    1    0    0 #> [13,]    0    0    0    0    0    0    0    0 #> [14,]    0    0    0    0    0    0    0    0 #> [15,]    0    0    0    0    0    0    1    0 #> [16,]    0    0    0    0    0    0    0    1 #> [17,]    0    0    0    0    0    0    0    0 #> [18,]    0    0    0    0    0    0    0    0 #> [19,]    0    0    0    0    0    0    0    0 #> [20,]    0    0    0    0    0    0    0    0 #>  #> $class #> [1] \"rmfdmod\" #>  #> $order #> [1] 2 2 1 1 #>  #> $n.par #> [1] 8 #>   # Use the template with fill_template() # filled <- fill_template(tmpl, theta = rnorm(tmpl$n.par)) # Create a template tmpl <- tmpl_stsp_full() #> Error in tmpl_stsp_full(): argument \"m\" is missing, with no default tmpl #> $h #>  [1] 1 0 0 0 1 0 0 0 0 1 0 0 0 1 0 0 1 0 0 1 #>  #> $H #>       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] #>  [1,]    0    0    0    0    0    0    0    0 #>  [2,]    0    0    0    0    0    0    0    0 #>  [3,]    1    0    0    0    0    0    0    0 #>  [4,]    0    1    0    0    0    0    0    0 #>  [5,]    0    0    0    0    0    0    0    0 #>  [6,]    0    0    0    0    0    0    0    0 #>  [7,]    0    0    1    0    0    0    0    0 #>  [8,]    0    0    0    1    0    0    0    0 #>  [9,]    0    0    0    0    0    0    0    0 #> [10,]    0    0    0    0    0    0    0    0 #> [11,]    0    0    0    0    1    0    0    0 #> [12,]    0    0    0    0    0    1    0    0 #> [13,]    0    0    0    0    0    0    0    0 #> [14,]    0    0    0    0    0    0    0    0 #> [15,]    0    0    0    0    0    0    1    0 #> [16,]    0    0    0    0    0    0    0    1 #> [17,]    0    0    0    0    0    0    0    0 #> [18,]    0    0    0    0    0    0    0    0 #> [19,]    0    0    0    0    0    0    0    0 #> [20,]    0    0    0    0    0    0    0    0 #>  #> $class #> [1] \"rmfdmod\" #>  #> $order #> [1] 2 2 1 1 #>  #> $n.par #> [1] 8 #>   # Use the template with fill_template() # filled <- fill_template(tmpl, theta = rnorm(tmpl$n.par)) # Create a template tmpl <- tmpl_stsp_ar() #> Error in tmpl_stsp_ar(): argument \"m\" is missing, with no default tmpl #> $h #>  [1] 1 0 0 0 1 0 0 0 0 1 0 0 0 1 0 0 1 0 0 1 #>  #> $H #>       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] #>  [1,]    0    0    0    0    0    0    0    0 #>  [2,]    0    0    0    0    0    0    0    0 #>  [3,]    1    0    0    0    0    0    0    0 #>  [4,]    0    1    0    0    0    0    0    0 #>  [5,]    0    0    0    0    0    0    0    0 #>  [6,]    0    0    0    0    0    0    0    0 #>  [7,]    0    0    1    0    0    0    0    0 #>  [8,]    0    0    0    1    0    0    0    0 #>  [9,]    0    0    0    0    0    0    0    0 #> [10,]    0    0    0    0    0    0    0    0 #> [11,]    0    0    0    0    1    0    0    0 #> [12,]    0    0    0    0    0    1    0    0 #> [13,]    0    0    0    0    0    0    0    0 #> [14,]    0    0    0    0    0    0    0    0 #> [15,]    0    0    0    0    0    0    1    0 #> [16,]    0    0    0    0    0    0    0    1 #> [17,]    0    0    0    0    0    0    0    0 #> [18,]    0    0    0    0    0    0    0    0 #> [19,]    0    0    0    0    0    0    0    0 #> [20,]    0    0    0    0    0    0    0    0 #>  #> $class #> [1] \"rmfdmod\" #>  #> $order #> [1] 2 2 1 1 #>  #> $n.par #> [1] 8 #>   # Use the template with fill_template() # filled <- fill_template(tmpl, theta = rnorm(tmpl$n.par))  # ###################################################### # state space models in echelon form # ###################################################### nu = c(3,2,4)   # Kronecker indices m = length(nu)  # number of outputs/inputs tmpl = tmpl_stsp_echelon(nu = nu)  # generate a random vector of parameters. # Note that \"tmpl$n.par\" contains the number free parameters. th = rnorm(tmpl$n.par)  # generate a model according to this structure with the parameters th model = fill_template(th, tmpl) print(model) #> state space model [3,3] with s = 9 states #>             s[1]        s[2]       s[3]        s[4]     s[5]       s[6] #> s[1]  0.00000000  0.00000000  0.0000000  1.00000000 0.000000  0.0000000 #> s[2]  0.00000000  0.00000000  0.0000000  0.00000000 1.000000  0.0000000 #> s[3]  0.00000000  0.00000000  0.0000000  0.00000000 0.000000  1.0000000 #> s[4]  0.00000000  0.00000000  0.0000000  0.00000000 0.000000  0.0000000 #> s[5] -0.56187636  1.59850877  0.6307541 -0.52111732 1.300199 -0.1331510 #> s[6]  0.00000000  0.00000000  0.0000000  0.00000000 0.000000  0.0000000 #> s[7] -0.34391723 -0.08856511 -0.1136399 -0.48987045 2.293079 -1.7565274 #> s[8]  0.00000000  0.00000000  0.0000000  0.00000000 0.000000  0.0000000 #> s[9]  0.09049665  1.08079950 -1.5329020  0.04715443 1.547581 -0.3887799 #> x[1]  1.00000000  0.00000000  0.0000000  0.00000000 0.000000  0.0000000 #> x[2]  0.00000000  1.00000000  0.0000000  0.00000000 0.000000  0.0000000 #> x[3]  0.00000000  0.00000000  1.0000000  0.00000000 0.000000  0.0000000 #>            s[7]       s[8]     s[9]        u[1]       u[2]        u[3] #> s[1] 0.00000000  0.0000000 0.000000 -0.44655722  0.1181445 -0.57746800 #> s[2] 0.00000000  0.0000000 0.000000  0.17480270  0.1340386  2.00248273 #> s[3] 0.00000000  0.0000000 0.000000  0.07455118  0.2210195  0.06670087 #> s[4] 1.00000000  0.0000000 0.000000  0.42816676  1.6408462  1.86685184 #> s[5] 0.08920722  0.0000000 0.000000  0.02467498 -0.2190504 -1.35090269 #> s[6] 0.00000000  1.0000000 0.000000 -1.66747510  0.1680654  0.02098359 #> s[7] 0.84501300  0.6843094 0.000000  0.73649596  1.1683839  1.24991457 #> s[8] 0.00000000  0.0000000 1.000000  0.38602657  1.0541810 -0.71524219 #> s[9] 0.96252797 -1.3952743 0.849643 -0.26565163  1.1452631 -0.75268897 #> x[1] 0.00000000  0.0000000 0.000000  1.00000000  0.0000000  0.00000000 #> x[2] 0.00000000  0.0000000 0.000000  0.00000000  1.0000000  0.00000000 #> x[3] 0.00000000  0.0000000 0.000000  0.00000000  0.0000000  1.00000000 #> Left square root of noise covariance Sigma: #>            u[1]       u[2]      u[3] #> u[1] -0.9385387  0.0000000 0.0000000 #> u[2] -1.0525133  0.3311792 0.0000000 #> u[3] -0.4371595 -2.0142105 0.2119804  # we can extract the free parameters from this given model all.equal(th, extract_theta(model, tmpl, on_error = 'stop')) #> [1] TRUE  # check the impulse response k = impresp(model, lag.max = 2*sum(nu) + 1)  # the lag zero coeffcient k[0] is equal to the identity all.equal(unclass(k$irf)[,,1], diag(m)) #> [1] TRUE  # check the Kronecker indices all.equal(rationalmatrices::pseries2nu(k$irf), nu) #> [1] TRUE"},{"path":"https://bfunovits.github.io/RLDM/reference/pfilter.html","id":null,"dir":"Reference","previous_headings":"","what":"Sequential Monte Carlo (Particle Filter) Methods — pfilter","title":"Sequential Monte Carlo (Particle Filter) Methods — pfilter","text":"Implementation Sequential Monte Carlo (SMC) methods, also known particle filters, state space models. methods extend Kalman filtering nonlinear /non-Gaussian state space models.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/pfilter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sequential Monte Carlo (Particle Filter) Methods — pfilter","text":"","code":"pfilter(   model,   y,   method = c(\"sir\", \"apf\", \"optimal\"),   N_particles = 1000,   resampling = c(\"systematic\", \"multinomial\", \"stratified\"),   ess_threshold = 0.5,   P1 = NULL,   a1 = NULL,   ... )  # S3 method for class 'stspmod' pfilter(   model,   y,   method = c(\"sir\", \"apf\", \"optimal\"),   N_particles = 1000,   resampling = c(\"systematic\", \"multinomial\", \"stratified\"),   ess_threshold = 0.5,   P1 = NULL,   a1 = NULL,   ... )"},{"path":"https://bfunovits.github.io/RLDM/reference/pfilter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sequential Monte Carlo (Particle Filter) Methods — pfilter","text":"model stspmod() object, represents state space model. nonlinear models, additional parameters may required. y sample, .e. \\((N,m)\\) dimensional matrix, \"time series\" object (.e. .matrix(y) return \\((N,m)\\)-dimensional numeric matrix). Missing values (NA, NaN Inf) supported. method Character string specifying particle filter algorithm. Options: \"sir\" (Sampling Importance Resampling, default), \"apf\" (Auxiliary Particle Filter), \"optimal\" (Optimal proposal linear Gaussian). Note: APF method may produce biased likelihood estimates models cross-covariance state observation noise (S != 0). linear Gaussian models cross-correlation, optimal proposal recommended. N_particles Number particles use (default: 1000). resampling Resampling method: \"multinomial\", \"systematic\" (default), \"stratified\". ess_threshold Effective sample size threshold triggering resampling (default: 0.5). Resampling occurs ESS < ess_threshold * N_particles. P1 \\((s,s)\\) dimensional covariance matrix error initial state estimate, .e. \\(\\Pi_{1|0}\\). NULL, state covariance \\(P = APA'+B\\Sigma B'\\) used. a1 \\(s\\) dimensional vector, holds initial estimate \\(a_{1|0}\\) state time \\(t=1\\). a1=NULL, zero vector used. ... Additional arguments passed filter implementations.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/pfilter.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sequential Monte Carlo (Particle Filter) Methods — pfilter","text":"List components filtered_states \\((N+1,s)\\) dimensional matrix filtered state estimates. \\(t\\)-th row corresponds \\(E[x_t | y_{1:t}]\\). predicted_states \\((N+1,s)\\) dimensional matrix predicted state estimates. \\(t\\)-th row corresponds \\(E[x_t | y_{1:t-1}]\\). particles \\((s, N\\_particles, N+1)\\) dimensional array containing particle trajectories. weight_trajectories \\((N+1, N\\_particles)\\) dimensional matrix particle weights time. \\(t\\)-th row corresponds weights time \\(t\\). weights \\((N\\_particles)\\) dimensional vector normalized particle weights final time. log_likelihood Particle approximation log-likelihood. log_likelihood_contributions \\((N)\\) dimensional vector log-likelihood contributions per time step. effective_sample_size \\((N+1)\\) dimensional vector effective sample sizes. N_particles Number particles used. resampling_method Resampling method used. filter_type Type particle filter used.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/pfilter.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Sequential Monte Carlo (Particle Filter) Methods — pfilter","text":"particle filter approximates filtering distribution \\(p(x_t | y_{1:t})\\) using set weighted particles (samples). basic algorithm Sampling Importance Resampling (SIR) filter, also known bootstrap filter. model considered $$x_{t+1} = f(x_t, u_t)$$ $$y_t = h(x_t, v_t)$$ \\(f\\) state transition function, \\(h\\) observation function, \\(u_t\\), \\(v_t\\) noise processes. linear Gaussian models (default), reduce $$x_{t+1} = x_t + B u_t$$ $$y_t = C x_t + D v_t$$ \\(u_t \\sim N(0, Q)\\) \\(v_t \\sim N(0, R)\\).","code":""},{"path":[]},{"path":"https://bfunovits.github.io/RLDM/reference/pfilter.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sequential Monte Carlo (Particle Filter) Methods — pfilter","text":"","code":"# Linear Gaussian example: compare particle filter with Kalman filter set.seed(123) s = 2  # state dimension m = 1  # number of outputs n = m  # number of inputs n.obs = 100 # sample size  # Generate a stable state space model tmpl = tmpl_stsp_full(m, n, s, sigma_L = \"chol\") model = r_model(tmpl, bpoles = 1, sd = 0.5) # Generate a sample data = sim(model, n.obs = n.obs, a1 = NA)  # Run particle filter pf_result = pfilter(model, data$y, N_particles = 500)  # Compare with Kalman filter kf_result = kf(model, data$y)  # Plot filtered states comparison plot(pf_result$filtered_states[,1], type = \"l\", col = \"blue\",      main = \"Filtered State Estimates\") lines(kf_result$a[,1], col = \"red\", lty = 2) legend(\"topright\", legend = c(\"Particle Filter\", \"Kalman Filter\"),        col = c(\"blue\", \"red\"), lty = 1:2)"},{"path":"https://bfunovits.github.io/RLDM/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"Pipe operator","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"https://bfunovits.github.io/RLDM/reference/plot.fevardec.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot Forecast Error Variance Decomposition — plot.fevardec","title":"Plot Forecast Error Variance Decomposition — plot.fevardec","text":"Plot Forecast Error Variance Decomposition","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/plot.fevardec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot Forecast Error Variance Decomposition — plot.fevardec","text":"","code":"# S3 method for class 'fevardec' plot(   x,   main = NA,   xlab = NA,   col = NA,   y_names = x$names,   u_names = y_names,   parse_names = FALSE,   ... )"},{"path":"https://bfunovits.github.io/RLDM/reference/plot.fevardec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot Forecast Error Variance Decomposition — plot.fevardec","text":"x fevardec() object. main (character string) overall title plot. main=NULL omits title main = NA sets default title. xlab (character string) title x-axis. xlab=NULL omits title xlab = NA sets default x-axis title. col (m)-dimensional vector colors. NA default colormap chosen. y_names optional (m)-dimensional character vector names components time-series/process. u_names optional (m)-dimensional character vector names orthogonalized shocks. parse_names boolean. TRUE series- shock- names parsed expression() plotting. See also grDevices::plotmath() usage expressions plot annotations. ... used.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/plot.fevardec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot Forecast Error Variance Decomposition — plot.fevardec","text":"plot routine returns (invisibly) function, subfig say, may used add additional graphic elements subfigures. call opar = subfig() creates new (sub) plot ()-th position suitable margins axis limits. See example .","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/plot.fevardec.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot Forecast Error Variance Decomposition — plot.fevardec","text":"","code":"# set seed for reproducible results set.seed(1995)  model = test_stspmod(dim = c(2,2), s = 3, bpoles = 1, bzeroes = 1) model$names = c('x[t]', 'y[t]')  # impulse response irf = impresp(model, lag.max = 11, H = 'eigen')  # forecast error variance decomposition fevd = fevardec(irf) # plot it subfig = plot(fevd, col = c('lightgray','darkgray'),               u_names = c('epsilon[t]', 'eta[t]'), parse_names = TRUE)  opar = subfig(1) graphics::text(x = 1, y = 0.5, 'EXAMPLE PLOT', col = 'blue', adj = c(0, 0.5))  graphics::par(opar)  # reset seed set.seed(NULL)"},{"path":"https://bfunovits.github.io/RLDM/reference/plot.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot Methods — plot methods","title":"Plot Methods — plot methods","text":"Plot methods impulse response functions (impresp() objects), autocovariance functions (autocov() objects), frequency response functions (freqresp() objects) spectral densities (spectrald() objects).","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/plot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot Methods — plot methods","text":"","code":"# S3 method for class 'impresp' plot(   x,   x_list = NULL,   xlim = c(\"global\", \"column\", \"subfig\"),   ylim = c(\"row\", \"subfig\", \"global\"),   main = NA,   xlab = NA,   ylab = NULL,   subfigure_main = NA,   parse_subfigure_main = FALSE,   style = c(\"gray\", \"bw\", \"bw2\", \"colored\"),   col = NA,   type = \"l\",   lty = \"solid\",   lwd = 1,   pch = 16,   cex.points = 1,   bg.points = \"black\",   legend = NULL,   legend_args = NA,   ... )  # S3 method for class 'autocov' plot(   x,   x_list = NULL,   xlim = c(\"global\", \"column\", \"subfig\"),   ylim = c(\"row\", \"subfig\", \"global\"),   main = NA,   xlab = NA,   ylab = NULL,   subfigure_main = NA,   parse_subfigure_main = FALSE,   style = c(\"gray\", \"bw\", \"bw2\", \"colored\"),   col = NA,   type = \"l\",   lty = \"solid\",   lwd = 1,   pch = 16,   cex.points = 1,   bg.points = \"black\",   legend = NULL,   legend_args = NA,   ... )  # S3 method for class 'freqresp' plot(   x,   x_list = NULL,   sampling_rate = 1,   unit = \"\",   which = c(\"gain\", \"phase\", \"nyquist\"),   xlim = NA,   ylim = NA,   log = \"\",   main = NA,   xlab = NA,   ylab = NA,   subfigure_main = NA,   parse_subfigure_main = FALSE,   style = c(\"gray\", \"bw\", \"bw2\", \"colored\"),   col = NA,   type = \"l\",   lty = \"solid\",   lwd = 1,   pch = 16,   cex.points = 1,   bg.points = \"black\",   legend = NULL,   legend_args = NA,   ... )  # S3 method for class 'spectrald' plot(   x,   x_list = NULL,   sampling_rate = 1,   unit = \"\",   which = c(\"modulus\", \"phase\", \"coherence\"),   xlim = c(0, 0.5) * sampling_rate,   ylim = \"row\",   log = \"\",   main = NA,   xlab = NA,   ylab = NA,   subfigure_main = NA,   parse_subfigure_main = FALSE,   style = c(\"gray\", \"bw\", \"bw2\", \"colored\"),   col = NA,   type = \"l\",   lty = \"solid\",   lwd = 1,   pch = 16,   cex.points = 1,   bg.points = \"black\",   legend = NULL,   legend_args = NA,   ... )"},{"path":"https://bfunovits.github.io/RLDM/reference/plot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot Methods — plot methods","text":"x impresp(), autocov(), freqresp() spectrald()  object. x_list (optional) list additional objects (class \"x\"). xlim, ylim determine axis limits subfigures. E.g. xlim = 'column' means subfigures column use x-axis limits. Analogously y = 'row' implies subfigures row share limits y-axis.  \"freqresp\" \"spectrald\" plots parameter xlim may also numeric 2-dimensional vector xlim = c(x1,x2). case sub-figures use given limits x-axis. Furthermore limits y-axis computed based corresponding data subset. option may used \"zoom\" certain range frequencies. main (character expression) main title plot xlab (character string expression) label x-axis ylab (character expression) label y-axis subfigure_main scalar (m x n) matrix type \"character\" titles subfigures. subfigure_main scalar character string procedures creates matrix respective titles replacing \"place holders\" 'i_' 'j_' respective row column number. parse_subfigure_main boolean. TRUE titles subfigures parsed expression plotting. See also plotmath usage expressions plot annotations. style (character string) determines appearance plot (background color plot regions, color line style grid lines, axis color, ...) See also style_parameters. col vector line colors type vector plot types. following values possible: \"p\" points, \"l\" lines, \"b\" points lines, \"c\" empty points joined lines, \"o\" overplotted points lines, \"s\" \"S\" stair steps \"h\" histogram-like vertical lines. 'n' suppresses plotting. lty vector line types. Line types can either specified integers (0=blank, 1=solid (default), 2=dashed, 3=dotted, 4=dotdash, 5=longdash, 6=twodash) one character strings \"blank\", \"solid\", \"dashed\", \"dotted\", \"dotdash\", \"longdash\", \"twodash\", \"blank\" uses ‘invisible lines’ (.e., draw ). lwd vector line widths. pch vector plotting character symbols. See points possible values. cex.points vector scales plotting symbols. bg.points vector fill color open plot symbols. legend (character expression vector). NULL legend produced. legend_args (optional) list parameters legend. legend title can included legend_args = list(title = my_legend_title). Note slots x, y ignored legend always put right hand side plot. See also legend. ... used. sampling_rate (number) sampling rate. unit (character string) time frequency unit. (character string) plot. parameter used plotting frequency response objects spectral densities. See details . log character string contains \"x\" x axis logarithmic, \"y\" y axis logarithmic \"xy\" \"yx\" axes logarithmic.  parameter used plotting frequency response objects spectral densities. Note logarithmic y-axis makes sense plotting moduli frequency response spectral density.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/plot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot Methods — plot methods","text":"plot methods return (invisibly) \"closure()\", subfig say, may used add additional graphic elements subfigures. call opar = subfig(,j) creates new (sub) plot (,j)-th position suitable margins axis limits. See examples .","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/plot.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot Methods — plot methods","text":"x \\((m,n)\\) dimensional object plot divided \\((m,n)\\) array subfigures. subfigures respective \\((,j)\\)-th element object x displayed. methods allow simultaneous plotting several objects, passing list x_list additional objects procedure. following assume x_list contains \\(k-1\\) objects, .e. total \\(k\\) objects plotted. parameter \"xlim\" determines x-limits subfigures: xlim='global' uses x-limits subfigures (limits determined data). case frequency response spectral density objects one may also pass two-dimensional vector xlim = c(x1,x2) plot method. case subfigures use values common x-limits. xlim='column' means sub figures \"column\" x-limits. limits determined data. Finally xlim='subfigure' means subfigure gets x-limits (determined data). Quite analogously parameter ylim determines limits y-axes. (Just replace 'column' 'row'). plot methods quite number optional design parameters. cases parameters interpreted follows. NA values mean methods use suitable defaults. E.g. labels x- y-axis chosen according class object(s) plotted parameter \"\". NULL values (optional) parameters mean respective graphic element omitted. E.g. subfigure_main = NULL skips titles subfigures. titles (m,n) subfigures determined parameter subfigure_main. One may pass \\((m,n)\\) character matrix scalar character (string) procedure. subfigure_main scalar (character string) procedures creates respective titles replacing \"place holders\" i_ j_ respective row column number. See examples . \"style\" parameters col, type, ..., bg.points determine appearance \"lines\" k objects. (necessary values \"recycled\".) See also graphics::lines() graphics::points() detailed explanation parameters. one object plotted (optional parameter x_list empty) suitable legend may added parameters legend legend_args. Note legend character (expression) vector length k. parameter \"\" determines plot case \"freqresp\" \"spectrald\" objects. gain,modulus plot moduli abs(x[,j]) versus frequencies. phase plot arguments Arg(x[,j]) versus frequencies. nyquist plot imaginary part Im(x[,j]) versus real part Re(x[,j]). coherence plot coherence. plot somewhat special. \"coherence matrix\" symmetric diagonal entries equal one (frequencies). Therefore entries diagonal contain additional information. reason subfigures diagonal display coherence, subfigures show \"scaled arguments\" Arg(x[,j])/(2*pi)+0.5 subfigures diagonal display scaled auto spectra \\(m\\) component processes. plot methods use internal helper function rationalmatrices::plot_3D().","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/plot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot Methods — plot methods","text":"","code":"set.seed(1995)  # set seed to get reproducible results n.obs = 2^8 m = 2 s = 3  # generate a random, stable and minimum phase state space model # for a bivariate process (x[t], y[t]) model = test_stspmod(dim = c(m,m), s = s, bpoles = 1, bzeroes = 1) model$names = c('x[t]', 'y[t]')  # simulate data data = sim(model, n.obs = n.obs)  #### plot impulse response # overlay three different \"orthogonalization\" schemes plot(impresp(model), list(impresp(model, H = 'eigen'),                           impresp(model, H = 'chol')),      legend = c('none','chol','eigen'),      legend_args = list(title = 'orthogonalization', fill = NA, border = NA, bty = 'n'),      style = 'colored', ylim = 'subfig', xlab = NA)   #### plot partial autocorrelation function # overlay with the corresponding sample partial ACF  par(lend = 1) # in order to get a \"barplot\" plot(autocov(data$y, lag.max = 12, type = 'partial'),      list(autocov(model, lag.max = 12, type = 'partial')),      subfigure_main = 'delta[i_*j_](k)', parse_subfigure_main = TRUE,      style = 'bw', type = c('h','l'), pch = 19, lwd = c(15,2),      legend = c('sample', 'true'))  par(lend = 0) # reset 'lend=0'  # frequency response of the model n.f = 2^11 frr = freqresp(model, n.f = n.f)  #### plot \"gain\" subfig = plot(frr, which = 'gain',               sampling_rate = 60, unit = 'Hz',               ylim = 'row', log = 'y',               subfigure_main = 'k[i_*j_](lambda)', parse_subfigure_main = TRUE)  # mark the frequencies with the max gain! junk = unclass(frr$frr) i_max = apply(Mod(junk), MARGIN = c(1,2), FUN = which.max) f_max = matrix(60*((0:(n.f-1))/n.f)[i_max], nrow = 2, ncol = 2) for (i in (1:2)) {   for (j in (1:2)) {     subfig(i,j)     abline(v = f_max[i,j], col = 'steelblue')   } }   #### create a \"Nyquist\" plot of the frequency response plot(frr, which = 'nyquist',      xlim = 'subfig', ylim = 'subfig',      subfigure_main = 'k[i_*j_](lambda)', parse_subfigure_main = TRUE)    # compute spectral density spd = spectrald(model, n.f = 256)  #### plot the coherence # the subfigure above the diagonal shows the coherenec between # the two component proceses x[t] and y[t] # the sub figures on the diagonal show the scaled autospectra # of the two component processes x[t] and y[t]. # and the subfigure below the diagonal shows the # phase/argument of the cross spectral density between the # two component processes x[t] and y[t] plot(spd, sampling_rate = 60, unit=\"Hz\",      main = expression(spectral~density~~Gamma[i*j] == kappa[i*j]*exp(i*Phi[i*j])),      which = 'coherence',      style = 'bw')   # periodogram per = spectrald(data$y)  # smoothed periodogram sacf = autocov(data$y, lag.max = floor(sqrt(n.obs))) per2 = spectrald(sacf, n.f = 256)   #### make a plot of the absolute value of the spectral density, # of the periodogram and the smoothed periogram. # with a logarithmic y-axis # skip zero frequency, since the periodogram is zero at lambda=0 plot(spd, list(per, per2), sampling_rate = 12, unit = '/year', which = 'modulus',      log = 'y', xlim = c(1/n.obs, 0.5) * 12,  # skip zero frequency      legend = c('true','periodogram', 'smoothed per.'),      legend_args = list(bty = 'n', col = NA, lty = NA, pch = NA, lwd = 4),      style = 'colored', ylim = 'subfig',      subfigure_main = 'kappa[i_*j_] == group(\"|\", Gamma[i_*j_], \"|\")',      parse_subfigure_main = TRUE,      col = c('red', 'black', 'blue'), type = 'o', lty = c(1,0,1),      pch = c(NA, 19, NA), cex.points = 0.1)   set.seed(NULL) # reset seed"},{"path":"https://bfunovits.github.io/RLDM/reference/plot.pfilter.html","id":null,"dir":"Reference","previous_headings":"","what":"Diagnostics for Particle Filter Results — plot.pfilter","title":"Diagnostics for Particle Filter Results — plot.pfilter","text":"Plotting diagnostic functions particle filter output.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/plot.pfilter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Diagnostics for Particle Filter Results — plot.pfilter","text":"","code":"# S3 method for class 'pfilter' plot(x, type = c(\"states\", \"ess\", \"weights\", \"likelihood\"), ...)"},{"path":"https://bfunovits.github.io/RLDM/reference/plot.pfilter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Diagnostics for Particle Filter Results — plot.pfilter","text":"x Particle filter result object pf(). type Type diagnostic plot: \"states\" (filtered states credibility intervals), \"ess\" (effective sample size time), \"weights\" (histogram final weights), \"likelihood\" (log-likelihood contributions time). ... Additional arguments passed plotting functions.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/plot.pfilter.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Diagnostics for Particle Filter Results — plot.pfilter","text":"Plot (invisibly returns x).","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/plot.pfilter.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Diagnostics for Particle Filter Results — plot.pfilter","text":"","code":"# See examples in pf()"},{"path":"https://bfunovits.github.io/RLDM/reference/plot_prediction.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot Forecasts — plot_prediction","title":"Plot Forecasts — plot_prediction","text":"function plot_prediction generates standard plots forecasts forecast errors.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/plot_prediction.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot Forecasts — plot_prediction","text":"","code":"plot_prediction(   pred,   which = c(\"prediction\", \"error\", \"cusum\", \"cusum2\", \"y0\", \"u0\"),   qu = stats::qnorm(0.95),   col = NULL,   lty = NULL,   style = c(\"gray\", \"colored\", \"bw\", \"bw2\"),   parse_names = FALSE,   plot = TRUE,   ... )"},{"path":"https://bfunovits.github.io/RLDM/reference/plot_prediction.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot Forecasts — plot_prediction","text":"pred list true data forecasts, produced predict(). One may also add slot \"date\" numeric vector indices vector type Date POSIXct contains date/time values. (character string) selects type plot. qu (numeric scalar vector) determines width plotted confidence intervalls. entry NA equal zero confidence band plotted. col, lty optional (vectors ) colors line styles. style character string determines general style plot (background color, grid style, axis axis-labels colors, ...). See also rationalmatrices::style_parameters(). parse_names parse series names predictor names expression(). See grDevices::plotmath(). plot (boolean) produce plot just return \"closure\" produces plot. ... used","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/plot_prediction.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot Forecasts — plot_prediction","text":"plot=TRUE plot_prediction returns (invisibly) function, subfig(= 1) say, may used add additional graphic elements subfigures. call opar = subfig() creates new (sub) plot ()-th position suitable margins axis limits. output opar contains original graphics parameters, see graphics::par().  plot=FALSE function, plotfun(xlim = NULL) say, returned produces desired plot. optional parameter xlim = c(x1,x2) may used zoom certain time range. function plotfun returns  function/closure add graphical elements plot described .  See also examples .","code":""},{"path":[]},{"path":"https://bfunovits.github.io/RLDM/reference/plot_prediction.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot Forecasts — plot_prediction","text":"","code":"# set seed for random number generation, to get reproducable results set.seed(1609)  # generate a random state space model with three outputs and 4 states model = test_stspmod(dim = c(3,3), s = 4, bpoles = 1, bzeroes = 1)  # create a vector \"date\" with date/time info date = seq(as.POSIXct('2017-01-01'), by = 15*60, length.out = 768) n.obs = sum(date < as.POSIXct('2017-01-08')) n.ahead = length(date) - n.obs  # generate random data data = sim(model, n.obs = n.obs, s1 = NA)  # compute predictions pred = predict(model, data$y, h = c(1, 5), n.ahead = n.ahead) # add the date/time information to the list \"pred\" pred$date = date  # the default \"predictor names\" h=1, h=2, ... # don't look well, when plotted as expressions dimnames(pred$yhat)[[3]] = gsub('=','==',dimnames(pred$yhat)[[3]])  # generate some plots ####################  # a simple/compressed plot of the data p.y0 = plot_prediction(pred, which = 'y0', style = 'bw',                        parse_names = TRUE, plot = FALSE) # p.y0()  # a simple/compressed plot of the prediction errors plot_prediction(pred, which = 'u0', parse_names = TRUE)   # plot of the prediction errors (with 95% confidence intervalls) # plot_prediction(pred, which = 'error', qu = c(2,2,2), #                 parse_names = TRUE)  # plot of the true vales and the predicted values (+ 50% confidence region # for the 1-step ahead prediction and the \"out of sample\" predictions) p.y = plot_prediction(pred, qu = c(qnorm(0.75), NA, qnorm(0.75)),                       parse_names = TRUE, plot = FALSE) # subfig = p.y(xlim = date[c(n.obs-20, n.obs+20)]) # opar = subfig(1) # abline(v = mean(as.numeric(date[c(n.obs, n.obs+1)])), col = 'red') # mtext(paste(' example plot:', date()), side = 1, outer = TRUE, #       cex = 0.5, col = 'gray', adj = 0) # graphics::par(opar) # reset the graphical parameters  # CUSUM plot of the prediction errors # plot_prediction(pred, which = 'cusum', #                 style = 'gray', parse_names = TRUE)  # CUSUM2 plot of the prediction errors # plot_prediction(pred, which = 'cusum2', parse_names = TRUE)  set.seed(NULL) # reset seed  if (FALSE) { # \\dontrun{ # open a 'shiny-App' window, where we can zoom # into the plot with the prediction(s) require(shiny) zoom_plot(p.y, p.y0, 'Test zoom & scroll') } # }"},{"path":"https://bfunovits.github.io/RLDM/reference/pm_test.html","id":null,"dir":"Reference","previous_headings":"","what":"Portmanteau Test for Serial Correlation — pm_test","title":"Portmanteau Test for Serial Correlation — pm_test","text":"Test whether residuals estimated model serially correlated. test statistic $$Q = N^2\\sum_{k=1}^{K} (N-k)^{-1}\\mbox{tr} (G_k G_0^{-1} G_k' G_0^{-1})$$ \\(G_k\\) sample covariances residuals. Null correctly specified estimated model test statistic asmyptotically Chi-squared distributed \\(Km^2-\\kappa\\) degrees freedom, \\(\\kappa\\) number (free) parameters model (class).","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/pm_test.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Portmanteau Test for Serial Correlation — pm_test","text":"","code":"pm_test(u, lag.max, n.par)"},{"path":"https://bfunovits.github.io/RLDM/reference/pm_test.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Portmanteau Test for Serial Correlation — pm_test","text":"u (N--m) matrix residuals (object may coerced matrix .matrix(u)). lag.max (integer) maximum number lags. n.par (integer) number parameters estimated model.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/pm_test.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Portmanteau Test for Serial Correlation — pm_test","text":"Matrix four columns (\"lags\" number lags, \"df\" degrees freedom, \"Q\" test statistics  \"p\" p values).","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/pm_test.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Portmanteau Test for Serial Correlation — pm_test","text":"","code":"u = matrix(rnorm(100*3), nrow = 100, ncol = 3) pm_test(u, 4, 0) #>      lags        Q df         p #> [1,]    1 12.43192  9 0.1900403 #> [2,]    2 19.80063 18 0.3441554 #> [3,]    3 27.67767 27 0.4277323 #> [4,]    4 36.28794 36 0.4552286"},{"path":"https://bfunovits.github.io/RLDM/reference/poles_and_zeroes.html","id":null,"dir":"Reference","previous_headings":"","what":"Poles and Zeroes — poles and zeroes","title":"Poles and Zeroes — poles and zeroes","text":"Compute poles zeroes VARMA Statespace models. Note models describe corresponding processes $$x_t = k(B) u_t$$ \\((u_t)\\) white noise process \\(k(B)\\) rational filter (\\(B\\) denotes lag- backward shift operator). poles zeroes poles zeroes rational transfer function \\(k(z)\\) filter.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/poles_and_zeroes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Poles and Zeroes — poles and zeroes","text":"","code":"# S3 method for class 'armamod' zeroes(x, tol = sqrt(.Machine$double.eps), print_message = TRUE, ...)  # S3 method for class 'armamod' poles(x, tol = sqrt(.Machine$double.eps), print_message = TRUE, ...)  # S3 method for class 'rmfdmod' zeroes(x, tol = sqrt(.Machine$double.eps), print_message = TRUE, ...)  # S3 method for class 'rmfdmod' poles(x, tol = sqrt(.Machine$double.eps), print_message = TRUE, ...)  # S3 method for class 'stspmod' zeroes(x, tol = sqrt(.Machine$double.eps), print_message = TRUE, ...)  # S3 method for class 'stspmod' poles(x, tol = sqrt(.Machine$double.eps), print_message = TRUE, ...)"},{"path":"https://bfunovits.github.io/RLDM/reference/poles_and_zeroes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Poles and Zeroes — poles and zeroes","text":"x object represents VARMA, RMFD statespace model (.e. armamod(), rmfdmod() stspmod() object). tol Double. Default set sqrt(.Machine$double.eps). Required decide root considered \"infinity\". print_message Boolean. Default set TRUE. Prints message roots \"infinity \" discarded. ... used.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/poles_and_zeroes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Poles and Zeroes — poles and zeroes","text":"Vector poles, respectively zeroes.","code":""},{"path":[]},{"path":"https://bfunovits.github.io/RLDM/reference/predict.html","id":null,"dir":"Reference","previous_headings":"","what":"Model Predictions — predict","title":"Model Predictions — predict","text":"Compute forecasts based VARMA state space model. procedure implements simplified approach. uses formulas prediction infinite past sets unknown initial values (prior \\(t < 1\\)) simply zero. simple approach assumes model stable strictly miniphase thus disturbances \\(u_t\\) innovations process. Note also forecasts known exogenous inputs calculated, .e. \"conditional forecasts\". honest prediction, forecasts exogenous inputs used.  forecast error covariance matrix computed assumes true model used. error stems estimation model taken account.  utility function evaluate_prediction may used assess quality predictions.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/predict.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Model Predictions — predict","text":"","code":"# S3 method for class 'armamod' predict(object, y, h = 1, n.ahead = 0, ...)  # S3 method for class 'stspmod' predict(object, y, x, h = 1, n.ahead = 0, ...)  evaluate_prediction(   y,   yhat,   h,   criteria = list(\"RMSE\"),   benchmark = NULL,   samples = list(1:nrow(y)) )"},{"path":"https://bfunovits.github.io/RLDM/reference/predict.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Model Predictions — predict","text":"object rldm_varma rldm_ss object represents model. y \\((T,n)\\) matrix observed outputs (\\(y_t\\), \\(t=1,...,T\\)). h (integer) vector forecast horizons. n.ahead (integer) number time steps look ahead (sample). number also denoted \\(T_0\\). ... used. x \\((T+T_0,r)\\) matrix exogenous inputs (\\(x_t\\), \\(t=1,...,T+T_0\\)). input parameter ignored, model exogenous inputs. Note condition forecasts computed hence (model exogenous inputs) need values inputs time \\(t=T+T_0\\). yhat \\((T,n,l)\\) dimensional array forecasts. entries yhat[t,,] contain prediction \\(y_t\\). criteria list \"evaluation criteria\". See details. benchmark \\((T,n,l)\\) dimensional array \"benchmark\" forecasts. NULL naive (\\(h\\)-step ahead) forecasts used benchmark. samples list \"(sub) samples\". See details.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/predict.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Model Predictions — predict","text":"function predict returns list components yhat \\((T,n,l)\\) dimensional array h-step ahead forecast. \\(T\\) sample size, \\(n\\) dimension outputs \\(y_t\\) \\(l\\) number forecasts made, .e. length vector h. entries yhat[t,,] h[]-step ahead forecast \\(y_t\\). sigmahat \\((n,n,l)\\) dimensional array, sigmahat[,,] contains theoretical covariance matrix \\(h\\)-step ahead prediction error h=h[]. h (integer) vector forecasts horizons considered. yhat.ahead \\((T_0,n)\\) dimensional matrix, contains \"--sample\" forecasts \\(t=T+1, t=T+2,...,t=T+T_0\\). sigmahat.ahead \\((n,n,T_0)\\) dimensional array, sigmahat.ahead[,,h] contains theoretical covariance matrix \\(h\\)-step ahead prediction error. y,x original data. function evaluate_prediction  returns 4-dimensional array dimensions refer evaluation criteria, (sub) samples, predictors components output \\(y_t\\). Note evaluation criteria applied (\\(n\\)) individual components well joint vector hence 4-th dimension array size \\(n+1\\). E.g. consider \"RMSE\" \"MAE\" forecast errors, two samples (training sample test sample), 5 forecast horizons \\(h=1,\\ldots,5\\) process \\((y_t)\\) 2 components, result \\((2,2,5,3)\\)-dimensional array.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/predict.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Model Predictions — predict","text":"utility function evaluate_prediction may used asses quality given predictions. (E.g. computed predict). evaluation criteria used passed parameter criteria function. parameter list components either character strings (selection one implemented quality measures) user defined function. function takes three arguments fun(uhat, y, utilde) uhat matrix prediction errors, y matrix (corresponding) true values ytilde matrix predictions benchmark prediction procedures. allows compute relative error measures. benchmark predictions passed via parameter benchmark procedure. input parameter missing naive \\(h\\)-step ahead predictions used benchmark. (Therefore user also specify respective forecast horizons via paramater h.) following evaluation criteria implemented (\\(\\hat{y}_{}\\) denotes prediction error \\(y_{}\\) \\(\\tilde{u}_{}\\) corresponding error benchmark procedure.) MSE Mean Square Error RMSE Root Mean Square Error MAE Mean Absolute Error MdAE Median Absolute Error MAPE Mean Absolute Percentage Error \\(100 mean(|\\hat{u}_{}/y_{}|)\\) MdAPE Median Absolute Percentage Error \\(100 median(|\\hat{u}_{}/y_{}|)\\) RMdSPE Root Median Square Percentage Error \\(100 \\sqrt{median(\\hat{u}^2_{}/y^2_{})}\\) RelRMSE Relative Root Mean Square Error \\(\\sqrt{mean(\\hat{u}^2_{})}/\\sqrt{mean(\\tilde{u}^2_{})}\\) RelMAE Relative Mean Absolute Error \\(mean(|\\hat{u}_{}|)/mean(|\\tilde{u}^2_{}|)\\) PB Percentage better \\(mean(100 (|\\hat{u}_{}|< |\\tilde{u}_{}|))\\) HR Hit Rate \\(100 mean( ((\\tilde{u}_{} - \\hat{u}_{})\\tilde{u}_{} \\geq 0))\\). precise measure computes hit rate naive prediction benchmark. procedure also supports evaluation different (sub) samples. parameter samples simply list integer vectors, vector defines sub sample. E.g. daily data, one evaluate predictions different weekdays.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/predict.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Model Predictions — predict","text":"","code":"# create a \"random\" ARMA(1,1) model (stable and miniphase) model = test_armamod(dim = c(2,2), degrees = c(1,1), bpoles = 1, bzeroes = 1)  # generate data (sample size n.obs = 200, \"burn_in\" phase has length 100.) data = sim(model, n.obs = 200, n.burn_in = 100)  # predict with true model pred_true = predict(model, data$y, h = c(1,5))  # estimate AR model, order selection by AIC n.train = 110   # use the first 110 observation for estimation n.test = 90     # the last 90 observations are used for (a fair) comparison model_ar = est_ar(data$y[1:n.train,],  mean_estimate = \"zero\",                   ic = 'AIC', method = 'ols')$model  # predict with AR model pred_ar = predict(model_ar, data$y, h = c(1,5))  # estimate AR1 model (Yule-Walker) model_ar1 = est_ar(data$y[1:n.train,],  mean_estimate = \"zero\",                   penalty = -1, p.max = 1, method = 'yule-walker')$model  # predict with AR1 model pred_ar1 = predict(model_ar1, data$y, h = c(1,5))  # evaluate prediction of the AR model (with the AR1 prediction as benchmark) stats = evaluate_prediction(data$y, pred_ar$yhat, h = pred_ar$h,                             criteria = list('RMSE', 'MAE', 'PB'),                             samples = list(train = 21:n.train, test = (n.train+1):(n.train+n.test)),                             benchmark = pred_ar1$yhat)  # use array2data.frame for \"tabular\" display of the results print(array2data.frame(stats, rows = 1:3, cols = 4)) #>    criterion sample predictor      y[1]      y[2]     total #> 1       RMSE  train       h=1  2.086576  2.284865  2.187968 #> 2        MAE  train       h=1  1.605899  1.821225  1.713562 #> 3         PB  train       h=1 60.000000 60.000000 60.000000 #> 4       RMSE   test       h=1  2.145560  2.332489  2.240974 #> 5        MAE   test       h=1  1.655692  1.820500  1.738096 #> 6         PB   test       h=1 51.111111 68.888889 60.000000 #> 7       RMSE  train       h=5  3.926034  6.024364  5.084619 #> 8        MAE  train       h=5  3.060212  4.707886  3.884049 #> 9         PB  train       h=5 55.555556 54.444444 55.000000 #> 10      RMSE   test       h=5  5.143429  7.940752  6.689933 #> 11       MAE   test       h=5  4.098242  6.317676  5.207959 #> 12        PB   test       h=5 53.333333 51.111111 52.222222  # evaluate all predictions # join predictions yhat  = dbind(3, pred_true$yhat, pred_ar1$yhat, pred_ar$yhat)  # define a function to compute the \"Median Relative Absolute Error\" MdRAE_ = function(u.hat, y, u.bench){    stats::median(abs(u.hat/u.bench), na.rm = TRUE) } stats = evaluate_prediction(data$y, yhat,                             h = c(pred_true$h, pred_ar1$h, pred_ar$h),                             criteria = list('RMSE', 'MAE', MdRAE = MdRAE_),                             samples = list(train = 21:n.train, test = (n.train+1):(n.train+n.test)))  # split prediction method and forecast horizon dimnames.stats = dimnames(stats) stats = stats[,,c(1,3,5,2,4,6),] dim(stats) = c(3,2,3,2,3) dimnames(stats) = list(criterion = dimnames.stats[[1]], sample = dimnames.stats[[2]],                       model = c('true','AR1','AR'), h = paste('h=',c(1,5),sep=''),                       data = dimnames.stats[[4]])  # use array2data.frame for \"tabular\" display of the results print(array2data.frame(stats, cols = 5, rows = c(3,4,1,2))) #>    model   h criterion sample      y[1]      y[2]     total #> 1   true h=1      RMSE  train 2.1004481 2.2410891 2.1719073 #> 2    AR1 h=1      RMSE  train 2.1511088 3.5571022 2.9394085 #> 3     AR h=1      RMSE  train 2.0865760 2.2848650 2.1879680 #> 4   true h=5      RMSE  train 3.8872815 6.1180098 5.1254756 #> 5    AR1 h=5      RMSE  train 4.2226266 7.3215919 5.9764657 #> 6     AR h=5      RMSE  train 3.9260343 6.0243641 5.0846194 #> 7   true h=1       MAE  train 1.5911145 1.7118734 1.6514939 #> 8    AR1 h=1       MAE  train 1.7707579 2.6322062 2.2014820 #> 9     AR h=1       MAE  train 1.6058989 1.8212248 1.7135618 #> 10  true h=5       MAE  train 2.9814276 4.7912724 3.8863500 #> 11   AR1 h=5       MAE  train 3.2264289 5.4652213 4.3458251 #> 12    AR h=5       MAE  train 3.0602124 4.7078857 3.8840490 #> 13  true h=1     MdRAE  train 0.2102793 0.1273445 0.1805562 #> 14   AR1 h=1     MdRAE  train 0.2894324 0.1793023 0.2442877 #> 15    AR h=1     MdRAE  train 0.2351318 0.1570311 0.1972723 #> 16  true h=5     MdRAE  train 0.6447836 0.7140907 0.6620257 #> 17   AR1 h=5     MdRAE  train 0.6401162 0.8265275 0.7209322 #> 18    AR h=5     MdRAE  train 0.6116586 0.7971210 0.7208321 #> 19  true h=1      RMSE   test 2.1487276 2.3258331 2.2390321 #> 20   AR1 h=1      RMSE   test 2.1820723 3.4744623 2.9011487 #> 21    AR h=1      RMSE   test 2.1455597 2.3324893 2.2409744 #> 22  true h=5      RMSE   test 5.1315914 7.5050204 6.4287853 #> 23   AR1 h=5      RMSE   test 5.4420293 8.2481764 6.9874207 #> 24    AR h=5      RMSE   test 5.1434292 7.9407518 6.6899329 #> 25  true h=1       MAE   test 1.7040837 1.8336330 1.7688583 #> 26   AR1 h=1       MAE   test 1.7482740 2.8552381 2.3017561 #> 27    AR h=1       MAE   test 1.6556918 1.8205004 1.7380961 #> 28  true h=5       MAE   test 4.0923265 6.0219790 5.0571528 #> 29   AR1 h=5       MAE   test 4.4109470 6.5999849 5.5054660 #> 30    AR h=5       MAE   test 4.0982421 6.3176756 5.2079588 #> 31  true h=1     MdRAE   test 0.1675068 0.1563427 0.1598174 #> 32   AR1 h=1     MdRAE   test 0.1653810 0.2558399 0.2210482 #> 33    AR h=1     MdRAE   test 0.1732917 0.1466292 0.1488637 #> 34  true h=5     MdRAE   test 0.6740428 0.8374683 0.7425257 #> 35   AR1 h=5     MdRAE   test 0.6921266 0.9550540 0.8202070 #> 36    AR h=5     MdRAE   test 0.6882451 0.8602644 0.7571071 # Basic example result <- evaluate_prediction() #> Error in evaluate_prediction(): argument \"y\" is missing, with no default result #> Error: object 'result' not found"},{"path":"https://bfunovits.github.io/RLDM/reference/print.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Methods — print methods","title":"Print Methods — print methods","text":"Print Methods","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/print.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Methods — print methods","text":"","code":"# S3 method for class 'armamod' print(   x,   digits = NULL,   format = c(\"i|jz\", \"i|zj\", \"iz|j\", \"zi|j\", \"i|j|z\", \"character\"),   ... )  # S3 method for class 'rmfdmod' print(   x,   digits = NULL,   format = c(\"i|jz\", \"i|zj\", \"iz|j\", \"zi|j\", \"i|j|z\", \"character\"),   ... )  # S3 method for class 'stspmod' print(x, digits = NULL, ...)  # S3 method for class 'impresp' print(   x,   digits = NULL,   format = c(\"i|jz\", \"i|zj\", \"iz|j\", \"zi|j\", \"i|j|z\"),   ... )  # S3 method for class 'autocov' print(   x,   digits = NULL,   format = c(\"i|jz\", \"i|zj\", \"iz|j\", \"zi|j\", \"i|j|z\"),   ... )  # S3 method for class 'fevardec' print(   x,   digits = NULL,   format = c(\"i|jz\", \"i|zj\", \"iz|j\", \"zi|j\", \"i|j|z\"),   ... )  # S3 method for class 'freqresp' print(   x,   digits = NULL,   format = c(\"i|jz\", \"i|zj\", \"iz|j\", \"zi|j\", \"i|j|z\"),   ... )  # S3 method for class 'spectrald' print(   x,   digits = NULL,   format = c(\"i|jz\", \"i|zj\", \"iz|j\", \"zi|j\", \"i|j|z\"),   ... )"},{"path":"https://bfunovits.github.io/RLDM/reference/print.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Methods — print methods","text":"x RLDM object, .e. armamod(), rmfdmod(), stspmod(), impresp(), autocov(), freqresp(), spectrum() fevardec() object. digits (integer) non NULL correspondingly rounded numbers printed, see round(). format (character string) selects specific output formats. Note rationalmatrices::stsp() fevardec() objects format option. option 'character' implemented (V)ARMA models. ... parameters ignored.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/print.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print Methods — print methods","text":"invisible(x)","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/print.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Print Methods — print methods","text":"","code":"# for VARMA models six different print formats are implemented ################### m = armamod(test_lmfd(dim = c(2,2), degrees = c(1,1)), sigma_L = diag(2)) print(m, digits = 2, format = \"i|jz\") #> ARMA model [2,2] with orders p = 1 and q = 1 #> AR polynomial a(z): #>      z^0 [,1]  [,2] z^1 [,1]  [,2] #> [1,]        1     0     0.64  0.78 #> [2,]        0     1     0.47  0.40 #> MA polynomial b(z): #>      z^0 [,1]  [,2] z^1 [,1]  [,2] #> [1,]    -1.00 -0.08    -0.32 -0.08 #> [2,]    -1.46  1.37     2.18  0.40 #> Left square root of noise covariance Sigma: #>      u[1] u[2] #> u[1]    1    0 #> u[2]    0    1"},{"path":"https://bfunovits.github.io/RLDM/reference/r_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a Random Model — r_model","title":"Generate a Random Model — r_model","text":"function may used generate random state space VARMA models. main argument model template, defines type model generate, see e.g. model structures(). bounds poles /zeroes given, procedure simply generates random models model satisfies constraint found. course crude method may need large number randomly generated model.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/r_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a Random Model — r_model","text":"","code":"r_model(   template,   ntrials.max = 100,   bpoles = NULL,   bzeroes = NULL,   rand.gen = stats::rnorm,   ... )"},{"path":"https://bfunovits.github.io/RLDM/reference/r_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a Random Model — r_model","text":"template model template computed e.g. model2template(). ntrials.max Maximum number trials. bpoles, bzeroes Lower bounds poles zeroes model (stability invertibility assumptions satisfied). set NA, corresponding test skipped. rand.gen (optional) function generate random, \"free\" parameters. ... Additional parameters, passed rand.gen. particular, \"free\" paramameters generated rnorm(), standard deviation sd may set. Choosing small values sd makes easier find stable miniphase model. course \"trick\" works reference model, obtained zero parameter vector, satisfies constraints.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/r_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a Random Model — r_model","text":"Model object whose class depends template.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/r_model.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate a Random Model — r_model","text":"","code":"# Generate a random VARMA model in echelon form ############ set.seed(123)  # Compute the appropriate model template tmpl = tmpl_arma_echelon(nu = c(1,2,1))  # Create a random model, which is stable but not necessarily miniphase model = r_model(tmpl, bpoles = 1, sd = 0.5) model #> ARMA model [3,3] with orders p = 2 and q = 2 #> AR polynomial a(z): #>      z^0 [,1]      [,2]  [,3]   z^1 [,1]      [,2]      [,3]    z^2 [,1] #> [1,]        1 0.0000000     0  0.2132321 0.4475628 0.3443201  0.00000000 #> [2,]        0 1.0000000     0  0.0000000 0.4390667 0.0000000 -0.03095586 #> [3,]        0 0.6269075     1 -0.1475357 0.4107905 0.2769588  0.00000000 #>            [,2]       [,3] #> [1,]  0.0000000  0.0000000 #> [2,] -0.1529813 -0.1902355 #> [3,]  0.0000000  0.0000000 #> MA polynomial b(z): #>      z^0 [,1]      [,2]  [,3]   z^1 [,1]       [,2]       [,3]    z^2 [,1] #> [1,]        1 0.0000000     0 -0.3473535  1.0844780 -0.2014424  0.00000000 #> [2,]        0 1.0000000     0 -0.1039586  0.6039810 -0.2333277 -0.04168453 #> [3,]        0 0.6269075     1 -0.6326982 -0.5615543  0.3899826  0.00000000 #>           [,2]        [,3] #> [1,] 0.0000000  0.00000000 #> [2,] 0.1266593 -0.01427338 #> [3,] 0.0000000  0.00000000 #> Left square root of noise covariance Sigma: #>             u[1]       u[2]      u[3] #> u[1] -0.02143523  0.0000000 0.0000000 #> u[2]  0.68430114  0.7582353 0.0000000 #> u[3] -0.11288549 -0.7743764 0.2923069  # Check whether the poles satisfy the constraint min(abs(poles(model))) #> There are determinantal roots at (or close to) infinity. #> Roots close to infinity got discarded. #> [1] 1.584116 min(abs(zeroes(model))) #> There are determinantal roots at (or close to) infinity. #> Roots close to infinity got discarded. #> [1] 0.9445676"},{"path":"https://bfunovits.github.io/RLDM/reference/riccati.html","id":null,"dir":"Reference","previous_headings":"","what":"Solve a discrete time, algebraic Riccati equation — riccati","title":"Solve a discrete time, algebraic Riccati equation — riccati","text":"function solves discrete time, algebraic Riccati equation $$X = AXA' + (M -AXC')(G-CXC')^{-1}(M-AXC')'$$ square (s--s) matrix, M C' matrices dimension (s--m) G square (positive definite) matrix dimension (m--m). Given certain regularity conditions (see discussion ) solution X computed riccati positive definite matrix (size (s--s)).","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/riccati.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Solve a discrete time, algebraic Riccati equation — riccati","text":"","code":"riccati(A, M, C, G, only.X = TRUE)"},{"path":"https://bfunovits.github.io/RLDM/reference/riccati.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Solve a discrete time, algebraic Riccati equation — riccati","text":"(s--s) matrix M (s--m) matrix C (m--s) matrix G (m--m) matrix .X boolean","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/riccati.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Solve a discrete time, algebraic Riccati equation — riccati","text":"(.X) TRUE riccati just returns solution X, otherwise list slots X solution Ricatti equation B matrix \\(B = (M- AXC')\\Sigma^{-1}\\) sigma matrix \\(\\Sigma=G-CXC'\\) lambda (2m) vector eigenvalues associated generalized eigenvalue problem. first \\(m\\) entries eigenvalues \\(-BC\\).","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/riccati.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Solve a discrete time, algebraic Riccati equation — riccati","text":"(within package) function mainly used construct state space model given autocovariance function process \\((y_t)\\) rational spectral density. ACF represented four matrices (,M,C,G) \\(\\gamma(0)=G\\) \\(\\gamma(k) = CA^{k-1}M\\) \\(k>0\\). realization problem related called spectral factorization problem. matrix \\(\\) stable, pair \\((,C)\\) controllable, pair \\((,M)\\) controllable (.e. (,M,C,G) \"minimal\" realization ACF) spectral density positive definite (.e. zeros) Riccati equation (unique) solution \\(X\\) positive definite matrix \\(- (M-AXC')(G-CXC')^{-1}C\\) stable. process  \\((y_t)\\) state space representation parameters \\((,B,C,D=)\\), \\(B=(M-AXC')\\Sigma^{-1}\\) \\(\\Sigma=(G-CXC')\\) innovation covariance. solution computed via (2m--2m) dimensional generalized eigenvalue problem, turn solved QZ decomposition. See QZ::qz.dgges() QZ::qz.dtgsen(). eigenvalues modulus less one eigenvalues matrix \\(-BC\\). addition riccati also used compute stochastically balanced realization state space model, see rationalmatrices::grammians() rationalmatrices::balance(). Note function mainly used utility function therefore checks given input parameters performed.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/riccati.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Solve a discrete time, algebraic Riccati equation — riccati","text":"","code":"# create a \"random\" state space model, which satisfies the # stability and the (strict) miniphase assumption m = 2 # number of outputs s = 4 # number of states  model = r_model(template = tmpl_stsp_full(m, m, s),                 bpoles = 1, bzeroes = 1, sd = 0.25) # scale sigma model$sigma_L = model$sigma_L / sqrt(sum(diag(model$sigma_L %*% t(model$sigma_L))))  # extract the model parameter matrices A = model$sys$A B = model$sys$B C = model$sys$C sigma = model$sigma_L %*% t(model$sigma_L)  # compute the variance of the state P = A P A' + B sigma B' P = lyapunov(A, B %*% sigma %*% t(B))  # variance of the output y[t]: G = C P C' + sigma G = C %*% P %*% t(C) + sigma # covariance between s[t+1] and y[t]: M = A P C' + B sigma M = A %*% P %*% t(C) + B %*% sigma  # check that P solves the Riccati equation P = APA' + (M -APC')(G-CPC')^{-1}(M-APC')' all.equal(P,           A %*% P %*% t(A) +             (M - A %*% P %*% t(C)) %*% solve(G - C%*% P %*% t(C), t(M - A %*% P %*% t(C)))) #> [1] TRUE  # compute P from the Riccati equation: P = APA' + (M -APC')(G-CPC')^{-1}(M-APC')' out = riccati(A, M, C, G, only.X=FALSE)  # check the solution all.equal(P, out$X) #> [1] TRUE all.equal(B, out$B) #> [1] TRUE all.equal(sigma, out$sigma) #> [1] TRUE  # eigenvalues of (A-BC) ( <=> reciprocals of the zeroes of the system) lambda = eigen(A - B %*% C, only.values=TRUE)$values all.equal(sort(lambda), sort(out$lambda[1:s])) #> [1] TRUE"},{"path":[]},{"path":"https://bfunovits.github.io/RLDM/reference/rmfdmod.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Constructor for RMFD Models — rmfdmod","text":"","code":"rmfdmod(sys, sigma_L = NULL, names = NULL, label = NULL)"},{"path":"https://bfunovits.github.io/RLDM/reference/rmfdmod.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Constructor for RMFD Models — rmfdmod","text":"sys rationalmatrices::rmfd() object sigma_L Left-factor noise covariance, .e. covariance \\(\\sigma\\) obtained sigma_L * t(sigma_L). sigma_L vector dimension \\(n\\), \\(n\\) input dimension, diagonal elements parametrized. vector dimension \\(n^2\\), elements sigma_L filled column column. names optional vector character strings label optional character string","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/rmfdmod.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Constructor for RMFD Models — rmfdmod","text":"Object class rmfdmod.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/rmfdmod.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Constructor for RMFD Models — rmfdmod","text":"right-matrix fraction description (RMFD) plus parameterisation noise covariance. (Hannan Deistler 2012) , RMFDs also called dynamic adjustment forms. Internally, MFDs lists slots sys, sigma_L, names, label. Many generic functions construct derived objects like autocovariance autocov() yet implemented rmfdmod objects.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/rmfdmod.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Constructor for RMFD Models — rmfdmod","text":"Hannan EJ, Deistler M (2012). Statistical Theory Linear Systems,  Classics Applied Mathematics. SIAM, Philadelphia. Originally published: John Wiley & Sons, New York, 1988.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/rmfdmod.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Constructor for RMFD Models — rmfdmod","text":"","code":"y = rmfdmod(sys = test_rmfd(dim = c(3,2), degrees = c(2,2))) y #> RMFD model [3,2] with orders p = 2 and q = 2 #> right factor polynomial c(z): #>      z^0 [,1]  [,2]   z^1 [,1]       [,2]   z^2 [,1]       [,2] #> [1,]        1     0 -0.6002596  1.5326106 -1.0264209  0.2568837 #> [2,]        0     1  2.1873330 -0.2357004 -0.7104066 -0.2466919 #> left factor polynomial d(z): #>         z^0 [,1]       [,2]   z^1 [,1]        [,2]   z^2 [,1]       [,2] #> [1,] -0.34754260 -0.7849045  0.9189966 -1.61788271  0.3011534 -0.8497043 #> [2,] -0.95161857 -1.6679419 -0.5753470 -0.05556197  0.1056762 -1.0241288 #> [3,] -0.04502772 -0.3802265  0.6079643  0.51940720 -0.6407060  0.1176466 #> Left square root of noise covariance Sigma: #>      u[1] u[2] #> u[1]    1    0 #> u[2]    0    1"},{"path":"https://bfunovits.github.io/RLDM/reference/sim.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate from a State Space or VARMA Model — sim","title":"Simulate from a State Space or VARMA Model — sim","text":"Generate time series given process model.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/sim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate from a State Space or VARMA Model — sim","text":"","code":"sim(model, n.obs, rand.gen, n.burnin, ...)  # S3 method for class 'armamod' sim(model, n.obs, rand.gen = stats::rnorm, n.burnin = 0, ...)  # S3 method for class 'stspmod' sim(model, n.obs, rand.gen = stats::rnorm, n.burnin = 0, a1 = NULL, ...)"},{"path":"https://bfunovits.github.io/RLDM/reference/sim.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate from a State Space or VARMA Model — sim","text":"model either armamod() stspmod() object. n.obs sample size (\\(N\\)). rand.gen (optional) function generate disturbances \\(u_t\\). Note rand.gen() generate iid sample random variable mean zero variance one. n.burnin length initial \"burn-\" phase (denoted \\(N_0\\)). ... used. a1 (otional) vector initial state (start \"burn--phase\"). default a1 = NULL means zero initial state used. a1 = NA random initial state according state covariance generated. rand.gen used. model stable covariance defined procedure break .","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/sim.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate from a State Space or VARMA Model — sim","text":"List slots y \\((N,m)\\) matrix generated outputs. u \\((N,n)\\) matrix noise. \\((N+1,s)\\) matrix generated states (\\(a_t\\), \\(t=1,...,N+1\\)). Note matrix (\\(N+1\\)) rows! slot present state space models.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/sim.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate from a State Space or VARMA Model — sim","text":"order generate \"stationary\" trajectory (stable model) one chose suitable initial starting values. quite easy, particular VARMA models. simple remedy, procedure offers option \"burn-\" phase. length phase chosen user. state space model, value state first time point may passed procedure parameter a1. a1 = NULL (default value) zero vector used. a1 = NA random initial state according state covariance generated. model stable, covariance defined procedure break . rand.gen used. user like control disturbances initial values, solve_de() may used.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/sim.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate from a State Space or VARMA Model — sim","text":"","code":"# Random Walk ############################################################################ set.seed(123) model = armamod(lmfd(a = c(1,-1), b = 1)) # generate outputs \"y\" n.obs = 100 data = sim(model, n.obs = n.obs, y0 = 1) plot(data$y, type = 'l')   # bivariate ARMA(2,1) model ############################################################## model = test_armamod(dim = c(2,2), degrees = c(2,1), bpoles = 1, bzeroes = 1) # generate outputs \"y\" with zero initial conditions n.obs = 50 data =  sim(model, n.obs = n.obs) # reconstruct noise \"u\" from given outputs \"y\" data1 = solve_inverse_de(model$sys, y = data$y) all.equal(data$u, data1$u) #> [1] TRUE  # bivariate state space model with 5 states ############################################## model = test_stspmod(dim = c(2,2), s = 5, bpoles = 1, bzeroes = 1) # generate outputs \"y\" with random initial state a[1] n.obs = 50 data =  sim(model, n.obs = n.obs, a1 = NA) # reconstruct noise \"u\" from given outputs \"y\" data1 = solve_inverse_de(model$sys, y = data$y, a1 = data$a[1,]) all.equal(data$u, data1$u) #> [1] TRUE"},{"path":"https://bfunovits.github.io/RLDM/reference/solve_ARMA.html","id":null,"dir":"Reference","previous_headings":"","what":"Solve ARMA system — solve_ARMA","title":"Solve ARMA system — solve_ARMA","text":"Compute outputs ARMA(p, q) systems form $$y_t = a_1 y_{t-1} + ... + a_p y_{t-p} + b_0 u_t + \\cdots + b_q u_{t-q}$$","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/solve_ARMA.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Solve ARMA system — solve_ARMA","text":"","code":"solve_ARMA_R(a, b, u, y, t0)"},{"path":"https://bfunovits.github.io/RLDM/reference/solve_ARMA.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Solve ARMA system — solve_ARMA","text":"\\((m, mp)\\) matrix \\((a_p,...,a_1)\\). b \\((m, n(q+1))\\) matrix \\((b_0,...,b_q\\). u \\((n, N)\\) matrix inputs \\((u_1,...,u_N\\). y \\((m, N)\\) matrix outputs \\((y_1,...,y_N\\). t0 integer, start iteration t=t0.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/solve_ARMA.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Solve ARMA system — solve_ARMA","text":"R implementation solve_ARMA_R returns matrix y computed outputs. RcppArmadillo implementation returns NULL overwrites input argument y!","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/solve_ARMA.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Solve ARMA system — solve_ARMA","text":"Values \\(y_t\\), \\(u_t\\) \\(t\\leq 0\\) implicitly set zero. However, start iteration \\(t_0>1\\) can enforce non-zero initial values. routines used internally hence check arguments. require \\(m > 0\\), \\(p \\geq 0\\), \\(n \\geq 0\\), \\((q+1) \\geq 0\\) \\(1 \\leq t_0 \\leq N\\). Note also RcppArmadillo implementation overwrites input argument y. Use procedure care! Note non standard arguments: order AR coefficients reversed. data matrices organized column-wise (avoid memory shuffling)!","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/solve_ARMA.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Solve ARMA system — solve_ARMA","text":"","code":"# Basic example result <- solve_ARMA_R() #> Error in solve_ARMA_R(): argument \"y\" is missing, with no default result #> Error: object 'result' not found"},{"path":"https://bfunovits.github.io/RLDM/reference/solve_RMFD_R.html","id":null,"dir":"Reference","previous_headings":"","what":"Solve RMFD system for given inputs — solve_RMFD_R","title":"Solve RMFD system for given inputs — solve_RMFD_R","text":"Compute outputs \\(y_t\\) RMFD(p, q) systems form $$y_t = d_0 v_t + d_1 v_{t-1} + \\cdots + d_q v_{t-q}$$ $$v_t + c_1 v_{t-1} + \\cdots + c_p v_{t-p} = u_t$$ given inputs \\(u_t\\) contained column-wis data matrix data_input, see .","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/solve_RMFD_R.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Solve RMFD system for given inputs — solve_RMFD_R","text":"","code":"solve_RMFD_R(polm_c, polm_d, data_input, t0 = 1)"},{"path":"https://bfunovits.github.io/RLDM/reference/solve_RMFD_R.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Solve RMFD system for given inputs — solve_RMFD_R","text":"polm_c, polm_d rationalmatrices::polm objects. Describe jointly RMFD. \\(c(z)\\) square, identity zero-lag coefficient, coefficients reversed procedure: \\((c_p,...,c_1)\\). \\(d(z)\\) might tall, zero-lag coefficient matrix general free. data_input \\((n, N)\\) matrix inputs \\((u_1,...,u_N\\). t0 integer, start iteration t=t0.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/solve_RMFD_R.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Solve RMFD system for given inputs — solve_RMFD_R","text":"R implementation solve_RMFD_R() returns matrix y computed outputs. $$y_t = d(z) c(z)^{-1} u_t$$ internal RcppArmadillo implementation returns NULL overwrites input argument. Note RcppArmadillo implementation different user interface (intended internal use ).","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/solve_RMFD_R.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Solve RMFD system for given inputs — solve_RMFD_R","text":"Values \\(y_t\\), \\(u_t\\) \\(t\\leq 0\\) implicitely set zero. However, start iteration \\(t_0>1\\) can enforce non-zero initial values. routines used internally hence check arguments. require number outputs positive \\(m > 0\\), number inputs non-negative \\(n \\geq 0\\), degree \\(c(z)\\) %>%  non-negative \\(p \\geq 0\\), degree \\(d(z)\\) unrestricted, .e. \\((q+1) \\geq 0\\), starting value sample size \\(1 \\leq t_0 \\leq N\\) holds. Note also RcppArmadillo implementation overwrites input argument y. Use procedure care! Note non standard arguments: polynomial matrices \\(c(z)\\) \\(d(z)\\) saved \"wide\" matrices. order coefficients \\(c(z)\\) reversed \\(c_0\\) coefficient (required identity matrix). order coefficients \\(d(z)\\) usual, \\(d_0\\) available . data matrices organized columnwise (avoid memory shuffling)!","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/solve_RMFD_R.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Solve RMFD system for given inputs — solve_RMFD_R","text":"","code":"# Basic example result <- solve_RMFD_R() #> Error in solve_RMFD_R(): argument \"polm_c\" is missing, with no default result #> Error: object 'result' not found"},{"path":"https://bfunovits.github.io/RLDM/reference/solve_de.html","id":null,"dir":"Reference","previous_headings":"","what":"Solve (linear) Difference Equations — solve_de","title":"Solve (linear) Difference Equations — solve_de","text":"procedure solve_de() solves difference equations associated (V)ARMA models $$a_0 y_t + a_1 y_{t-1} + \\cdots + a_p y_{t-p} = b_0 u_t  + b_1 u_{t-1} + ... b_1 u_{t-q}$$ state space models $$a_{t+1} = a_t + B u_t \\mbox{ } y_t = C a_t + D u_t.$$","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/solve_de.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Solve (linear) Difference Equations — solve_de","text":"","code":"solve_de(sys, u, ...)  # S3 method for class 'stsp' solve_de(sys, u, a1 = NULL, ...)  # S3 method for class 'lmfd' solve_de(sys, u, u0 = NULL, y0 = NULL, ...)  # S3 method for class 'rmfd' solve_de(sys, u, u0 = NULL, y0 = NULL, ...)  solve_inverse_de(sys, y, ...)  # S3 method for class 'stsp' solve_inverse_de(sys, y, a1 = NULL, ...)  # S3 method for class 'lmfd' solve_inverse_de(sys, y, u0 = NULL, y0 = NULL, ...)  # S3 method for class 'rmfd' solve_inverse_de(sys, y, u0 = NULL, y0 = NULL, ...)"},{"path":"https://bfunovits.github.io/RLDM/reference/solve_de.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Solve (linear) Difference Equations — solve_de","text":"sys rationalmatrices::lmfd() rationalmatrices::stsp() object describes difference equation. u \\((N,n)\\) matrix noise (\\(u_t\\), \\(t=1,...,N\\)). ... used. a1 \\(m\\) dimensional vector initial state \\(a_1\\). a1=NULL zero vector used. u0 \\((h,n)\\) dimensional matrix starting values disturbances \\((u_{1-h}, \\ldots, u_{-1}, u_0)\\). Note last row corresponds \\(u_0\\), last one row \\(u_{-1}\\) . \\(h>q\\) last \\(q\\) rows u0 used. case \\(h<q\\) \"missing\" initial values set zero vectors.  default value u0=NULL sets initial values \\(u_t\\), \\(t \\leq 0\\) equal zero vectors. y0 \\((h,m)\\) dimensional matrix starting values outputs \\((y_{1-h}, \\ldots, y_{-1}, y_0)\\). (optional) parameter interpreted analogously u0. y \\((N,m)\\) matrix outputs (\\(y_t\\), \\(t=1,...,N\\)).","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/solve_de.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Solve (linear) Difference Equations — solve_de","text":"List slots y \\((N,n)\\) matrix (computed) outputs. u \\((N,n)\\) matrix (computed) noise. \\((N+1,n)\\) matrix (computed) states (\\(a_t\\), \\(t=1,...,N+1\\)). Note matrix (\\(N+1\\)) rows! slot present state space models.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/solve_de.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Solve (linear) Difference Equations — solve_de","text":"solve_de() computes outputs \\(y_t\\) \\(t=1,\\ldots,N\\) given disturbances \\(u_t\\) \\(t=1,\\ldots,N\\). starting values  (\\(u_t\\) \\(y_t\\) \\(t\\leq 0\\) VARMA models \\(a_1\\) state space models) may given optional arguments. default use zero vectors. reverse direction, .e. reconstruct disturbances outputs given, function solve_inverse_de may used. case system must square matrix \\(D\\) respectively \\(b_0\\) must invertible. functions mainly intended internal use hence basic checks input parameters performed.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/solve_de.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Solve (linear) Difference Equations — solve_de","text":"","code":"### generate a random ARMA(2,1) model (with two outputs) ######### model = test_armamod(dim = c(2,2), degrees = c(2,1),                      digits = 2, bpoles = 1, bzeroes = 1)  # generate random noise sequence (sample size N = 100) u = matrix(rnorm(100*2), nrow = 100, ncol = 2)  # generate random initial values u0 = matrix(rnorm(2), nrow = 1, ncol = 2) # u[0] y0 = matrix(rnorm(2), nrow = 1, ncol = 2) # y[0]  # compute outputs \"y[t]\" # note that y0 has only one row, thus y[-1] is set to zero! data = solve_de(model$sys, u = u, y0 = y0, u0 = u0)  # we can reconstruct the noise \"u\" from given outputs \"y\" data1 = solve_inverse_de(model$sys, y = data$y, u0 = u0, y0 = y0) all.equal(data$u, data1$u) #> [1] TRUE  ### generate a random state space model (3 outputs and 4 states) ## model = test_stspmod(dim = c(3,3), s = 4,                      digits = 2, bpoles = 1, bzeroes = 1)  # generate random noise sequence (sample size N = 100) u = matrix(rnorm(100*3), nrow = 100, ncol = 3)  # generate random initial state a[1] a1 = rnorm(4)  # compute outputs \"y[t]\" data = solve_de(model$sys, u = u, a1 = a1)  # we can reconstruct the noise \"u\" from given outputs \"y\" data1 = solve_inverse_de(model$sys, y = data$y, a1 = data$a[1,]) all.equal(data$u, data1$u) #> [1] TRUE  # Basic example result <- solve_inverse_de() #> Error in solve_inverse_de(): argument \"sys\" is missing, with no default result #> Error: object 'result' not found"},{"path":"https://bfunovits.github.io/RLDM/reference/solve_inverse_RMFD_R.html","id":null,"dir":"Reference","previous_headings":"","what":"Obtain Inputs of RMFD System for Given Data — solve_inverse_RMFD_R","title":"Obtain Inputs of RMFD System for Given Data — solve_inverse_RMFD_R","text":"Compute inputs \\(u_t\\) RMFD(p, q) systems form $$y_t = d_0 v_t + d_1 v_{t-1} + \\cdots + d_q v_{t-q}$$ $$v_t + c_1 v_{t-1} + \\cdots + c_p v_{t-p} = u_t$$ given data \\(y_t\\) contained column-wise matrix data_output, see .","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/solve_inverse_RMFD_R.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Obtain Inputs of RMFD System for Given Data — solve_inverse_RMFD_R","text":"","code":"solve_inverse_RMFD_R(polm_c, polm_d, data_output, t0 = 1)"},{"path":"https://bfunovits.github.io/RLDM/reference/solve_inverse_RMFD_R.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Obtain Inputs of RMFD System for Given Data — solve_inverse_RMFD_R","text":"polm_c, polm_d polm objects. Jointly, reprsent RMFD. \\(c(z)\\) square, identity zero-lag coefficient. \\(d(z)\\) might tall, zero-lag coefficient matrix general free. data_output \\((m, N)\\) matrix outputs \\((y_1,...,y_N\\). t0 integer, start iteration t=t0.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/solve_inverse_RMFD_R.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Obtain Inputs of RMFD System for Given Data — solve_inverse_RMFD_R","text":"R implementation solve_inverse_RMFD_R returns matrix u computed inputs $$u_t = d^{+}(z) c(z) y_t$$ columns. internal RcppArmadillo implementation returns NULL overwrites input argument! Note RcppArmadillo implementation different user interface (intended internal use ).","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/solve_inverse_RMFD_R.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Obtain Inputs of RMFD System for Given Data — solve_inverse_RMFD_R","text":"Values \\(y_t\\), \\(u_t\\) \\(t\\leq 0\\) implicitely set zero. However, start iteration \\(t_0>1\\) can enforce non-zero initial values. routines used internally hence check arguments. require number outputs positive \\(m > 0\\), number inputs non-negative \\(n \\geq 0\\), degree \\(c(z)\\) non-negative \\(p \\geq 0\\), degree \\(d(z)\\) unrestricted, .e. \\((q+1) \\geq 0\\), starting value sample size \\(1 \\leq t_0 \\leq N\\) holds. Note also RcppArmadillo implementation overwrites input argument y. Use procedure care! Note non standard arguments: polynomial matrices \\(c(z)\\) \\(d(z)\\) saved \"wide\" matrices. order coefficients \\(c(z)\\) reversed \\(c_0\\) coefficient (required identity matrix). order coefficients \\(d(z)\\) usual, \\(d_0\\) available . data matrices organized columnwise (avoid memory shuffling)!","code":""},{"path":[]},{"path":"https://bfunovits.github.io/RLDM/reference/solve_inverse_RMFD_R.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Obtain Inputs of RMFD System for Given Data — solve_inverse_RMFD_R","text":"","code":"# Basic example result <- solve_inverse_RMFD_R() #> Error in solve_inverse_RMFD_R(): argument \"polm_c\" is missing, with no default result #> Error: object 'result' not found"},{"path":"https://bfunovits.github.io/RLDM/reference/spectrald.html","id":null,"dir":"Reference","previous_headings":"","what":"Spectral Density — spectrald","title":"Spectral Density — spectrald","text":"Compute spectral density ARMA process process defined state space model.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/spectrald.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spectral Density — spectrald","text":"","code":"spectrald(obj, n.f, ...)  # S3 method for class 'armamod' spectrald(obj, n.f = 128, ...)  # S3 method for class 'stspmod' spectrald(obj, n.f = 128, ...)  # S3 method for class 'autocov' spectrald(obj, n.f = 128, ...)  # S3 method for class 'impresp' spectrald(obj, n.f = 128, ...)  # Default S3 method spectrald(obj, n.f = NULL, demean = TRUE, ...)"},{"path":"https://bfunovits.github.io/RLDM/reference/spectrald.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Spectral Density — spectrald","text":"obj armamod(), stspmod(), autocov(), impresp() object \"time series\" object, .e. object may coerced data matrix y = .matrix(obj). n.f number frequencies. ... used. demean (logical) data demeaned computing periodogram?","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/spectrald.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Spectral Density — spectrald","text":"freqresp object, .e. list slots spd rationalmatrices::zvalues() object. names (m)-dimensional character vector NULL. optional slot stores names components time series/process. label character string NULL. n.obs (optional) integer NULL.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/spectrald.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Spectral Density — spectrald","text":"spectral density stationary process absolutely summable autocovariance function \\((\\gamma_j)\\) given $$ \\Gamma(\\lambda) = \\frac{1}{2\\pi}\\sum_{j=-\\infty}^{\\infty} \\gamma_j e^{-\\lambda j}. $$ ARMA process, process defined state space model spectral density equal $$ \\Gamma(\\lambda) = \\frac{1}{2\\pi} K(\\lambda) \\Sigma K^*(\\lambda) $$ \\(\\Sigma\\) noise covariance, \\(K()\\) frequency response model \\(K^*(\\lambda)\\) Hermitean transpose \\(K(\\lambda)\\). See also autocov() freqresp(). Note \\(\\Gamma()\\) (factor \\(2\\pi\\)) discrete-time Fourier transform (DTFT) autocovariance function therefore ACF \\(\\gamma_j\\) may reconstructed spectral density via inverse DTFT $$ \\gamma_j = \\int_{-\\pi}^{\\pi} \\Gamma(\\lambda) e^{\\lambda j} d\\lambda $$ S3 methods spectrald.* evaluate spectral density function grid angular frequencies \\(\\lambda_j = 2\\pi j/N\\), \\(j=0,\\ldots,N-1\\) store result spectrald object. several possible ways specify process. One may provide ARMA (armamod) respectively state space model (stspmod), autocovariance function (autocov) impulse response function (impresp) maps noise outputs. Note however, given autocov impresp object computed spectral density approximation true spectral density since finite number covariances respectively impulse response coefficients given. type autocovariance function (\"covariances\", \"correlations\" \"partial correlations\") irrelevenat since procedure alwayas uses slot \"gamma\" contains covariances. default method spectrald.default assumes obj \"time series\" object tries coerce object data matrix via y = .matrix(obj). case procedure computes periodogram simple estimate spectral density. periodgram may also computed call spectrald(autocov(obj, max.lag = n.obs-1)), .e. first computing sample auto covariance function computing corresponding spectral density. Note use different scaling stats::[spectrum][stats::spectrum] routine.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/spectrald.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Spectral Density — spectrald","text":"","code":"#' ### generate random 3-dimensional ARMA(1,1) model # \"bpoles = 1.1\" implies that the poles have moduli larger than 1.1 # and therefore the impulse response coefficients decay with a rate (1.1)^k arma_model = test_armamod(dim = c(3,3), degrees = c(1,1), bpoles = 1.1)  # spectral density spd = spectrald(arma_model)  # compute the spectral density via the impulse response spd1 = spectrald(impresp(arma_model, lag.max = 100))  # since the impulse response quickly decays # the \"truncated\" spectral density should be close to the true one all.equal(spd, spd1) #> [1] TRUE  # compute the spectral density via the autocovariance function spd1 = spectrald(autocov(arma_model, lag.max = 100))  # since the ACF quickly decays # the \"truncated\" spectral density should be close to the true one all.equal(spd, spd1) #> [1] TRUE  # create an equivalent state space model stsp_model = as.stspmod(arma_model)  # of course the state space model gives the same spectrum # as the original ARMA model spd1 = spectrald(stsp_model) all.equal(spd, spd1) #> [1] TRUE"},{"path":"https://bfunovits.github.io/RLDM/reference/str.html","id":null,"dir":"Reference","previous_headings":"","what":"Display the Structure of Objects — str methods","title":"Display the Structure of Objects — str methods","text":"Display Structure Objects","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/str.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Display the Structure of Objects — str methods","text":"","code":"# S3 method for class 'armamod' str(object, ...)  # S3 method for class 'stspmod' str(object, ...)  # S3 method for class 'impresp' str(object, ...)  # S3 method for class 'autocov' str(object, ...)  # S3 method for class 'fevardec' str(object, ...)  # S3 method for class 'freqresp' str(object, ...)  # S3 method for class 'spectrald' str(object, ...)"},{"path":"https://bfunovits.github.io/RLDM/reference/str.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Display the Structure of Objects — str methods","text":"object object ... used","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/str.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Display the Structure of Objects — str methods","text":"invisible(NULL)","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/stspmod.html","id":null,"dir":"Reference","previous_headings":"","what":"Creator for stspmod class — stspmod","title":"Creator for stspmod class — stspmod","text":"Creator stspmod class","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/stspmod.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Creator for stspmod class — stspmod","text":"","code":"stspmod(sys, sigma_L = NULL, names = NULL, label = NULL)"},{"path":"https://bfunovits.github.io/RLDM/reference/stspmod.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Creator for stspmod class — stspmod","text":"sys rationalmatrices::stsp() object sigma_L noise covariance left names optional vector character strings label optional chracter string","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/stspmod.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Creator for stspmod class — stspmod","text":"Object class stspmod.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/stspmod.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Creator for stspmod class — stspmod","text":"","code":"x = stspmod(sys = test_stsp(dim = c(2,2), s = 2), sigma_L = diag(2)) x #> state space model [2,2] with s = 2 states #>            s[1]        s[2]      u[1]       u[2] #> s[1] -0.2504141  0.24679921 0.2551648  0.5368560 #> s[2]  1.5495553 -0.73677154 0.2774468 -0.4604856 #> x[1] -1.0971396 -1.28000894 1.0000000  0.0000000 #> x[2]  0.9255112  0.07664366 0.0000000  1.0000000 #> Left square root of noise covariance Sigma: #>      u[1] u[2] #> u[1]    1    0 #> u[2]    0    1"},{"path":"https://bfunovits.github.io/RLDM/reference/subspace-helpers.html","id":null,"dir":"Reference","previous_headings":"","what":"Subspace Helper Methods — subspace helpers","title":"Subspace Helper Methods — subspace helpers","text":"procedure implement two subspace algorithms estimation state space models, AOKI method, described (Aoki 1990)  CCA algorithm (see e.g. (Dahlen Scherrer 2004)  (Bauer 2001) ). subspace algorithms center weighted Hankel matrix $$(R_f')^{-T} H_{fp} R_p^{-1}$$ block Hankel matrix \\(H_{fp}\\) covariance \"past\" \\((y_{t-1}',\\cdots,y_{t-p}')'\\) \"future\" \\((y_{t}',\\cdots,y_{t+f-1}')'\\) \\(R_f\\) \\(R_p\\) cholesky factors covariance matrices \"future\" \"past\" respectively. singular values weighted Hankel matrix canonical correlation coefficients past future. Note implementation always sets \\(f = p+1\\).","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/subspace-helpers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Subspace Helper Methods — subspace helpers","text":"","code":"est_stsp_aoki(   gamma,   s.max,   p,   estorder = estorder_SVC,   keep_models = FALSE,   n.obs = NULL,   ... )  est_stsp_cca(   gamma,   s.max,   p,   estorder = estorder_SVC,   keep_models = FALSE,   n.obs = NULL,   ... )  est_stsp_cca_sample(   y,   s.max,   p,   estorder = estorder_SVC,   keep_models = FALSE,   mean_estimate = c(\"sample.mean\", \"zero\"),   ... )"},{"path":"https://bfunovits.github.io/RLDM/reference/subspace-helpers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Subspace Helper Methods — subspace helpers","text":"gamma \\((m,m,L+1)\\)-dimensional array (sample) autocovariance function. s.max (integer) maximum possible order. p (integer) number block columns Hankel matrix (size \"past\") estorder function, estimate order system. keep_models (boolean) function return list estimated system order 0:s.max? n.obs sample size \\(N\\). ... additional parameters, passed order estimation routine. y \\((N,m)\\)-dimensional matrix object, may coerced matrix .matrix{y}. mean_estimate Character string giving method used estimate mean \\(\\mu = E y_t\\). Default use sample mean.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/subspace-helpers.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Subspace Helper Methods — subspace helpers","text":"List slots: model rationalmatrices::stsp() object, represents estimated state space model. models either NULL (!keep_models) list parameters estimated models orders (s=0:s.max+1). slot may e.g. used estimate model order user defined model selection procedure. s (integer) estimate model order. info list information data design parameters estimation procedure. stats ((s.max+1)--5)-dimensional matrix statistics (estimated) state space models.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/subspace-helpers.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Subspace Helper Methods — subspace helpers","text":"AOKIs method realization algorithm, .e. reconstructs underlying state space model (population) autocovariance function. end Riccati equation solved, see riccati(). estimated ACF fed algorithm one obtains estimate state space model. However note may fail (particular Riccati equation may positive definite solution) estimate ACF positive definite, Hankel matrix small state dimension correct. CCA method estimates state space model first constructing estimate states. parameter matrices estimated via simple LS regressions. procedure give \"true\" model, even case population ACF used. However, \"distance\" true model estimated model converges zero, estimate ACF converges population ACF size \\(p\\) Hankel matrix converges infinity. two implementations CCA method: routine est_stsp_cca_sample() operates directly supplied data. routine est_stsp_cca() uses (estimated) autocovariance function. algorithms may also used simple \"model reduction algorithms\". want approximate high dimensional state space model model lower order, may proceed follows. First compute ACF high dimensional model fed ACF subspace routines est_stsp_cca est_stsp_aoki, however setting maximum order s.max value less true order. Order Estimation order estimation based Hankel singular values \\(\\sigma_s\\) /log det values estimated noise covariance matrices \\(\\ln\\det \\hat{\\Sigma}_s\\). Using Hankel singular values advantage one model estimated, whereas otherwise estimates models orders \\(s=0,\\ldots,s_{\\max}\\) computed. order exploit (small) advantage singular values based criteria order estimation runs follows: First procedures call  estorder(s.max, Hsv, n.par, m, n.obs, Hsize=c(f,p), ...)  Hsv \\(pm\\) dimensional vector Hankel singular values n.par \\((s_{\\max}+1)\\) dimensional vector respective number parameters models orders \\(s=0,\\ldots,s_{\\max}\\). call returns estimate order procedures estimate corresonding state space model. call fails (.e returns NULL) procedures estimate models orders \\(s_{\\max}\\) corresponding noise covariance matrices. order estimated calling  estorder(s.max = s.max, Hsv, lndetSigma, n.par, m, n.obs, Hsize, ...)  lndetSigma vector log det values estimated noise covariance matrices (\\(\\ln\\det \\hat{\\Sigma}_s\\)). package offers predefined order selection procedures (see also subspace order estimates): estorder_max(s.max, ...) simply returns maximum order s.max considered. estorder_rkH(s.max, Hsv, tol, ...) estimates order estimate rank Hankel matrix. estorder_MOE(s.max, Hsv, ...) estimates order searching \"gap\" singular values. estorder_SVC(s.max, Hsv, n.par, n.obs, Hsize, penalty, ...) implements called Singular Value Criteria, see (Bauer 2001) : $$svc(s) = \\sigma_{s+1}^2 + c(N)d(s)/N$$ \\(\\sigma_s\\) \\(s\\)-th singular value weighted Hankel marix, \\(N\\) sample size, \\(d(s) = 2ms\\) denotes number parameters state space model \\(s\\) states (\\(m\\) outputs) \\(c(N)\\)) \"penalty\" (depending sample size). order estimation procedures use Hankel singular values, whereas following procedure based estimated noise covariances. estorder_IVC(s.max, lndetSigma, n.par, n.obs, penalty, ...) estimates order via information criterion form $$ivc(s) = \\ln\\det\\hat\\Sigma_{s} + c(N)d(s)/N$$ \\(\\hat\\Sigma_s\\) estimate noise covariace matrix obtained model order \\(s\\), \\(d(s)\\) denotes number parameters \\(c(N)\\) \"penalty\" (depending sample size). estorder_SVC estorder_IVC (optional) parameter penalty controls penalty term \\(c(N)\\). Note also  keep_models==TRUE estimation procedures compute models even case Hankel singular value based selection criterion.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/subspace-helpers.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Subspace Helper Methods — subspace helpers","text":"Bauer D (2001). “Order estimation subspace methods.” Automatica, 37(10), 1561 - 1573. doi:10.1016/S0005-1098(01)00118-2 .","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/subspace-helpers.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Subspace Helper Methods — subspace helpers","text":"","code":"set.seed(123) # Generate example data model <- stspmod(sys = test_stsp(dim = c(2,2), s = 2), sigma_L = diag(2)) y <- sim(model, n.obs = 100)$y  # Run estimation result <- est_stsp_aoki(y) #> Error in est_stsp_aoki(y): input \"gamma\" is not a valid 3-D array. result #> Error: object 'result' not found set.seed(123) # Generate example data model <- stspmod(sys = test_stsp(dim = c(2,2), s = 2), sigma_L = diag(2)) y <- sim(model, n.obs = 100)$y  # Run estimation result <- est_stsp_cca(y) #> Error in est_stsp_cca(y): input \"gamma\" is not a valid 3-D array. result #> Error: object 'result' not found set.seed(123) # Generate example data model <- stspmod(sys = test_stsp(dim = c(2,2), s = 2), sigma_L = diag(2)) y <- sim(model, n.obs = 100)$y  # Run estimation result <- est_stsp_cca_sample(y) #> Error in est_stsp_cca_sample(y): argument \"p\" is missing, with no default result #> Error: object 'result' not found"},{"path":"https://bfunovits.github.io/RLDM/reference/subspace-methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate State Space Models with Subspace Methods — subspace methods","title":"Estimate State Space Models with Subspace Methods — subspace methods","text":"Estimate (respectively construct) state space model given sample given (sample) autocovariance function.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/subspace-methods.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate State Space Models with Subspace Methods — subspace methods","text":"","code":"est_stsp_ss(   obj,   method = c(\"cca\", \"aoki\"),   s.max = NULL,   p = NULL,   p.ar.max = NULL,   p.factor = 2,   extend_acf = FALSE,   sample2acf = TRUE,   estorder = estorder_SVC,   keep_models = FALSE,   mean_estimate = c(\"sample.mean\", \"zero\"),   n.obs = NULL,   ... )"},{"path":"https://bfunovits.github.io/RLDM/reference/subspace-methods.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate State Space Models with Subspace Methods — subspace methods","text":"obj Either \"time series\" object (.e .matrix(obj) returns \\((N,m)\\)-dimensional numeric matrix) autocov() object (\\(L\\) lags) represents (estimated) autocovariance function. type autocov object irrelevant since est_stsp_ss always uses slot obj$gamma contains autocovariance function. method Character string giving method used fit model. s.max (integer) maximum order state space model. NULL default value chosen based sample size \\(N\\), respectively based number lags \\(L\\) ACF. p (integer) number block columns Hankel matrix (size \"past\"). NULL p chosen fitting \"long\" AR model. p.ar.max (integer) maximum order \"long\" AR model. NULL default choice made. parameter needed case p=NULL. p.factor (integer) p=NULL, number block columns Hankel matrix set \\(p = p_f\\hat{p}_{AIC}\\) \\(p_f\\) parameter p.factor \\(\\hat{p}_{AIC}\\) (AIC) estimate order \"long\" AR model. See also est_ar(). extend_acf (boolean) TRUE ACF extended via AR(p) model (MEST). sample2acf (boolean) obj data object sample2acf TRUE, first sample autocovariance function computed used actual computations. estorder function, used select order state space model. keep_models (boolean) function return list estimated system order 0:s.max? mean_estimate Character string giving method used estimate mean \\(\\mu = E y_t\\). Default use sample mean. See details . n.obs Optional integer gives sample size \\(N\\). parameter used, obj autocov() object. n.obs=NULL slot obj$n.obs used. Note obj$n.obs=NULL obj$n.obs=Inf refers case population autocovariance function, .e. \\(N=\\infty\\). \"time series\" object sample size course set number observations, .e. n.obs = nrow(.matrix(obj)). sample size \\(N\\) controls computation default (maximum) orders estimation order state space model. ... additional parameters, passed order estimation routine.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/subspace-methods.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate State Space Models with Subspace Methods — subspace methods","text":"list slots model rationalmatrices::stsp() object, represents estimated state space model. models either NULL (!keep_models) list parameters estimated models orders (s=0:s.max+1). slot may e.g. used estimate model order user defined model selection procedure. s (integer) estimate model order. info list information data design parameters estimation procedure. stats ((s.max+1)--5)-dimensional matrix statistics (estimated) state space models. y.mean estimate mean \\(\\mu\\).","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/subspace-methods.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Estimate State Space Models with Subspace Methods — subspace methods","text":"procedure implements three subspace algorithms estimation state space models, AOKI method, described (Aoki 1990)  CCA MEST algorithms (see e.g. (Dahlen Scherrer 2004) ). three algorithms center weighted Hankel matrix $$(R_f')^{-T} H_{fp} R_p^{-1}$$ block Hankel matrix \\(H_{fp}\\) covariance \"past\" \\((y_{t-1}',\\cdots,y_{t-p}')'\\) \"future\" \\((y_{t}',\\cdots,y_{t+f-1}')'\\) \\(R_f\\) \\(R_p\\) cholesky factors covariance matrices \"future\" \"past\" respectively. singular values weighted Hankel matrix canonical correlation coefficients past future. Note implementation always sets \\(f = p+1\\). AOKIs method realization algorithm, .e. reconstructs underlying state space model (population) autocovariance function. end Riccati equation solved, see riccati(). estimated ACF fed algorithm one obtains estimate state space model. However note may fail (particular Riccati equation may positive definite solution) estimate ACF positive definite, Hankel matrix small state dimension correct. CCA method estimates state space model first constructing estimate states. parameter matrices estimated via simple LS regressions. procedure give \"true\" model, even case population ACF used. However, \"distance\" true model estimated model converges zero, estimate ACF converges population ACF size \\(p\\) Hankel matrix converges infinity. two implementations CCA method: obj \"time series\" object sample2acf==FALSE helper function est_stsp_cca_sample() called. implementation CCA operates directly supplied data. obj autocov() object obj \"time series\" object sample2acf==TRUE helper function est_stsp_cca() called. implementation uses (estimated) autocovariance function. time series object, first sample autocovariance function computed fed helper function. key idea MEST algorithm first estimate \"long\" AR model, convert AR model state space model use \"balancing truncation\" method obtain final estimate state space model. scheme may obtained calling est_stsp_ss option extend_acf=TRUE: option instructs procedure first estimate AR(p) model use model \"extend\" ACF, .e. compute values ACF lags \\(p+1,\\ldots,2p\\). extended ACF fed helper function  est_stsp_cca(). Note MEST uses autocovariance function. \"time series\" object one set sample2acf=TRUE. algorithms may used model reduction (.e. find model smaller state space dimension true model) estimation (feeding sample autocovariance function ). algorithms may also used simple \"model reduction algorithms\". want approximate high dimensional state space model model lower order, may proceed follows. First compute ACF high dimensional model fed ACF subspace routine est_stsp_ss, however setting maximum order s.max value less true order. Note thet AOKI procedure however, may break , since guaranteed Riccati equation, needs solved, positive semidefinite solution. Size Hankel matrix input parameter p=NULL \\(p\\) chosen follows. procedure estimates order \"long\" AR model AIC criterion. size \"past\" \\(p\\) set \\(p = p_f\\hat{p}_{AIC}\\) \\(p_f\\) factor (defaults \\(2\\)) \\(\\hat{p}_{AIC}\\) (AIC) estimate order \"long\" AR model. See also est_ar(). Estimation Mean input parameter obj autocov() object (contains info mean \\(\\mu=E y_t\\)) \"estimate\" mean simply set vector NA's. input parameter obj \"time series\" object, two options. mean_estimate == 'zero' procedure assumes process centered (\\(\\mu=E y_t=0\\)) thus sets estimate zero vector. case mean_estimate == 'sample.mean'  sample mean data used. Order Estimation input parameter s.max defines maximum order considered. order estimation based Hankel singular values \\(\\sigma_s\\) /log det values estimated noise covariance matrices \\(\\ln\\det \\hat{\\Sigma}_s\\). Using Hankel singular values advantage one model estimated, whereas otherwise estimates models orders \\(s=0,\\ldots,s_{\\max}\\) computed. order exploit (small) advantage singular values based criteria order estimation runs follows: First procedures call  estorder(s.max, Hsv, n.par, m, n.obs, Hsize=c(f,p), ...)  Hsv \\(pm\\) dimensional vector Hankel singular values n.par \\((s_{\\max}+1)\\) dimensional vector respective number parameters models orders \\(s=0,\\ldots,s_{\\max}\\). call returns estimate order procedures estimate corresonding state space model. call fails (.e returns NULL) procedures estimate models orders \\(s_{\\max}\\) corresponding noise covariance matrices. order estimated calling  estorder(s.max = s.max, Hsv, lndetSigma, n.par, m, n.obs, Hsize, ...)  lndetSigma vector log det values estimated noise covariance matrices (\\(\\ln\\det \\hat{\\Sigma}_s\\)). package offers predefined order selection procedures (see also subspace order estimates): estorder_max(s.max, ...) simply returns maximum order s.max considered. estorder_rkH(s.max, Hsv, tol, ...) estimates order estimate rank Hankel matrix. estorder_MOE(s.max, Hsv, ...) estimates order searching \"gap\" singular values. estorder_SVC(s.max, Hsv, n.par, n.obs, Hsize, penalty, ...) implements called Singular Value Criteria, see (Bauer 2001) : $$svc(s) = \\sigma_{s+1}^2 + c(N)d(s)/N$$ \\(\\sigma_s\\) \\(s\\)-th singular value weighted Hankel marix, \\(N\\) sample size, \\(d(s) = 2ms\\) denotes number parameters state space model \\(s\\) states (\\(m\\) outputs) \\(c(N)\\)) \"penalty\" (depending sample size).  order estimation procedures use Hankel singular values, whereas following procedure based estimated noise covariances. estorder_IVC(s.max, lndetSigma, n.par, n.obs, penalty, ...) estimates order via information criterion form $$ivc(s) = \\ln\\det\\hat\\Sigma_{s} + c(N)d(s)/N$$ \\(\\hat\\Sigma_s\\) estimate noise covariace matrix obtained model order \\(s\\), \\(d(s)\\) denotes number parameters \\(c(N)\\) \"penalty\" (depending sample size). estorder_SVC estorder_IVC (optional) parameter penalty controls penalty term \\(c(N)\\).","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/subspace-methods.html","id":"further-notes","dir":"Reference","previous_headings":"","what":"Further Notes","title":"Estimate State Space Models with Subspace Methods — subspace methods","text":"actual computations done helper routines detailed subspace helpers. type autocov() object irrelevenat since function always uses slot obj$gamma.  keep_models==TRUE estimation procedure compute models even case Hankel singular value based selection criterion.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/subspace-methods.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Estimate State Space Models with Subspace Methods — subspace methods","text":"Aoki M (1990). State Space Modeling Time Series. Springer Verlag, New York. Bauer D (2001). “Order estimation subspace methods.” Automatica, 37(10), 1561 - 1573. doi:10.1016/S0005-1098(01)00118-2 . Dahlen , Scherrer W (2004). “relation CCA subspace method balanced reduction autoregressive model.” Journal Econometrics, 118, 293–312. doi:10.1016/S0304-4076(03)00144-1 .","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/subspace-methods.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate State Space Models with Subspace Methods — subspace methods","text":"","code":"set.seed(3421) # in order to get reproducible results  # create a \"random\", stable and miniphase state space model m = 2 # number of outputs s = 3 # number of states s.max = 2*s lag.max = max(4*s, 25) n.obs = 1000  model = r_model(tmpl_stsp_full(m, m, s),                 bpoles = 1, bzeroes = 1,  sd = 0.5) # scale sigma_L diag(model$sigma_L) = 1  # compute ACF gam = autocov(model, lag.max = lag.max)  # simulate data data = sim(model, n.obs)  # sample ACF gam.sample = autocov(data$y, lag.max = lag.max, demean = FALSE)  # AOKIs method ############################################################## # reconstruct the true model from the population ACF # \"estimate\" the order by the rank of the Hankel matrix out = est_stsp_ss(gam, method = 'aoki', s.max = 2*s, estorder = estorder_rkH)  # compute the ACF of the constructed model. gam.hat = autocov(out$model, lag.max = lag.max)  # check that the constructed model is equivalent to the original model all.equal(dim(model$sys), dim(out$model$sys)) #> [1] TRUE all.equal(gam, gam.hat) #> [1] TRUE   # CCA based on the sample ################################################### # estimate the order by a \"singular value criterion\" out = est_stsp_ss(data$y, method = 'cca', sample2acf = FALSE, s.max = 2*s,                   estorder = estorder_SVC)  # compute the ACF of the constructed model. gam.hat = autocov(out$model, lag.max = lag.max)  all.equal(dim(model$sys), dim(out$model$sys)) # the estimated order is correct #> [1] TRUE all.equal(gam$gamma, gam.hat$gamma)           # but of course the estimated model is not perfect #> [1] \"Mean relative difference: 0.1680467\"  # CCA based on the sample ACF ############################################### # estimate the order by an \"information criterion\" out = est_stsp_ss(gam.sample, method = 'cca', s.max = 2*s,                   estorder = estorder_IVC)  # compute the ACF of the constructed model. gam.hat = autocov(out$model, lag.max = lag.max)  cat('s.hat=', dim(out$model$sys)[3], '\\n') # the estimated order is s.hat=2, the true order is s=3! #> s.hat= 2  all.equal(gam$gamma, gam.hat$gamma)        # relative error of the TRUE and the estimated ACF #> [1] \"Mean relative difference: 0.1966654\"  # alternatively, we may also use out2 = est_stsp_ss(data$y, sample2acf = TRUE, mean_estimate = 'zero',                    method = 'cca', s.max = 2*s, estorder = estorder_IVC) all.equal(out$model, out2$model) #> [1] TRUE  # MEST algorithm ############################################################# # estimate the order by an \"information criterion\" out = est_stsp_ss(gam.sample, method = 'cca', extend_acf = TRUE, s.max = 2*s,                   estorder = estorder_IVC)  # compute the ACF of the constructed model. gam.hat = autocov(out$model, lag.max = lag.max)  cat('s.hat=', dim(out$model$sys)[3], '\\n') # the estimated order is s.hat=2, the true order is s=3! #> s.hat= 2  all.equal(gam$gamma, gam.hat$gamma)        # relative error of the TRUE and the estimated ACF #> [1] \"Mean relative difference: 0.196599\"  # make a plot of the ACFs plot(gam, list(gam.sample, gam.hat), legend = c('TRUE', 'sample', 'subspace'))   # reset seed set.seed(NULL)"},{"path":"https://bfunovits.github.io/RLDM/reference/subspace-order-estimates.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper Functions for Order Estimation — subspace order estimates","title":"Helper Functions for Order Estimation — subspace order estimates","text":"helper function used subspace estimation routine subspace methods estimation order state space model. discussion order estimation context subspace methods see e.g (Bauer 2001) .","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/subspace-order-estimates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper Functions for Order Estimation — subspace order estimates","text":"","code":"estorder_SVC(s.max, Hsv = NULL, n.par, n.obs, Hsize, penalty = \"lnN\", ...)  estorder_IVC(s.max, lndetSigma = NULL, n.par, n.obs, penalty = \"BIC\", ...)  estorder_max(s.max, ...)  estorder_rkH(s.max, Hsv = NULL, tol = sqrt(.Machine$double.eps), ...)  estorder_MOE(s.max, Hsv = NULL, ...)"},{"path":"https://bfunovits.github.io/RLDM/reference/subspace-order-estimates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helper Functions for Order Estimation — subspace order estimates","text":"s.max (integer) maximum order (maximum state space dimension). Hsv vector Hankel singular values (must least s.max entries). n.par (s.max+1) dimensional vector respective number parameters. n.obs (integer) sample size \\(N\\) (Inf). Hsize two dimensional integer vector number block rows block columns Hankel matrix (Hsize = c(f,p)). penalty determines penalty term. See details . ... optional additional parameters. lndetSigma (s.max+1) dimensional vector logarithms determinants respective estimated noise covariance matrices. tol (small) tolarenace used determine rank Hankel matrix.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/subspace-order-estimates.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Helper Functions for Order Estimation — subspace order estimates","text":"Either NULL list slots $s (selected/estimated order) $criterion ((s.max+1) dimensional vector).","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/subspace-order-estimates.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Helper Functions for Order Estimation — subspace order estimates","text":"estorder_max simply returns maximum order s.max considered. estorder_rkH estimates order estimate rank Hankel matrix. maximum singular value smaller equal .Machine$double.eps estimate set s=0. Otherwise estimated order equal number singular values larger equal tol times maximum singular value. function estorder_MOE searches \"gap\" singular values. order set maximum \\(s\\) satisfies $$\\ln(\\sigma_s) > (\\ln(\\sigma_1)+\\ln(\\sigma_m))/2$$ \\(\\sigma_m\\) minimum, non zero singular value. scheme also implemented N4SID procedure system identification toolbox MATLAB (Ljung, 1991). function estorder_SVC implements called Singular Value Criterion $$svc(s) = \\sigma_{s+1}^2 + c(N)d(s)/N$$ (see e.g. (Bauer 2001) ). \\(\\sigma_s\\) \\(s\\)-th singular value weighted Hankel marix, \\(N\\) sample size, \\(d(s) = 2ms\\) denotes number parameters state space model \\(s\\) states (\\(m\\) outputs) \\(c(N)\\) \"penalty\" term. term \\(c(N)=\\ln(N)\\) penalty = \"lnN\" \\(c(N)=fp\\ln(N)\\) penalty = \"fplnN\". estimate order minimizer criterion. estorder_IVC estimates order via information criterion form $$ivc(s) = \\ln\\det\\hat\\Sigma_{s} + c(N)d(s)/N$$ \\(\\hat\\Sigma_s\\) estimate noise covariace matrix obtained model order \\(s\\). term \\(c(N)\\) chosen \\(c(N)=2\\) penalty = \"AIC\" \\(c(N)=\\ln(N)\\) penalty = \"BIC\". Note also routines estorder_SVC estorder_IVC one may also set penalty arbitrary numeric value! E.g. setting penalty=-1 ensure  estorder_SVC  always choses maximum possible order s=s.max.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/subspace-order-estimates.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Helper Functions for Order Estimation — subspace order estimates","text":"Bauer D (2001). “Order estimation subspace methods.” Automatica, 37(10), 1561 - 1573. doi:10.1016/S0005-1098(01)00118-2 .","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/subspace-order-estimates.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Helper Functions for Order Estimation — subspace order estimates","text":"","code":"# Basic example result <- estorder_SVC() result #> NULL # Basic example result <- estorder_IVC() result #> NULL # Basic example result <- estorder_max() #> Error in estorder_max(): argument \"s.max\" is missing, with no default result #> NULL # Basic example result <- estorder_rkH() result #> NULL # Basic example result <- estorder_MOE() result #> NULL"},{"path":"https://bfunovits.github.io/RLDM/reference/test_armamod.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Test ARMA model — test_armamod","title":"Create Test ARMA model — test_armamod","text":"simple tool may used create random ARMA model $$y_t + a_1 y_{t-1} + \\cdots + a_p y_{t-p} = b_0 u_t + b_1 u_{t-1} + \\cdots + b_q u_{t-q}$$ given order \\((p,q)\\).","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/test_armamod.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Test ARMA model — test_armamod","text":"","code":"test_armamod(   dim = c(1, 1),   degrees = c(1, 1),   b0 = NULL,   sigma_L = NULL,   digits = NULL,   bpoles = NULL,   bzeroes = NULL,   n.trials = 100 )"},{"path":"https://bfunovits.github.io/RLDM/reference/test_armamod.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create Test ARMA model — test_armamod","text":"dim integer vector c(m,n). degrees integer vector c(p,q). b0 \\((m,n)\\) dimensional matrix (NULL). See details . sigma_L \\((n,n)\\) dimensional matrix (NULL). See details . digits integer, non NULL randomly generated numbers rounded \"digits\" number decimal places. bpoles lower bound moduli poles corresponding transfer function (NULL). bzeroes lower bound moduli zeroes corresponding tranmsfer function (NULL). parameter ignored non-square matrices (m != n). n.trials maximum number trials.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/test_armamod.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create Test ARMA model — test_armamod","text":"armamod() object, represents generated ARMA model.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/test_armamod.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create Test ARMA model — test_armamod","text":"require \\(m>0\\) \\(p\\geq 0\\). \\(b_0\\) matrix defaults \\((m,n)\\)-dimensional diagonal matrix ones diagonal (diag(x=1, nrow = m, ncol = n)). However, one may also pass arbitray (compatible) matrix procedure. matrix may contain NA's, replaced random numbers. \\(sigma_L\\) matrix defaults \\((n,n)\\)-dimensional lower, triangular matrix However, one may also pass arbitrary (compatible) \\(sigma_L\\) matrix procedure. user may prescribe lower bounds moduli zeroes /poles transfer function $$k(z) = ^{-1}(z) b(z).$$ case procedure simply generates (n.trials) random models model found satisfies constraint. standard deviation normal distribution, used generate random entries, decreased step. course crude method may fail need large number randomly generated matrices.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/test_armamod.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create Test ARMA model — test_armamod","text":"","code":"### generate a random ARMA(1,1) model (with two outputs) ### we require that the model is stable and minimum phase model = try(test_armamod(dim = c(2,2), degrees = c(1,1), digits = 2, bpoles = 1, bzeroes = 1)) if (!inherits(model, 'try-error')) {    print(model)    print(abs(poles(model$sys)))    print(abs(zeroes(model$sys))) } #> ARMA model [2,2] with orders p = 1 and q = 1 #> AR polynomial a(z): #>      z^0 [,1]  [,2] z^1 [,1]  [,2] #> [1,]        1     0    -0.24  0.59 #> [2,]        0     1     0.12  0.55 #> MA polynomial b(z): #>      z^0 [,1]  [,2] z^1 [,1]  [,2] #> [1,]        1     0    -0.38 -0.44 #> [2,]        0     1     0.13 -0.31 #> Left square root of noise covariance Sigma: #>      u[1] u[2] #> u[1] 0.55 0.00 #> u[2] 1.43 0.79 #> [1] 1.584130 3.112729 #> [1] 2.390457 2.390457"},{"path":"https://bfunovits.github.io/RLDM/reference/test_stspmod.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Test state space Model — test_stspmod","title":"Create Test state space Model — test_stspmod","text":"simple tool may used create random, state space model $$a_{t+1} = a_t + B u_t \\mbox{ } y_t = C a_t + D u_t.$$","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/test_stspmod.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Test state space Model — test_stspmod","text":"","code":"test_stspmod(   dim = c(1, 1),   s = NULL,   nu = NULL,   D = NULL,   sigma_L = NULL,   digits = NULL,   bpoles = NULL,   bzeroes = NULL,   n.trials = 100 )"},{"path":"https://bfunovits.github.io/RLDM/reference/test_stspmod.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create Test state space Model — test_stspmod","text":"dim integer vector c(m,n). s state dimension (NULL). nu vector Kronecker indices (NULL). Either state space dimension s Kronecker indices nu must non NULL. parameters given, parameter s ignored. D \\((m,n)\\) dimensional matrix (NULL). See details . sigma_L \\((n,n)\\) dimensional matrix (NULL). See details . digits integer, non NULL randomly generated numbers rounded \"digits\" number decimal places. bpoles lower bound moduli poles corresponding transfer function (NULL). bzeroes lower bound moduli zeroes corresponding tranmsfer function (NULL). parameter ignored non-square matrices (m != n). n.trials maximum number trials.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/test_stspmod.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create Test state space Model — test_stspmod","text":"stspmod() object, represents generated model.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/test_stspmod.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create Test state space Model — test_stspmod","text":"Kronecker indices (parameter nu) given, state space model echelon canonical form generated. means entries \\(,B,C\\) matrices fixed one zero others considerd \"free\". See also rationalmatrices::Kronecker-Indices(). entries \\(, B, C\\) matrices, priori fixed randomly generated. state dimension \\(s\\) (parameter s) given, entries \\(, B, C\\) matrices considered \"free\". \\(D\\) matrix defaults \\((m,n)\\)-dimensional diagonal matrix ones diagonal (diag(x=1, nrow = m, ncol = n)). However, one may also pass arbitray (compatible) \\(D\\) matrix procedure. matrix may contain NA's, replaced random numbers. \\(sigma_L\\) matrix defaults \\((n,n)\\)-dimensional lower, triangular matrix However, one may also pass arbitray (compatible) \\(sigma_L\\) matrix procedure. user may prescribe lower bounds moduli zeroes /poles transfer function $$k(z) = C(I_m z{-1} - )^{-1} B + D.$$ case procedure simply generates (n.trials) random models model found satisfies constraint. standard deviation normal distribution, used generate random entries, decreased step. course crude method may fail need large number randomly generated matrices. Note also, generated model may non-minimal.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/test_stspmod.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create Test state space Model — test_stspmod","text":"","code":"### random state space model with two outputs and state dimension s = 3 ### The model is required to be stable and minimum phase model = try(test_stspmod(dim = c(2,2), s = 3, digits = 2, bpoles = 1, bzeroes = 1)) if (!inherits(model, 'try-error')) {    print(model)    print(min(abs(poles(model$sys))) > 1)    print(min(abs(zeroes(model$sys))) > 1)    print(pseries2nu(pseries(model$sys, lag.max = 10))) # Kronecker indices } #> state space model [2,2] with s = 3 states #>       s[1]  s[2]  s[3]  u[1]  u[2] #> s[1] -0.85  0.97 -0.85 -0.28  0.52 #> s[2] -0.24 -0.13 -0.78 -0.16  0.06 #> s[3] -0.10  0.42  0.54  0.49 -0.57 #> x[1]  1.46  0.23 -0.02  1.00  0.00 #> x[2]  0.58  0.79 -1.28  0.00  1.00 #> Left square root of noise covariance Sigma: #>       u[1] u[2] #> u[1]  2.74 0.00 #> u[2] -0.96 0.56 #> [1] TRUE #> [1] TRUE #> [1] 2 1  ### random state space model with three outputs and 2 inputs in echelon canonical form ### D is lower triangular (with ones on the diagonal) ### the model is required to stable (the transfer function has no poles within the unit circle) model = try(test_stspmod(dim = c(3, 2), nu = c(2,3,0),                          D = matrix(c(1,NA,NA,0,1,NA), nrow = 3, ncol = 2),                          digits = 2, bpoles = 1))  if (!inherits(model, 'try-error')) {    print(model)    print(min(abs(poles(model$sys))) > 1)    print(pseries2nu(pseries(model$sys, lag.max = 10))) # Kronecker indices } #> state space model [3,2] with s = 5 states #>       s[1]  s[2]  s[3]  s[4] s[5]  u[1]  u[2] #> s[1]  0.00  0.00  1.00  0.00 0.00 -0.14  0.78 #> s[2]  0.00  0.00  0.00  1.00 0.00 -0.01 -0.46 #> s[3] -0.05  0.37  0.45 -0.33 0.00 -0.35  0.11 #> s[4]  0.00  0.00  0.00  0.00 1.00  0.49  0.11 #> s[5]  0.22 -0.10 -0.10 -0.10 0.15 -0.45 -0.12 #> x[1]  1.00  0.00  0.00  0.00 0.00  1.00  0.00 #> x[2]  0.00  1.00  0.00  0.00 0.00 -0.41  1.00 #> x[3]  0.16  0.22  0.00  0.00 0.00  0.11 -0.58 #> Left square root of noise covariance Sigma: #>       u[1] u[2] #> u[1]  2.01  0.0 #> u[2] -0.19  1.2 #> [1] TRUE #> [1] 2 3 0"},{"path":"https://bfunovits.github.io/RLDM/reference/tmpl_sigma_L.html","id":null,"dir":"Reference","previous_headings":"","what":"sigma_L Structure — tmpl_sigma_L","title":"sigma_L Structure — tmpl_sigma_L","text":"Create templates left square root \\(L\\) noise covariance matrix \\(\\Sigma = LL'\\). means \\(L\\) parametrized $$\\mbox{vec}(L) = h + H \\theta$$ (\\(k\\)-dimensional) parameter vector \\(\\theta\\).","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/tmpl_sigma_L.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"sigma_L Structure — tmpl_sigma_L","text":"","code":"tmpl_sigma_L(   sigma_L,   structure = c(\"as_given\", \"chol\", \"symm\", \"identity\", \"full_normalized\") )"},{"path":"https://bfunovits.github.io/RLDM/reference/tmpl_sigma_L.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"sigma_L Structure — tmpl_sigma_L","text":"sigma_L numeric (n x n) matrix, free entries coded NAs structure character string, determines \"structure\" sigma_L, see examples.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/tmpl_sigma_L.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"sigma_L Structure — tmpl_sigma_L","text":"List slots h (\\(n^2\\)-dimensional vector), H (\\((n^2, k)\\)-dimensional matrix, \\(k\\) denotes number  free/deep parameters) n.par (integer) number free/deep parameters (\\(=k\\)).","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/tmpl_sigma_L.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"sigma_L Structure — tmpl_sigma_L","text":"parameter structure following meaning as_given Use given parameter sigma_L construct template: NA entries considered free entries fixed. chol Set entries sigma_L diagonal zero proceed . symm First make sigma_L symmetric (sigma_L = (sigma_L + t(sigma_L))/2) use sigma_L template. However, h, H constructed \\(h + H\\theta\\) gives symmetric matrix! Note NAs overwrite fixed values, see examples. identity Use identity matrix template. case free parameters, .e. \\(\\theta\\) empty vector (vector zero length). full_normalized Ones diagonal, otherwise parameters free.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/tmpl_sigma_L.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"sigma_L Structure — tmpl_sigma_L","text":"","code":"sigma_L = matrix(c(0, NA, 1, 0, 2, 3, NA, 1, 1), nrow = 3, ncol = 3) sigma_L #>      [,1] [,2] [,3] #> [1,]    0    0   NA #> [2,]   NA    2    1 #> [3,]    1    3    1  tmpl = tmpl_sigma_L(sigma_L, structure = 'as_given') th = -(1:tmpl$n.par) matrix(tmpl$h + tmpl$H %*% th, nrow = 3, ncol = 3) #>      [,1] [,2] [,3] #> [1,]    0    0   -2 #> [2,]   -1    2    1 #> [3,]    1    3    1  tmpl = tmpl_sigma_L(sigma_L, structure = 'chol') th = -(1:tmpl$n.par) matrix(tmpl$h + tmpl$H %*% th, nrow = 3, ncol = 3) #>      [,1] [,2] [,3] #> [1,]    0    0    0 #> [2,]   -1    2    0 #> [3,]    1    3    1  tmpl = tmpl_sigma_L(sigma_L, structure = 'symm') th = -(1:tmpl$n.par) matrix(tmpl$h + tmpl$H %*% th, nrow = 3, ncol = 3) #>      [,1] [,2] [,3] #> [1,]    0   -1   -2 #> [2,]   -1    2    2 #> [3,]   -2    2    1  tmpl = tmpl_sigma_L(sigma_L, structure = 'identity') tmpl$n.par # = 0 #> [1] 0 matrix(tmpl$h, nrow = 3, ncol = 3) #>      [,1] [,2] [,3] #> [1,]    1    0    0 #> [2,]    0    1    0 #> [3,]    0    0    1  tmpl = tmpl_sigma_L(sigma_L, structure = 'full_normalized') th = -(1:tmpl$n.par) matrix(tmpl$h + tmpl$H %*% th, nrow = 3, ncol = 3) #>      [,1] [,2] [,3] #> [1,]    1   -3   -5 #> [2,]   -1    1   -6 #> [3,]   -2   -4    1"},{"path":"https://bfunovits.github.io/RLDM/reference/toepl_fwd.html","id":null,"dir":"Reference","previous_headings":"","what":"Toeplitz Calculations — toepl_fwd","title":"Toeplitz Calculations — toepl_fwd","text":"Multiplication stacked data vector block Toeplitz matrix (toepl_fwd() MA calculations) \"inversion\" block Toeplitz matrix order perform calculations equivalent multiplying given stacked data vector inverse lower-triangular banded block Toeplitz matrix (toepl_inv() AR calculations). Note matrix polynomials can mapped one--one banded lower-triangular block Toeplitz matrices.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/toepl_fwd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Toeplitz Calculations — toepl_fwd","text":"","code":"toepl_fwd(polm_wide, data_in, t0 = 1)  toepl_inv(polm_rev, data_in, t0 = 1)"},{"path":"https://bfunovits.github.io/RLDM/reference/toepl_fwd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Toeplitz Calculations — toepl_fwd","text":"polm_wide Wide matrix \\(( d_0, d_1, \\ldots, d_q )\\) dimension \\((m \\times (q+1) n)\\) represents matrix polynomial \\(d(z)\\) degree \\(q\\). data_in Data matrix dimension \\((dim(inputs) x nobs)\\). Every column corresponds one observation. t0 Integer. Time index calculations start. Default set 1. AR calculations, \\(degree + 1\\) another smart option. polm_rev Wide matrix \\((c_p, ... , c_1)\\) dimension \\((n \\times (q+1) n)\\) coefficients ordered reverse direction, zero-lag coefficient matrix included. represents square polynomial matrix \\(c(z)\\) \\(c_0\\) equal identity matrix degree \\(p\\).","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/toepl_fwd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Toeplitz Calculations — toepl_fwd","text":"data_out Data matrix dimension \\((dim_out x n_obs)\\)","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/toepl_fwd.html","id":"ma-type-toeplitz-calculations","dir":"Reference","previous_headings":"","what":"MA-type Toeplitz calculations","title":"Toeplitz Calculations — toepl_fwd","text":"Given polynomial matrix degree \\(q\\) dimension \\((m \\times n)\\), \\(m \\geq n\\), given \"wide\" input data matrix dimension \\((n \\times nobs)\\), \\(nobs\\) number observations column corresponds one observation number columns equal number observations, calculate \"wide\" output data matrix dimension \\((m \\times nobs)\\). function name toepl_fwd stems multiplication \"stacked\" input data vector \\((u_1', \\ldots , u_{nobs}')'\\) banded lower-triangular block Toeplitz matrix \\(T\\) dimension \\((nobs m \\times nobs n)\\) whose block elements depend difference row- column-index  \\(T_{,j} = d_{-j}\\).","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/toepl_fwd.html","id":"ar-type-toeplitz-calcuations","dir":"Reference","previous_headings":"","what":"AR-type Toeplitz calcuations","title":"Toeplitz Calculations — toepl_fwd","text":"Given square polynomial matrix \\(c(z)\\) \\(c_0\\) identity matrix given wide data matrix y = data_in, obtain solution u, wide data matrix, Toeplitz equation $$T (y_1', \\ldots , y_{nobs}')' =  (u_1', ... , u_{nobs}')'$$ Note zero-lag coefficient discarded coefficients reversed order since simplifies computations implementation.","code":""},{"path":"https://bfunovits.github.io/RLDM/reference/toepl_fwd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Toeplitz Calculations — toepl_fwd","text":"","code":"p = test_polm(dim = c(2,2), degree = 2) %>% unclass() dim(p) = c(2,2*3) data = matrix(rnorm(2*100), 2, 100) toepl_fwd(p, data) #>          [,1]      [,2]      [,3]       [,4]       [,5]      [,6]      [,7] #> [1,] 141.4748 -23.13566 -248.4166  -591.9084  -590.1148 -267.8618 -22.54160 #> [2,] 265.6674 -40.86986 -473.6662 -1108.6499 -1114.6648 -508.4464 -40.41374 #>          [,8]      [,9]     [,10]     [,11]     [,12]     [,13]     [,14] #> [1,] 337.9961  61.65166 -174.3230 -480.3138 -332.2220 -359.2901 -468.8967 #> [2,] 633.4052 133.31731 -327.9794 -883.4771 -618.9747 -667.0883 -881.7640 #>          [,15]     [,16]     [,17]     [,18]     [,19]      [,20]     [,21] #> [1,] -457.8742 -437.2916 -257.6943 -361.0563 -102.0771  -80.64441 -109.7963 #> [2,] -852.6561 -818.1317 -478.0183 -664.4814 -179.1595 -131.14669 -197.6166 #>         [,22]    [,23]     [,24]     [,25]     [,26]    [,27]    [,28]    [,29] #> [1,] 34.91040 48.87798  86.59909  -93.8866 -292.7939 24.56999 130.1283 429.0934 #> [2,] 67.41063 89.49313 160.32566 -172.1910 -548.8772 40.10576 252.6989 809.0855 #>         [,30]     [,31]     [,32]     [,33]    [,34]    [,35]    [,36] #> [1,] 222.2223 -12.03776 -56.45539  86.37366 305.3626 348.6875 152.3885 #> [2,] 431.3414 -16.82197 -90.71190 179.31578 586.9399 650.0350 271.0928 #>          [,37]     [,38]     [,39]    [,40]    [,41]    [,42]      [,43] #> [1,] -11.71296 -25.25584  52.99139 315.1927 273.1658 31.19768  -60.09739 #> [2,] -26.60370 -41.56590 107.53906 588.6766 508.6323 57.19161 -118.66863 #>          [,44]    [,45]    [,46]    [,47]     [,48]      [,49]     [,50] #> [1,] -189.3048 389.9989 175.8936 174.9174 -382.0507  -534.7276 -339.3511 #> [2,] -362.3038 708.3049 319.4822 316.9774 -718.7050 -1004.2183 -645.5925 #>          [,51]      [,52]     [,53]     [,54]     [,55]     [,56]     [,57] #> [1,] -330.0379  -88.61569 -383.5234 -130.9149 -53.97294 -272.2546 -427.3010 #> [2,] -640.1781 -194.77295 -725.6863 -235.3338 -96.01573 -508.5599 -787.6784 #>          [,58]     [,59]      [,60]     [,61]     [,62]     [,63]      [,64] #> [1,] -317.3687 -49.22824  -7.675721 -384.1177 -273.5994 -153.9431  -94.22858 #> [2,] -566.9174 -79.96722 -37.299727 -741.6514 -543.2314 -303.9576 -186.24470 #>          [,65]      [,66]     [,67]     [,68]    [,69]     [,70]    [,71] #> [1,]  64.79213  -64.57484  62.96636 -39.36107 147.6626  87.72005 374.1570 #> [2,] 118.60555 -113.03190 111.50775 -76.14069 274.2275 170.02801 717.7904 #>          [,72]     [,73]     [,74]     [,75]     [,76]     [,77]     [,78] #> [1,] -21.38605 -144.4953 -386.7786 -276.5288 -49.80268 -144.5885 -45.70775 #> [2,] -26.07724 -259.6862 -723.4931 -522.8544 -91.03230 -269.5783 -83.85605 #>          [,79]     [,80]     [,81]    [,82]    [,83]     [,84]     [,85] #> [1,] -279.9757 -378.9133 -291.1977 127.3729 252.6703  93.75194 -191.5580 #> [2,] -522.4010 -707.0198 -540.1409 235.0461 474.4832 167.06251 -354.9276 #>          [,86]    [,87]    [,88]    [,89]     [,90]     [,91]    [,92]    [,93] #> [1,] -319.0661 107.4696 185.0086 105.3729 -345.8812 -199.8807 129.1090 293.9800 #> [2,] -593.5456 213.2051 349.0362 187.9175 -659.1456 -386.8416 233.6103 542.2512 #>          [,94]       [,95]     [,96]     [,97]     [,98]     [,99]   [,100] #> [1,]  58.82142 -5.46274106 -57.15317 -163.5273 -131.5317 -119.6936 42.34206 #> [2,] 108.85731 -0.06150599 -94.69699 -292.7382 -242.4070 -225.4060 75.00084 p = test_polm(dim = c(2,2), degree = 2) %>% unclass() dim(p) = c(2,2*3) data = matrix(rnorm(2*100), 2, 100) toepl_inv(p, data) #>           [,1]     [,2]       [,3]     [,4]         [,5]         [,6] #> [1,] -0.145243 164.0438  -54728.88 18389019  -6178217732 2.075718e+12 #> [2,] -1.210946 299.3382 -100931.57 33908862 -11392486213 3.827574e+12 #>               [,7]         [,8]          [,9]        [,10]         [,11] #> [1,] -6.973862e+14 2.343033e+17 -7.871971e+19 2.644774e+22 -8.885741e+24 #> [2,] -1.285964e+15 4.320497e+17 -1.451573e+20 4.876900e+22 -1.638509e+25 #>             [,12]         [,13]        [,14]         [,15]        [,16] #> [1,] 2.985374e+27 -1.003007e+30 3.369837e+32 -1.132176e+35 3.803812e+37 #> [2,] 5.504958e+27 -1.849520e+30 6.213898e+32 -2.087705e+35 7.014138e+37 #>              [,17]        [,18]         [,19]        [,20]         [,21] #> [1,] -1.277980e+40 4.293675e+42 -1.442561e+45 4.846623e+47 -1.628337e+50 #> [2,] -2.356565e+40 7.917433e+42 -2.660048e+45 8.937058e+47 -3.002615e+50 #>             [,22]         [,23]        [,24]         [,25]        [,26] #> [1,] 5.470782e+52 -1.838038e+55 6.175321e+57 -2.074744e+60 6.970592e+62 #> [2,] 1.008799e+53 -3.389298e+55 1.138714e+58 -3.825779e+60 1.285361e+63 #>              [,27]        [,28]         [,29]        [,30]         [,31] #> [1,] -2.341935e+65 7.868280e+67 -2.643534e+70 8.881575e+72 -2.983974e+75 #> [2,] -4.318471e+65 1.450892e+68 -4.874614e+70 1.637741e+73 -5.502377e+75 #>             [,32]         [,33]        [,34]         [,35]        [,36] #> [1,] 1.002536e+78 -3.368257e+80 1.131645e+83 -3.802028e+85 1.277381e+88 #> [2,] 1.848653e+78 -6.210985e+80 2.086727e+83 -7.010849e+85 2.355460e+88 #>              [,37]        [,38]         [,39]        [,40]          [,41] #> [1,] -4.291662e+90 1.441885e+93 -4.844351e+95 1.627574e+98 -5.468217e+100 #> [2,] -7.913721e+90 2.658801e+93 -8.932868e+95 3.001207e+98 -1.008326e+101 #>              [,42]          [,43]         [,44]          [,45]         [,46] #> [1,] 1.837176e+103 -6.172426e+105 2.073772e+108 -6.967324e+110 2.340837e+113 #> [2,] 3.387709e+103 -1.138181e+106 3.823986e+108 -1.284758e+111 4.316447e+113 #>               [,47]         [,48]          [,49]         [,50]          [,51] #> [1,] -7.864591e+115 2.642295e+118 -8.877411e+120 2.982575e+123 -1.002066e+126 #> [2,] -1.450212e+116 4.872328e+118 -1.636973e+121 5.499797e+123 -1.847786e+126 #>              [,52]          [,53]         [,54]          [,55]         [,56] #> [1,] 3.366678e+128 -1.131115e+131 3.800246e+133 -1.276782e+136 4.289649e+138 #> [2,] 6.208073e+128 -2.085748e+131 7.007562e+133 -2.354355e+136 7.910011e+138 #>               [,57]        [,58]          [,59]         [,60]          [,61] #> [1,] -1.441209e+141 4.84208e+143 -1.626811e+146 5.465653e+148 -1.836315e+151 #> [2,] -2.657554e+141 8.92868e+143 -2.999800e+146 1.007853e+149 -3.386121e+151 #>              [,62]          [,63]         [,64]          [,65]         [,66] #> [1,] 6.169532e+153 -2.072799e+156 6.964058e+158 -2.339739e+161 7.860904e+163 #> [2,] 1.137647e+154 -3.822193e+156 1.284156e+159 -4.314423e+161 1.449532e+164 #>               [,67]         [,68]          [,69]         [,70]          [,71] #> [1,] -2.641056e+166 8.873248e+168 -2.981177e+171 1.001596e+174 -3.365099e+176 #> [2,] -4.870044e+166 1.636206e+169 -5.497219e+171 1.846920e+174 -6.205162e+176 #>              [,72]          [,73]         [,74]          [,75]         [,76] #> [1,] 1.130584e+179 -3.798464e+181 1.276183e+184 -4.287638e+186 1.440533e+189 #> [2,] 2.084770e+179 -7.004277e+181 2.353252e+184 -7.906303e+186 2.656308e+189 #>               [,77]         [,78]          [,79]         [,80]          [,81] #> [1,] -4.839810e+191 1.626048e+194 -5.463091e+196 1.835454e+199 -6.166639e+201 #> [2,] -8.924493e+191 2.998394e+194 -1.007381e+197 3.384533e+199 -1.137114e+202 #>              [,82]          [,83]         [,84]          [,85]         [,86] #> [1,] 2.071828e+204 -6.960793e+206 2.338642e+209 -7.857219e+211 2.639818e+214 #> [2,] 3.820401e+204 -1.283554e+207 4.312400e+209 -1.448852e+212 4.867760e+214 #>               [,87]         [,88]          [,89]         [,90]          [,91] #> [1,] -8.869088e+216 2.979779e+219 -1.001127e+222 3.363521e+224 -1.130054e+227 #> [2,] -1.635439e+217 5.494641e+219 -1.846054e+222 6.202253e+224 -2.083793e+227 #>              [,92]          [,93]         [,94]          [,95]         [,96] #> [1,] 3.796683e+229 -1.275585e+232 4.285628e+234 -1.439858e+237 4.837540e+239 #> [2,] 7.000993e+229 -2.352148e+232 7.902596e+234 -2.655063e+237 8.920309e+239 #>               [,97]         [,98]          [,99]        [,100] #> [1,] -1.625286e+242 5.460529e+244 -1.834593e+247 6.163748e+249 #> [2,] -2.996988e+242 1.006909e+245 -3.382946e+247 1.136580e+250"}]
