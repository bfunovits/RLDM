# Generate a Random Model

This function may be used to generate random state space or VARMA
models. The main argument is a model template, which defines the type of
model to generate, see e.g.
[`model structures()`](https://bfunovits.github.io/RLDM/reference/model_structures.md).
If bounds for the poles and/or the zeroes are given, then the procedure
simply generates random models until a model which satisfies the
constraint is found. Of course this is a very crude method and it may
need a large number of randomly generated model.

## Usage

``` r
r_model(
  template,
  ntrials.max = 100,
  bpoles = NULL,
  bzeroes = NULL,
  rand.gen = stats::rnorm,
  ...
)
```

## Arguments

- template:

  A model template as computed e.g. by
  [`model2template()`](https://bfunovits.github.io/RLDM/reference/model_structures.md).

- ntrials.max:

  Maximum number of trials.

- bpoles, bzeroes:

  Lower bounds on the poles and zeroes of the model (such that stability
  and invertibility assumptions are satisfied). If set to `NA`, then the
  corresponding test is skipped.

- rand.gen:

  (optional) A function to generate the random, "free" parameters.

- ...:

  Additional parameters, passed on to `rand.gen`. In particular, if the
  "free" paramameters are generated by
  [`rnorm()`](https://rdrr.io/r/stats/Normal.html), then the standard
  deviation `sd` may be set. Choosing small values for `sd` makes it
  easier to find a stable and miniphase model. Of course this "trick"
  only works if the reference model, which is obtained with a zero
  parameter vector, satisfies the constraints.

## Value

Model object whose class depends on the template.

## Examples

``` r
# Generate a random VARMA model in echelon form ############

# Compute the appropriate model template
tmpl = tmpl_arma_echelon(nu = c(1,2,1))

# Create a random model, which is stable but not necessarily miniphase
model = r_model(tmpl, bpoles = 1, sd = 0.5)
model
#> ARMA model [3,3] with orders p = 2 and q = 2
#> AR polynomial a(z):
#>      z^0 [,1]       [,2]  [,3]  z^1 [,1]       [,2]         [,3]   z^2 [,1]
#> [1,]        1  0.0000000     0 0.3081750  0.7223715 -0.601089964  0.0000000
#> [2,]        0  1.0000000     0 0.0000000 -0.1094972  0.000000000 -0.2809953
#> [3,]        0 -0.4492821     1 0.6414264  0.3907063 -0.005302969  0.0000000
#>            [,2]    [,3]
#> [1,] 0.00000000 0.00000
#> [2,] 0.02720296 1.17281
#> [3,] 0.00000000 0.00000
#> MA polynomial b(z):
#>      z^0 [,1]       [,2]  [,3]    z^1 [,1]       [,2]       [,3]  z^2 [,1]
#> [1,]        1  0.0000000     0 -1.10775193 0.41434164 -0.5257544 0.0000000
#> [2,]        0  1.0000000     0  0.05311813 0.03511124  0.8294160 0.5049485
#> [3,]        0 -0.4492821     1 -0.17082805 0.67677103  0.3718860 0.0000000
#>           [,2]      [,3]
#> [1,] 0.0000000 0.0000000
#> [2,] 0.2190252 0.5539707
#> [3,] 0.0000000 0.0000000
#> Left square root of noise covariance Sigma:
#>            u[1]      u[2]       u[3]
#> u[1]  0.4270146 0.0000000  0.0000000
#> u[2]  0.1189830 0.3324880  0.0000000
#> u[3] -0.3873182 0.2249256 -0.2380616

# Check whether the poles satisfy the constraint
min(abs(poles(model)))
#> There are determinantal roots at (or close to) infinity.
#> Roots close to infinity got discarded.
#> [1] 1.022024
min(abs(zeroes(model)))
#> There are determinantal roots at (or close to) infinity.
#> Roots close to infinity got discarded.
#> [1] 0.7532046
```
