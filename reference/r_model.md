# Generate a Random Model

This function may be used to generate random state space or VARMA
models. The main argument is a model template, which defines the type of
model to generate, see e.g.
[`model structures()`](https://bfunovits.github.io/RLDM/reference/model_structures.md).
If bounds for the poles and/or the zeroes are given, then the procedure
simply generates random models until a model which satisfies the
constraint is found. Of course this is a very crude method and it may
need a large number of randomly generated model.

## Usage

``` r
r_model(
  template,
  ntrials.max = 100,
  bpoles = NULL,
  bzeroes = NULL,
  rand.gen = stats::rnorm,
  ...
)
```

## Arguments

- template:

  A model template as computed e.g. by
  [`model2template()`](https://bfunovits.github.io/RLDM/reference/model_structures.md).

- ntrials.max:

  Maximum number of trials.

- bpoles, bzeroes:

  Lower bounds on the poles and zeroes of the model (such that stability
  and invertibility assumptions are satisfied). If set to `NA`, then the
  corresponding test is skipped.

- rand.gen:

  (optional) A function to generate the random, "free" parameters.

- ...:

  Additional parameters, passed on to `rand.gen`. In particular, if the
  "free" paramameters are generated by
  [`rnorm()`](https://rdrr.io/r/stats/Normal.html), then the standard
  deviation `sd` may be set. Choosing small values for `sd` makes it
  easier to find a stable and miniphase model. Of course this "trick"
  only works if the reference model, which is obtained with a zero
  parameter vector, satisfies the constraints.

## Value

Model object whose class depends on the template.

## Examples

``` r
# Generate a random VARMA model in echelon form ############
set.seed(123)

# Compute the appropriate model template
tmpl = tmpl_arma_echelon(nu = c(1,2,1))

# Create a random model, which is stable but not necessarily miniphase
model = r_model(tmpl, bpoles = 1, sd = 0.5)
model
#> ARMA model [3,3] with orders p = 2 and q = 2
#> AR polynomial a(z):
#>      z^0 [,1]      [,2]  [,3]   z^1 [,1]      [,2]      [,3]    z^2 [,1]
#> [1,]        1 0.0000000     0  0.2132321 0.4475628 0.3443201  0.00000000
#> [2,]        0 1.0000000     0  0.0000000 0.4390667 0.0000000 -0.03095586
#> [3,]        0 0.6269075     1 -0.1475357 0.4107905 0.2769588  0.00000000
#>            [,2]       [,3]
#> [1,]  0.0000000  0.0000000
#> [2,] -0.1529813 -0.1902355
#> [3,]  0.0000000  0.0000000
#> MA polynomial b(z):
#>      z^0 [,1]      [,2]  [,3]   z^1 [,1]       [,2]       [,3]    z^2 [,1]
#> [1,]        1 0.0000000     0 -0.3473535  1.0844780 -0.2014424  0.00000000
#> [2,]        0 1.0000000     0 -0.1039586  0.6039810 -0.2333277 -0.04168453
#> [3,]        0 0.6269075     1 -0.6326982 -0.5615543  0.3899826  0.00000000
#>           [,2]        [,3]
#> [1,] 0.0000000  0.00000000
#> [2,] 0.1266593 -0.01427338
#> [3,] 0.0000000  0.00000000
#> Left square root of noise covariance Sigma:
#>             u[1]       u[2]      u[3]
#> u[1] -0.02143523  0.0000000 0.0000000
#> u[2]  0.68430114  0.7582353 0.0000000
#> u[3] -0.11288549 -0.7743764 0.2923069

# Check whether the poles satisfy the constraint
min(abs(poles(model)))
#> There are determinantal roots at (or close to) infinity.
#> Roots close to infinity got discarded.
#> [1] 1.584116
min(abs(zeroes(model)))
#> There are determinantal roots at (or close to) infinity.
#> Roots close to infinity got discarded.
#> [1] 0.9445676
```
