# Generate a Random Model

This function may be used to generate random state space or VARMA
models. The main argument is a model template, which defines the type of
model to generate, see e.g.
[`model structures()`](https://bfunovits.github.io/RLDM/reference/model_structures.md).
If bounds for the poles and/or the zeroes are given, then the procedure
simply generates random models until a model which satisfies the
constraint is found. Of course this is a very crude method and it may
need a large number of randomly generated model.

## Usage

``` r
r_model(
  template,
  ntrials.max = 100,
  bpoles = NULL,
  bzeroes = NULL,
  rand.gen = stats::rnorm,
  ...
)
```

## Arguments

- template:

  A model template as computed e.g. by
  [`model2template()`](https://bfunovits.github.io/RLDM/reference/model_structures.md).

- ntrials.max:

  Maximum number of trials.

- bpoles, bzeroes:

  Lower bounds on the poles and zeroes of the model (such that stability
  and invertibility assumptions are satisfied). If set to `NA`, then the
  corresponding test is skipped.

- rand.gen:

  (optional) A function to generate the random, "free" parameters.

- ...:

  Additional parameters, passed on to `rand.gen`. In particular, if the
  "free" paramameters are generated by
  [`rnorm()`](https://rdrr.io/r/stats/Normal.html), then the standard
  deviation `sd` may be set. Choosing small values for `sd` makes it
  easier to find a stable and miniphase model. Of course this "trick"
  only works if the reference model, which is obtained with a zero
  parameter vector, satisfies the constraints.

## Value

Model object whose class depends on the template.

## Examples

``` r
# Generate a random VARMA model in echelon form ############

# Compute the appropriate model template
tmpl = tmpl_arma_echelon(nu = c(1,2,1))

# Create a random model, which is stable but not necessarily miniphase
model = r_model(tmpl, bpoles = 1, sd = 0.5)
model
#> ARMA model [3,3] with orders p = 2 and q = 2
#> AR polynomial a(z):
#>      z^0 [,1]      [,2]  [,3]   z^1 [,1]        [,2]       [,3]   z^2 [,1]
#> [1,]        1 0.0000000     0 0.24097016  0.01663105 -0.1597946  0.0000000
#> [2,]        0 1.0000000     0 0.00000000 -0.31538394  0.0000000 -0.2758003
#> [3,]        0 0.2001581     1 0.05906883  0.35436034  0.4563334  0.0000000
#>           [,2]      [,3]
#> [1,] 0.0000000 0.0000000
#> [2,] 0.1798877 0.1491349
#> [3,] 0.0000000 0.0000000
#> MA polynomial b(z):
#>      z^0 [,1]      [,2]  [,3] z^1 [,1]       [,2]         [,3]  z^2 [,1]
#> [1,]        1 0.0000000     0 1.034615 -0.9216181  0.265717438 0.0000000
#> [2,]        0 1.0000000     0 1.150798 -0.6000085 -0.007246912 0.2857984
#> [3,]        0 0.2001581     1 0.723430  0.8488433 -0.374071926 0.0000000
#>           [,2]      [,3]
#> [1,] 0.0000000 0.0000000
#> [2,] 0.6305671 0.1034917
#> [3,] 0.0000000 0.0000000
#> Left square root of noise covariance Sigma:
#>            u[1]       u[2]       u[3]
#> u[1] -0.1662601  0.0000000  0.0000000
#> u[2]  0.5251204  0.6084734  0.0000000
#> u[3]  0.5476129 -0.4049386 -0.6795729

# Check whether the poles satisfy the constraint
min(abs(poles(model)))
#> There are determinantal roots at (or close to) infinity.
#> Roots close to infinity got discarded.
#> [1] 2.334861
min(abs(zeroes(model)))
#> There are determinantal roots at (or close to) infinity.
#> Roots close to infinity got discarded.
#> [1] 0.8560205
```
