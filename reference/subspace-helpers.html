<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Subspace Helper Methods — subspace helpers • RLDM</title><script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet"><script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet"><link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet"><script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Subspace Helper Methods — subspace helpers"><meta name="description" content="These procedure implement two subspace algorithms for the estimation of state space models,
the AOKI method, as described in (Aoki 1990)
 and the CCA algorithm
(see e.g. (Dahlen and Scherrer 2004)
 or (Bauer 2001)
).
These subspace algorithms center on the weighted Hankel matrix
$$(R_f')^{-T} H_{fp} R_p^{-1}$$
where the block Hankel matrix \(H_{fp}\) is the covariance between the
&quot;past&quot; \((y_{t-1}',\cdots,y_{t-p}')'\) and the
&quot;future&quot; \((y_{t}',\cdots,y_{t+f-1}')'\) and
\(R_f\) and \(R_p\) are the cholesky factors of the covariance matrices
of the &quot;future&quot; and the &quot;past&quot; respectively. The singular values of this weighted Hankel matrix
are the canonical correlation coefficients between the past and the future.
Note that the implementation here always sets \(f = p+1\)."><meta property="og:description" content="These procedure implement two subspace algorithms for the estimation of state space models,
the AOKI method, as described in (Aoki 1990)
 and the CCA algorithm
(see e.g. (Dahlen and Scherrer 2004)
 or (Bauer 2001)
).
These subspace algorithms center on the weighted Hankel matrix
$$(R_f')^{-T} H_{fp} R_p^{-1}$$
where the block Hankel matrix \(H_{fp}\) is the covariance between the
&quot;past&quot; \((y_{t-1}',\cdots,y_{t-p}')'\) and the
&quot;future&quot; \((y_{t}',\cdots,y_{t+f-1}')'\) and
\(R_f\) and \(R_p\) are the cholesky factors of the covariance matrices
of the &quot;future&quot; and the &quot;past&quot; respectively. The singular values of this weighted Hankel matrix
are the canonical correlation coefficients between the past and the future.
Note that the implementation here always sets \(f = p+1\)."><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script></head><body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">RLDM</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.0.0.9006</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto"><li class="active nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles"><li><a class="dropdown-item" href="../articles/0_getting_started.html">Getting Started with RLDM</a></li>
    <li><a class="dropdown-item" href="../articles/1_case_study.html">Case Study: Economic Data Analysis with RLDM</a></li>
    <li><a class="dropdown-item" href="../articles/2_technical_reference.html">Technical Reference: RLDM Classes and Methods</a></li>
  </ul></li>
      </ul><ul class="navbar-nav"><li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json"></form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/bfunovits/RLDM/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul></div>


  </div>
</nav><div class="container template-reference-topic">
<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Subspace Helper Methods</h1>

      <div class="d-none name"><code>subspace-helpers.Rd</code></div>
    </div>

    <div class="ref-description section level2">
    <p>These procedure implement two subspace algorithms for the estimation of state space models,
the <em>AOKI</em> method, as described in (Aoki 1990)
 and the <em>CCA</em> algorithm
(see e.g. (Dahlen and Scherrer 2004)
 or (Bauer 2001)
).
These subspace algorithms center on the weighted Hankel matrix
$$(R_f')^{-T} H_{fp} R_p^{-1}$$
where the block <em>Hankel</em> matrix \(H_{fp}\) is the covariance between the
"past" \((y_{t-1}',\cdots,y_{t-p}')'\) and the
"future" \((y_{t}',\cdots,y_{t+f-1}')'\) and
\(R_f\) and \(R_p\) are the cholesky factors of the covariance matrices
of the "future" and the "past" respectively. The singular values of this weighted Hankel matrix
are the canonical correlation coefficients between the past and the future.
Note that the implementation here always sets \(f = p+1\).</p>
    </div>

    <div class="section level2">
    <h2 id="ref-usage">Usage<a class="anchor" aria-label="anchor" href="#ref-usage"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span><span class="fu">est_stsp_aoki</span><span class="op">(</span></span>
<span>  <span class="va">gamma</span>,</span>
<span>  <span class="va">s.max</span>,</span>
<span>  <span class="va">p</span>,</span>
<span>  estorder <span class="op">=</span> <span class="va">estorder_SVC</span>,</span>
<span>  keep_models <span class="op">=</span> <span class="cn">FALSE</span>,</span>
<span>  n.obs <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  <span class="va">...</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="fu">est_stsp_cca</span><span class="op">(</span></span>
<span>  <span class="va">gamma</span>,</span>
<span>  <span class="va">s.max</span>,</span>
<span>  <span class="va">p</span>,</span>
<span>  estorder <span class="op">=</span> <span class="va">estorder_SVC</span>,</span>
<span>  keep_models <span class="op">=</span> <span class="cn">FALSE</span>,</span>
<span>  n.obs <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  <span class="va">...</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="fu">est_stsp_cca_sample</span><span class="op">(</span></span>
<span>  <span class="va">y</span>,</span>
<span>  <span class="va">s.max</span>,</span>
<span>  <span class="va">p</span>,</span>
<span>  estorder <span class="op">=</span> <span class="va">estorder_SVC</span>,</span>
<span>  keep_models <span class="op">=</span> <span class="cn">FALSE</span>,</span>
<span>  mean_estimate <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"sample.mean"</span>, <span class="st">"zero"</span><span class="op">)</span>,</span>
<span>  <span class="va">...</span></span>
<span><span class="op">)</span></span></code></pre></div>
    </div>

    <div class="section level2">
    <h2 id="arguments">Arguments<a class="anchor" aria-label="anchor" href="#arguments"></a></h2>


<dl><dt id="arg-gamma">gamma<a class="anchor" aria-label="anchor" href="#arg-gamma"></a></dt>
<dd><p>\((m,m,L+1)\)-dimensional array with the (sample) autocovariance function.</p></dd>


<dt id="arg-s-max">s.max<a class="anchor" aria-label="anchor" href="#arg-s-max"></a></dt>
<dd><p>(integer) maximum possible order.</p></dd>


<dt id="arg-p">p<a class="anchor" aria-label="anchor" href="#arg-p"></a></dt>
<dd><p>(integer) number of block columns of the Hankel matrix (size of the "past")</p></dd>


<dt id="arg-estorder">estorder<a class="anchor" aria-label="anchor" href="#arg-estorder"></a></dt>
<dd><p>function, to estimate the order of the system.</p></dd>


<dt id="arg-keep-models">keep_models<a class="anchor" aria-label="anchor" href="#arg-keep-models"></a></dt>
<dd><p>(boolean) should the function return a list with estimated system of
order <code>0:s.max</code>?</p></dd>


<dt id="arg-n-obs">n.obs<a class="anchor" aria-label="anchor" href="#arg-n-obs"></a></dt>
<dd><p>sample size \(N\).</p></dd>


<dt id="arg--">...<a class="anchor" aria-label="anchor" href="#arg--"></a></dt>
<dd><p>additional parameters, passed on to the order estimation routine.</p></dd>


<dt id="arg-y">y<a class="anchor" aria-label="anchor" href="#arg-y"></a></dt>
<dd><p>\((N,m)\)-dimensional matrix or an object, which may be coerced to
a matrix with <code>as.matrix{y}</code>.</p></dd>


<dt id="arg-mean-estimate">mean_estimate<a class="anchor" aria-label="anchor" href="#arg-mean-estimate"></a></dt>
<dd><p>Character string giving the method used to estimate
the mean \(\mu = E y_t\).
Default is to use the sample mean.</p></dd>

</dl></div>
    <div class="section level2">
    <h2 id="value">Value<a class="anchor" aria-label="anchor" href="#value"></a></h2>
    <p>List with slots:</p>
<dl><dt>model</dt>
<dd><p>a <code>stsp()</code> object, which represents the estimated state space model.</p></dd>

<dt>models</dt>
<dd><p>either <code>NULL</code> (if <code>!keep_models</code>) or a list with the parameters
of the estimated models with orders (<code>s=0:s.max+1</code>). This slot may e.g. be
used to estimate the model order by some user defined model selection procedure.</p></dd>

<dt>s</dt>
<dd><p>(integer) the estimate of the model order.</p></dd>

<dt>info</dt>
<dd><p>list with information about the data and the design parameters of the estimation procedure.</p></dd>

<dt>stats</dt>
<dd><p>((s.max+1)-by-5)-dimensional matrix with statistics of the (estimated) state space models.</p></dd>

</dl></div>
    <div class="section level2">
    <h2 id="details">Details<a class="anchor" aria-label="anchor" href="#details"></a></h2>
    <p>AOKIs method is a <em>realization</em> algorithm, i.e. it reconstructs the underlying state space
model from the (population) autocovariance function. To this end a Riccati equation has to be solved,
see <code><a href="riccati.html">riccati()</a></code>.
If an estimated ACF is fed into this algorithm one obtains an estimate for the
state space model. However note that this may fail (in particular the Riccati
equation may have no positive definite solution) if the estimate of the ACF is <em>not</em> positive
definite, if the Hankel matrix is too small or if state dimension is not correct.</p>
<p>The CCA method estimates the state space model by first constructing an estimate of the states.
Then the parameter matrices are estimated via simple LS regressions. This procedure does
not give the "true" model, even in the case when the population ACF is used. However,
the "distance" between the true model
and the estimated model converges to zero,
if the estimate of the ACF converges to the population ACF and
the size \(p\) of the Hankel matrix converges to infinity.</p>
<p>There are two implementations of the CCA method:</p><ol><li><p>The routine <code>est_stsp_cca_sample()</code>
operates directly on the supplied data.</p></li>
<li><p>The routine <code>est_stsp_cca()</code> uses an (estimated) autocovariance function.</p></li>
</ol><p>These algorithms may also be used as simple "model reduction algorithms". If we want to
approximate a high dimensional state space model by a model of lower order, we may proceed
as follows. First we compute the ACF of the high dimensional model and then fed
this ACF into the subspace routines <code>est_stsp_cca</code> or <code>est_stsp_aoki</code>,
however setting the maximum order <code>s.max</code> to some value less than the true order.</p>
<p><strong>Order Estimation</strong></p>
<p>The order estimation is based on the Hankel singular values \(\sigma_s\) and/or the
log det values of the estimated noise covariance matrices \(\ln\det \hat{\Sigma}_s\).
Using only the Hankel singular values has the advantage that only <em>one</em> model has to be estimated,
whereas otherwise estimates for <em>all</em> models with orders \(s=0,\ldots,s_{\max}\)
have to be computed.</p>
<p>In order to exploit this (small) advantage of singular values based criteria the
order estimation runs as follows:
First the procedures call
<br><code> estorder(s.max, Hsv, n.par, m, n.obs, Hsize=c(f,p), ...)</code>
<br>
Here <code>Hsv</code> is an \(pm\) dimensional vector with the Hankel singular values and
<code>n.par</code> is an \((s_{\max}+1)\) dimensional vector with the respective number of
parameters of the models with orders \(s=0,\ldots,s_{\max}\).
If this call returns an estimate of the order then the procedures estimate a
corresonding state space model.</p>
<p>If this call fails (i.e returns <code>NULL</code>) then the procedures estimate
all models with orders up to \(s_{\max}\) and the corresponding
noise covariance matrices. The order then is estimated by calling
<br><code> estorder(s.max = s.max, Hsv, lndetSigma, n.par, m, n.obs, Hsize, ...)</code>
<br>
where <code>lndetSigma</code> is the vector with the log det values of the estimated
noise covariance matrices (\(\ln\det \hat{\Sigma}_s\)).</p>
<p>The package offers some predefined order selection procedures
(see also <a href="subspace-order-estimates.html">subspace order estimates</a>):</p>
<p><code>estorder_max(s.max, ...)</code> simply returns the maximum order <code>s.max</code> considered.</p>
<p><code>estorder_rkH(s.max, Hsv, tol, ...)</code> estimates the order by an estimate
of the rank of the Hankel matrix.</p>
<p><code>estorder_MOE(s.max, Hsv, ...)</code> estimates the order by searching
for a "gap" in the singular values.</p>
<p><code>estorder_SVC(s.max, Hsv, n.par, n.obs, Hsize, penalty, ...)</code>
implements the so called <em>Singular Value Criteria</em>, see (Bauer 2001)
:
$$svc(s) = \sigma_{s+1}^2 + c(N)d(s)/N$$
Here \(\sigma_s\) is the \(s\)-th
singular value of the weighted Hankel marix, \(N\) is the sample size,
\(d(s) = 2ms\) denotes the number of parameters for a state space
model with \(s\) states (and \(m\) outputs) and \(c(N)\)) is a "penalty"
(depending on the sample size).</p>
<p>The above order estimation procedures only use the Hankel singular values, whereas
the following procedure is based on the estimated noise covariances.</p>
<p><code>estorder_IVC(s.max, lndetSigma, n.par, n.obs, penalty, ...)</code> estimates the order
via an information criterion of the form
$$ivc(s) = \ln\det\hat\Sigma_{s} + c(N)d(s)/N$$
where \(\hat\Sigma_s\) is the estimate of the noise covariace matrix
obtained from a model with order \(s\), \(d(s)\) denotes the number of parameters
and \(c(N)\) is a "penalty" (depending on the sample size).</p>
<p>For both <code>estorder_SVC</code> and <code>estorder_IVC</code> the (optional) parameter
<code>penalty</code> controls the penalty term \(c(N)\).</p>
<p>Note also that for  <code>keep_models==TRUE</code> the estimation procedures compute <em>all</em>
models even in the case of a Hankel singular value based selection criterion.</p>
    </div>
    <div class="section level2">
    <h2 id="references">References<a class="anchor" aria-label="anchor" href="#references"></a></h2>
    <p>Bauer D (2001).
“Order estimation for subspace methods.”
<em>Automatica</em>, <b>37</b>(10), 1561 - 1573.
<a href="https://doi.org/10.1016/S0005-1098%2801%2900118-2" class="external-link">doi:10.1016/S0005-1098(01)00118-2</a>
.</p>
    </div>

  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside></div>


    <footer><div class="pkgdown-footer-left">
  <p>Developed by <a href="https://scholar.google.com/citations?user=-Ytb9BYAAAAJ" class="external-link">Wolfgang Scherrer</a>, <a href="https://ch.linkedin.com/in/bernd-funovits-phd-cfa-a8215016" class="external-link">Bernd Funovits</a>.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.2.0.</p>
</div>

    </footer></div>





  </body></html>

