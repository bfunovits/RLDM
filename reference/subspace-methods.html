<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="description" content="Estimate (respectively construct) a state space model from a given sample or a given
(sample) autocovariance function."><title>Estimate State Space Models with Subspace Methods — subspace methods • RLDM</title><script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet"><script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous"><!-- bootstrap-toc --><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@v1.0.1/dist/bootstrap-toc.min.js" integrity="sha256-4veVQbu7//Lk5TSmc7YV48MxtMy98e26cf5MrgZYnwo=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- search --><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Estimate State Space Models with Subspace Methods — subspace methods"><meta property="og:description" content="Estimate (respectively construct) a state space model from a given sample or a given
(sample) autocovariance function."><!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]--></head><body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>
    

    <nav class="navbar fixed-top navbar-light navbar-expand-lg bg-light"><div class="container">
    
    <a class="navbar-brand me-2" href="../index.html">RLDM</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.0.0.9006</small>

    
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto"><li class="active nav-item">
  <a class="nav-link" href="../reference/index.html">Reference</a>
</li>
<li class="nav-item dropdown">
  <a href="#" class="nav-link dropdown-toggle" data-bs-toggle="dropdown" role="button" aria-expanded="false" aria-haspopup="true" id="dropdown-articles">Articles</a>
  <div class="dropdown-menu" aria-labelledby="dropdown-articles">
    <a class="dropdown-item" href="../articles/a_RLDM.html">Rational Linear Dynamic Models (RLDM)</a>
    <a class="dropdown-item" href="../articles/b_RLDM_technicaldetails.html">Rational Linear Dynamic Models (RLDM): Technical Details</a>
    <a class="dropdown-item" href="../articles/c_hrk_stage3.html">Hannan-Rissanen-Kavalieris Estimation - Stage 3</a>
    <a class="dropdown-item" href="../articles/d_casestudy2.html">Case Study</a>
  </div>
</li>
      </ul><form class="form-inline my-2 my-lg-0" role="search">
        <input type="search" class="form-control me-sm-2" aria-label="Toggle navigation" name="search-input" data-search-index="../search.json" id="search-input" placeholder="Search for" autocomplete="off"></form>

      <ul class="navbar-nav"><li class="nav-item">
  <a class="external-link nav-link" href="https://github.com/bfunovits/RLDM/" aria-label="github">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul></div>

    
  </div>
</nav><div class="container template-reference-topic">
<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="" class="logo" alt=""><h1>Estimate State Space Models with Subspace Methods</h1>
      
      <div class="d-none name"><code>subspace-methods.Rd</code></div>
    </div>

    <div class="ref-description section level2">
    <p>Estimate (respectively construct) a state space model from a given sample or a given
(sample) autocovariance function.</p>
    </div>

    <div class="section level2">
    <h2 id="ref-usage">Usage<a class="anchor" aria-label="anchor" href="#ref-usage"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span><span class="fu">est_stsp_ss</span><span class="op">(</span></span>
<span>  <span class="va">obj</span>,</span>
<span>  method <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"cca"</span>, <span class="st">"aoki"</span><span class="op">)</span>,</span>
<span>  s.max <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  p <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  p.ar.max <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  p.factor <span class="op">=</span> <span class="fl">2</span>,</span>
<span>  extend_acf <span class="op">=</span> <span class="cn">FALSE</span>,</span>
<span>  sample2acf <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  estorder <span class="op">=</span> <span class="va">estorder_SVC</span>,</span>
<span>  keep_models <span class="op">=</span> <span class="cn">FALSE</span>,</span>
<span>  mean_estimate <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"sample.mean"</span>, <span class="st">"zero"</span><span class="op">)</span>,</span>
<span>  n.obs <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  <span class="va">...</span></span>
<span><span class="op">)</span></span></code></pre></div>
    </div>

    <div class="section level2">
    <h2 id="arguments">Arguments<a class="anchor" aria-label="anchor" href="#arguments"></a></h2>
    <dl><dt>obj</dt>
<dd><p>Either a "time series" object (i.e <code>as.matrix(obj)</code>
returns an \((N,m)\)-dimensional numeric matrix)
or an <code><a href="autocov.html">autocov()</a></code> object (with \(L\) lags)
which represents an (estimated) autocovariance function.
The type of the <code>autocov</code> object is irrelevant since <code>est_stsp_ss</code> always uses the
slot <code>obj$gamma</code> which contains the autocovariance function.</p></dd>


<dt>method</dt>
<dd><p>Character string giving the method used to fit the model.</p></dd>


<dt>s.max</dt>
<dd><p>(integer) maximum order of the state space model. If <code>NULL</code> a default value
is chosen based on the sample size \(N\), respectively based on the number of lags
\(L\) of the ACF.</p></dd>


<dt>p</dt>
<dd><p>(integer) number of block columns of the Hankel matrix (size of the "past"). If <code>NULL</code>
then <code>p</code> is chosen by fitting a "long" AR model.</p></dd>


<dt>p.ar.max</dt>
<dd><p>(integer) maximum order of the "long" AR model. If <code>NULL</code> a default choice is made.
This parameter is only needed in the case <code>p=NULL</code>.</p></dd>


<dt>p.factor</dt>
<dd><p>(integer) If <code>p=NULL</code>, then the number of block columns of the
Hankel matrix is set to \(p = p_f\hat{p}_{AIC}\) where
\(p_f\) is this parameter <code>p.factor</code> and
\(\hat{p}_{AIC}\) is
the (AIC) estimate of the order of the "long" AR model. See also <code><a href="est_ar.html">est_ar()</a></code>.</p></dd>


<dt>extend_acf</dt>
<dd><p>(boolean) If TRUE then the ACF is extended via an AR(p) model (MEST).</p></dd>


<dt>sample2acf</dt>
<dd><p>(boolean) If <code>obj</code> is a data object and <code>sample2acf</code> is TRUE,
then first the sample autocovariance function is computed and then used for the actual computations.</p></dd>


<dt>estorder</dt>
<dd><p>function, used to select the order of the state space model.</p></dd>


<dt>keep_models</dt>
<dd><p>(boolean) should the function return a list with estimated system of order 0:s.max?</p></dd>


<dt>mean_estimate</dt>
<dd><p>Character string giving the method used to estimate the mean
\(\mu = E y_t\).
Default is to use the sample mean. See the details below.</p></dd>


<dt>n.obs</dt>
<dd><p>Optional integer which gives the sample size \(N\). This parameter is only used,
when <code>obj</code> is an <code><a href="autocov.html">autocov()</a></code> object. If <code>n.obs=NULL</code> then the
slot <code>obj$n.obs</code> is used. Note that <code>obj$n.obs=NULL</code> or <code>obj$n.obs=Inf</code>
refers to the case of a population autocovariance function,
i.e. \(N=\infty\). For a "time series" object the sample size is of course set to
the number of observations, i.e. <code>n.obs = nrow(as.matrix(obj))</code>.
The sample size \(N\) controls the computation of the default (maximum) orders
and the estimation of the order of the state space model.</p></dd>


<dt>...</dt>
<dd><p>additional parameters, passed on to the order estimation routine.</p></dd>

</dl></div>
    <div class="section level2">
    <h2 id="value">Value<a class="anchor" aria-label="anchor" href="#value"></a></h2>
    

<p>list with slots</p>
<dl><dt>model</dt>
<dd><p>a <code>stsp()</code> object, which represents the estimated state space model.</p></dd>

<dt>models</dt>
<dd><p>either <code>NULL</code> (if <code>!keep_models</code>) or a list with the parameters
of the estimated models with orders (<code>s=0:s.max+1</code>). This slot may e.g. be
used to estimate the model order by some user defined model selection procedure.</p></dd>

<dt>s</dt>
<dd><p>(integer) the estimate of the model order.</p></dd>

<dt>info</dt>
<dd><p>list with information about the data and the design parameters of the estimation procedure.</p></dd>

<dt>stats</dt>
<dd><p>((s.max+1)-by-5)-dimensional matrix with statistics of the (estimated) state space models.</p></dd>

<dt>y.mean</dt>
<dd><p>estimate of the mean \(\mu\).</p></dd>

</dl></div>
    <div class="section level2">
    <h2 id="details">Details<a class="anchor" aria-label="anchor" href="#details"></a></h2>
    <p>The procedure implements three subspace algorithms for the estimation of state space models,
the <em>AOKI</em> method, as described in (Aoki 1990)
 and the <em>CCA</em>
and <em>MEST</em> algorithms
(see e.g. (Dahlen and Scherrer 2004)
). All three algorithms center on the
weighted Hankel matrix
$$(R_f')^{-T} H_{fp} R_p^{-1}$$
where the block <em>Hankel</em> matrix \(H_{fp}\) is the covariance between the
"past" \((y_{t-1}',\cdots,y_{t-p}')'\) and the
"future" \((y_{t}',\cdots,y_{t+f-1}')'\) and
\(R_f\) and \(R_p\) are the cholesky factors of the covariance matrices
of the "future" and the "past" respectively. The singular values of this weighted Hankel matrix
are the canonical correlation coefficients between the past and the future.
Note that the implementation here always sets \(f = p+1\).</p>
<p>AOKIs method is a <em>realization</em> algorithm, i.e. it reconstructs the underlying state space
model from the (population) autocovariance function. To this end a Riccati equation has to be solved,
see <code><a href="riccati.html">riccati()</a></code>.
If an estimated ACF is fed into this algorithm one obtains an estimate for the
state space model. However note that this may fail (in particular the Riccati
equation may have no positive definite solution) if the estimate of the ACF is <em>not</em> positive
definite, if the Hankel matrix is too small or if state dimension is not correct.</p>
<p>The CCA method estimates the state space model by first constructing an estimate of the states.
Then the parameter matrices are estimated via simple LS regressions. This procedure does
not give the "true" model, even in the case when the population ACF is used. However,
the "distance" between the true model
and the estimated model converges to zero,
if the estimate of the ACF converges to the population ACF and
the size \(p\) of the Hankel matrix converges to infinity.</p>
<p>There are two implementations of the CCA method:</p><ol><li><p>If <code>obj</code> is a "time series" object and
<code>sample2acf==FALSE</code> then the helper function
<code><a href="subspace-helpers.html">est_stsp_cca_sample()</a></code> is called. This implementation
of CCA operates directly on the supplied data.</p></li>
<li><p>If <code>obj</code> is an <code><a href="autocov.html">autocov()</a></code> object or
when <code>obj</code> is a "time series" object and
<code>sample2acf==TRUE</code> then the helper function <code><a href="subspace-helpers.html">est_stsp_cca()</a></code>
is called. This implementation uses an (estimated) autocovariance function.
For a time series object, first the sample
autocovariance function is computed and then fed into the helper function.</p></li>
</ol><p>The key idea of the MEST algorithm is to first estimate a "long" AR model, convert this
AR model to a state space model and then to use a "balancing and truncation" method to obtain the
final estimate of the state space model. This scheme may be obtained by
calling <code>est_stsp_ss</code> with the option <code>extend_acf=TRUE</code>: This option
instructs the procedure to first estimate an AR(p) model and then to use this model
to "extend" the ACF, i.e.
to compute the values of the ACF for lags \(p+1,\ldots,2p\).
Then this extended ACF is fed into the helper function  <code><a href="subspace-helpers.html">est_stsp_cca()</a></code>.</p>
<p>Note that MEST uses the autocovariance function. So for a "time series" object one has
to set <code>sample2acf=TRUE</code>.</p>
<p>These algorithms may be used for model reduction (i.e. to find a model with a
smaller state space dimension than the true model) and for estimation (by feeding a sample autocovariance function in).</p>
<p>These algorithms may also be used as simple "model reduction algorithms". If we want to
approximate a high dimensional state space model by a model of lower order, we may proceed
as follows. First we compute the ACF of the high dimensional model and then fed
this ACF into the subspace routine <code>est_stsp_ss</code>, however setting the maximum order
<code>s.max</code> to some value less than the true order.
Note thet the AOKI procedure however, may break down, since it is not guaranteed that
the Riccati equation, which needs to be solved, has a positive semidefinite solution.</p>
<p><strong>Size of the Hankel matrix</strong></p>
<p>If the input parameter <code>p=NULL</code> then \(p\) is chosen as follows. The procedure
estimates the order of a "long" AR model with the AIC criterion. The size of
the "past" \(p\) then is set to \(p = p_f\hat{p}_{AIC}\)
where \(p_f\) is a factor (defaults to \(2\)) and
\(\hat{p}_{AIC}\) is the (AIC) estimate of the order of the "long"
AR model. See also <code><a href="est_ar.html">est_ar()</a></code>.</p>
<p><strong>Estimation of the Mean</strong></p>
<p>If the input parameter <code>obj</code> is an <code><a href="autocov.html">autocov()</a></code> object (which contains no info
about the mean \(\mu=E y_t\)) the "estimate" of the mean is simply set to
a vector of <code>NA</code>'s.</p>
<p>If the input parameter <code>obj</code> is a "time series" object, then there are two options.
For <code>mean_estimate == 'zero'</code> the procedure assumes that the process is centered
(\(\mu=E y_t=0\)) and thus sets the estimate to a zero vector.
In the case <code>mean_estimate == 'sample.mean'</code>  the sample mean of the data is used.</p>
<p><strong>Order Estimation</strong></p>
<p>The input parameter <code>s.max</code> defines the maximum order considered.</p>
<p>The order estimation is based on the Hankel singular values \(\sigma_s\) and/or the
log det values of the estimated noise covariance matrices \(\ln\det \hat{\Sigma}_s\).
Using only the Hankel singular values has the advantage that only <em>one</em> model has to be estimated,
whereas otherwise estimates for <em>all</em> models with orders \(s=0,\ldots,s_{\max}\)
have to be computed.</p>
<p>In order to exploit this (small) advantage of singular values based criteria the
order estimation runs as follows:
First the procedures call
<br><code> estorder(s.max, Hsv, n.par, m, n.obs, Hsize=c(f,p), ...)</code>
<br>
Here <code>Hsv</code> is an \(pm\) dimensional vector with the Hankel singular values and
<code>n.par</code> is an \((s_{\max}+1)\) dimensional vector with the respective number of
parameters of the models with orders \(s=0,\ldots,s_{\max}\).
If this call returns an estimate of the order then the procedures estimate a
corresonding state space model.</p>
<p>If this call fails (i.e returns <code>NULL</code>) then the procedures estimate
all models with orders up to \(s_{\max}\) and the corresponding
noise covariance matrices. The order then is estimated by calling
<br><code> estorder(s.max = s.max, Hsv, lndetSigma, n.par, m, n.obs, Hsize, ...)</code>
<br>
where <code>lndetSigma</code> is the vector with the log det values of the estimated
noise covariance matrices (\(\ln\det \hat{\Sigma}_s\)).</p>
<p>The package offers some predefined order selection procedures
(see also <a href="subspace-order-estimates.html">subspace order estimates</a>):</p><ul><li><p><code>estorder_max(s.max, ...)</code> simply returns
the maximum order <code>s.max</code> considered.</p></li>
<li><p><code>estorder_rkH(s.max, Hsv, tol, ...)</code> estimates
the order by an estimate of the rank of the Hankel matrix.</p></li>
<li><p><code>estorder_MOE(s.max, Hsv, ...)</code> estimates the order by searching
for a "gap" in the singular values.</p></li>
<li><p><code>estorder_SVC(s.max, Hsv, n.par, n.obs, Hsize, penalty, ...)</code>
implements the so called <em>Singular Value Criteria</em>, see
(Bauer 2001)
:
$$svc(s) = \sigma_{s+1}^2 + c(N)d(s)/N$$
Here \(\sigma_s\) is the \(s\)-th
singular value of the weighted Hankel marix, \(N\) is the sample size,
\(d(s) = 2ms\) denotes the number of parameters for a state space
model with \(s\) states (and \(m\) outputs) and \(c(N)\)) is a "penalty"
(depending on the sample size).
<br>
The above order estimation procedures only use the Hankel singular values, whereas
the following procedure is based on the estimated noise covariances.</p></li>
<li><p><code>estorder_IVC(s.max, lndetSigma, n.par, n.obs, penalty, ...)</code> estimates the order
via an information criterion of the form
$$ivc(s) = \ln\det\hat\Sigma_{s} + c(N)d(s)/N$$
where \(\hat\Sigma_s\) is the estimate of the noise covariace matrix
obtained from a model with order \(s\), \(d(s)\) denotes the number of parameters
and \(c(N)\) is a "penalty" (depending on the sample size).</p></li>
</ul><p>For both <code>estorder_SVC</code> and <code>estorder_IVC</code> the (optional) parameter
<code>penalty</code> controls the penalty term \(c(N)\).</p>
    </div>
    <div class="section level2">
    <h2 id="further-notes">Further Notes<a class="anchor" aria-label="anchor" href="#further-notes"></a></h2>
    


<p>The actual computations are done by the helper routines detailed in <a href="subspace-helpers.html">subspace helpers</a>.</p>
<p>The type of the <code><a href="autocov.html">autocov()</a></code> object is irrelevenat
since the function always uses the slot <code>obj$gamma</code>.</p>
<p>For  <code>keep_models==TRUE</code> the estimation procedure compute <em>all</em>
models even in the case of a Hankel singular value based selection criterion.</p>
    </div>
    <div class="section level2">
    <h2 id="references">References<a class="anchor" aria-label="anchor" href="#references"></a></h2>
    <p>Aoki M (1990).
<em>State Space Modeling of Time Series</em>.
Springer Verlag, New York.</p>
<p>Bauer D (2001).
“Order estimation for subspace methods.”
<em>Automatica</em>, <b>37</b>(10), 1561 - 1573.
<a href="https://doi.org/10.1016/S0005-1098%2801%2900118-2" class="external-link">doi:10.1016/S0005-1098(01)00118-2</a>
.</p>
<p>Dahlen A, Scherrer W (2004).
“The relation of the CCA subspace method to a balanced reduction of an autoregressive model.”
<em>Journal of Econometrics</em>, <b>118</b>, 293--312.
<a href="https://doi.org/10.1016/S0304-4076%2803%2900144-1" class="external-link">doi:10.1016/S0304-4076(03)00144-1</a>
.</p>
    </div>

    <div class="section level2">
    <h2 id="ref-examples">Examples<a class="anchor" aria-label="anchor" href="#ref-examples"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span class="r-in"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">3421</span><span class="op">)</span> <span class="co"># in order to get reproducible results</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># create a "random", stable and miniphase state space model</span></span></span>
<span class="r-in"><span><span class="va">m</span> <span class="op">=</span> <span class="fl">2</span> <span class="co"># number of outputs</span></span></span>
<span class="r-in"><span><span class="va">s</span> <span class="op">=</span> <span class="fl">3</span> <span class="co"># number of states</span></span></span>
<span class="r-in"><span><span class="va">s.max</span> <span class="op">=</span> <span class="fl">2</span><span class="op">*</span><span class="va">s</span></span></span>
<span class="r-in"><span><span class="va">lag.max</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">max</a></span><span class="op">(</span><span class="fl">4</span><span class="op">*</span><span class="va">s</span>, <span class="fl">25</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">n.obs</span> <span class="op">=</span> <span class="fl">1000</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="va">model</span> <span class="op">=</span> <span class="fu"><a href="r_model.html">r_model</a></span><span class="op">(</span><span class="fu"><a href="model_structures.html">tmpl_stsp_full</a></span><span class="op">(</span><span class="va">m</span>, <span class="va">m</span>, <span class="va">s</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>                bpoles <span class="op">=</span> <span class="fl">1</span>, bzeroes <span class="op">=</span> <span class="fl">1</span>,  sd <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="co"># scale sigma_L</span></span></span>
<span class="r-in"><span><span class="fu"><a href="https://rdrr.io/r/base/diag.html" class="external-link">diag</a></span><span class="op">(</span><span class="va">model</span><span class="op">$</span><span class="va">sigma_L</span><span class="op">)</span> <span class="op">=</span> <span class="fl">1</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># compute ACF</span></span></span>
<span class="r-in"><span><span class="va">gam</span> <span class="op">=</span> <span class="fu"><a href="autocov.html">autocov</a></span><span class="op">(</span><span class="va">model</span>, lag.max <span class="op">=</span> <span class="va">lag.max</span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># simulate data</span></span></span>
<span class="r-in"><span><span class="va">data</span> <span class="op">=</span> <span class="fu"><a href="sim.html">sim</a></span><span class="op">(</span><span class="va">model</span>, <span class="va">n.obs</span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># sample ACF</span></span></span>
<span class="r-in"><span><span class="va">gam.sample</span> <span class="op">=</span> <span class="fu"><a href="autocov.html">autocov</a></span><span class="op">(</span><span class="va">data</span><span class="op">$</span><span class="va">y</span>, lag.max <span class="op">=</span> <span class="va">lag.max</span>, demean <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># AOKIs method ##############################################################</span></span></span>
<span class="r-in"><span><span class="co"># reconstruct the true model from the population ACF</span></span></span>
<span class="r-in"><span><span class="co"># "estimate" the order by the rank of the Hankel matrix</span></span></span>
<span class="r-in"><span><span class="va">out</span> <span class="op">=</span> <span class="fu">est_stsp_ss</span><span class="op">(</span><span class="va">gam</span>, method <span class="op">=</span> <span class="st">'aoki'</span>, s.max <span class="op">=</span> <span class="fl">2</span><span class="op">*</span><span class="va">s</span>, estorder <span class="op">=</span> <span class="va">estorder_rkH</span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># compute the ACF of the constructed model.</span></span></span>
<span class="r-in"><span><span class="va">gam.hat</span> <span class="op">=</span> <span class="fu"><a href="autocov.html">autocov</a></span><span class="op">(</span><span class="va">out</span><span class="op">$</span><span class="va">model</span>, lag.max <span class="op">=</span> <span class="va">lag.max</span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># check that the constructed model is equivalent to the original model</span></span></span>
<span class="r-in"><span><span class="fu"><a href="https://rdrr.io/r/base/all.equal.html" class="external-link">all.equal</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/dim.html" class="external-link">dim</a></span><span class="op">(</span><span class="va">model</span><span class="op">$</span><span class="va">sys</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/dim.html" class="external-link">dim</a></span><span class="op">(</span><span class="va">out</span><span class="op">$</span><span class="va">model</span><span class="op">$</span><span class="va">sys</span><span class="op">)</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] TRUE</span>
<span class="r-in"><span><span class="fu"><a href="https://rdrr.io/r/base/all.equal.html" class="external-link">all.equal</a></span><span class="op">(</span><span class="va">gam</span>, <span class="va">gam.hat</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] TRUE</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># CCA based on the sample ###################################################</span></span></span>
<span class="r-in"><span><span class="co"># estimate the order by a "singular value criterion"</span></span></span>
<span class="r-in"><span><span class="va">out</span> <span class="op">=</span> <span class="fu">est_stsp_ss</span><span class="op">(</span><span class="va">data</span><span class="op">$</span><span class="va">y</span>, method <span class="op">=</span> <span class="st">'cca'</span>, sample2acf <span class="op">=</span> <span class="cn">FALSE</span>, s.max <span class="op">=</span> <span class="fl">2</span><span class="op">*</span><span class="va">s</span>,</span></span>
<span class="r-in"><span>                  estorder <span class="op">=</span> <span class="va">estorder_SVC</span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># compute the ACF of the constructed model.</span></span></span>
<span class="r-in"><span><span class="va">gam.hat</span> <span class="op">=</span> <span class="fu"><a href="autocov.html">autocov</a></span><span class="op">(</span><span class="va">out</span><span class="op">$</span><span class="va">model</span>, lag.max <span class="op">=</span> <span class="va">lag.max</span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="fu"><a href="https://rdrr.io/r/base/all.equal.html" class="external-link">all.equal</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/dim.html" class="external-link">dim</a></span><span class="op">(</span><span class="va">model</span><span class="op">$</span><span class="va">sys</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/dim.html" class="external-link">dim</a></span><span class="op">(</span><span class="va">out</span><span class="op">$</span><span class="va">model</span><span class="op">$</span><span class="va">sys</span><span class="op">)</span><span class="op">)</span> <span class="co"># the estimated order is correct</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] TRUE</span>
<span class="r-in"><span><span class="fu"><a href="https://rdrr.io/r/base/all.equal.html" class="external-link">all.equal</a></span><span class="op">(</span><span class="va">gam</span><span class="op">$</span><span class="va">gamma</span>, <span class="va">gam.hat</span><span class="op">$</span><span class="va">gamma</span><span class="op">)</span>           <span class="co"># but of course the estimated model is not perfect</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "Mean relative difference: 0.1680467"</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># CCA based on the sample ACF ###############################################</span></span></span>
<span class="r-in"><span><span class="co"># estimate the order by an "information criterion"</span></span></span>
<span class="r-in"><span><span class="va">out</span> <span class="op">=</span> <span class="fu">est_stsp_ss</span><span class="op">(</span><span class="va">gam.sample</span>, method <span class="op">=</span> <span class="st">'cca'</span>, s.max <span class="op">=</span> <span class="fl">2</span><span class="op">*</span><span class="va">s</span>,</span></span>
<span class="r-in"><span>                  estorder <span class="op">=</span> <span class="va">estorder_IVC</span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># compute the ACF of the constructed model.</span></span></span>
<span class="r-in"><span><span class="va">gam.hat</span> <span class="op">=</span> <span class="fu"><a href="autocov.html">autocov</a></span><span class="op">(</span><span class="va">out</span><span class="op">$</span><span class="va">model</span>, lag.max <span class="op">=</span> <span class="va">lag.max</span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="fu"><a href="https://rdrr.io/r/base/cat.html" class="external-link">cat</a></span><span class="op">(</span><span class="st">'s.hat='</span>, <span class="fu"><a href="https://rdrr.io/r/base/dim.html" class="external-link">dim</a></span><span class="op">(</span><span class="va">out</span><span class="op">$</span><span class="va">model</span><span class="op">$</span><span class="va">sys</span><span class="op">)</span><span class="op">[</span><span class="fl">3</span><span class="op">]</span>, <span class="st">'\n'</span><span class="op">)</span> <span class="co"># the estimated order is s.hat=2, the true order is s=3!</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> s.hat= 2 </span>
<span class="r-in"><span><span class="fu"><a href="https://rdrr.io/r/base/all.equal.html" class="external-link">all.equal</a></span><span class="op">(</span><span class="va">gam</span><span class="op">$</span><span class="va">gamma</span>, <span class="va">gam.hat</span><span class="op">$</span><span class="va">gamma</span><span class="op">)</span>        <span class="co"># relative error of the TRUE and the estimated ACF</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "Mean relative difference: 0.1966654"</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># alternatively, we may also use</span></span></span>
<span class="r-in"><span><span class="va">out2</span> <span class="op">=</span> <span class="fu">est_stsp_ss</span><span class="op">(</span><span class="va">data</span><span class="op">$</span><span class="va">y</span>, sample2acf <span class="op">=</span> <span class="cn">TRUE</span>, mean_estimate <span class="op">=</span> <span class="st">'zero'</span>,</span></span>
<span class="r-in"><span>                   method <span class="op">=</span> <span class="st">'cca'</span>, s.max <span class="op">=</span> <span class="fl">2</span><span class="op">*</span><span class="va">s</span>, estorder <span class="op">=</span> <span class="va">estorder_IVC</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="fu"><a href="https://rdrr.io/r/base/all.equal.html" class="external-link">all.equal</a></span><span class="op">(</span><span class="va">out</span><span class="op">$</span><span class="va">model</span>, <span class="va">out2</span><span class="op">$</span><span class="va">model</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] TRUE</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># MEST algorithm #############################################################</span></span></span>
<span class="r-in"><span><span class="co"># estimate the order by an "information criterion"</span></span></span>
<span class="r-in"><span><span class="va">out</span> <span class="op">=</span> <span class="fu">est_stsp_ss</span><span class="op">(</span><span class="va">gam.sample</span>, method <span class="op">=</span> <span class="st">'cca'</span>, extend_acf <span class="op">=</span> <span class="cn">TRUE</span>, s.max <span class="op">=</span> <span class="fl">2</span><span class="op">*</span><span class="va">s</span>,</span></span>
<span class="r-in"><span>                  estorder <span class="op">=</span> <span class="va">estorder_IVC</span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># compute the ACF of the constructed model.</span></span></span>
<span class="r-in"><span><span class="va">gam.hat</span> <span class="op">=</span> <span class="fu"><a href="autocov.html">autocov</a></span><span class="op">(</span><span class="va">out</span><span class="op">$</span><span class="va">model</span>, lag.max <span class="op">=</span> <span class="va">lag.max</span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="fu"><a href="https://rdrr.io/r/base/cat.html" class="external-link">cat</a></span><span class="op">(</span><span class="st">'s.hat='</span>, <span class="fu"><a href="https://rdrr.io/r/base/dim.html" class="external-link">dim</a></span><span class="op">(</span><span class="va">out</span><span class="op">$</span><span class="va">model</span><span class="op">$</span><span class="va">sys</span><span class="op">)</span><span class="op">[</span><span class="fl">3</span><span class="op">]</span>, <span class="st">'\n'</span><span class="op">)</span> <span class="co"># the estimated order is s.hat=2, the true order is s=3!</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> s.hat= 2 </span>
<span class="r-in"><span><span class="fu"><a href="https://rdrr.io/r/base/all.equal.html" class="external-link">all.equal</a></span><span class="op">(</span><span class="va">gam</span><span class="op">$</span><span class="va">gamma</span>, <span class="va">gam.hat</span><span class="op">$</span><span class="va">gamma</span><span class="op">)</span>        <span class="co"># relative error of the TRUE and the estimated ACF</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "Mean relative difference: 0.196599"</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># make a plot of the ACFs</span></span></span>
<span class="r-in"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">gam</span>, <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="va">gam.sample</span>, <span class="va">gam.hat</span><span class="op">)</span>, legend <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">'TRUE'</span>, <span class="st">'sample'</span>, <span class="st">'subspace'</span><span class="op">)</span><span class="op">)</span></span></span>
<span class="r-plt img"><img src="subspace-methods-1.png" alt="" width="700" height="433"></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># reset seed</span></span></span>
<span class="r-in"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="cn">NULL</span><span class="op">)</span></span></span>
</code></pre></div>
    </div>
  </main><aside class="col-md-3"><nav id="toc"><h2>On this page</h2>
    </nav></aside></div>


    <footer><div class="pkgdown-footer-left">
  <p></p><p>Developed by <a href="https://scholar.google.com/citations?user=-Ytb9BYAAAAJ" class="external-link">Wolfgang Scherrer</a>, <a href="https://ch.linkedin.com/in/bernd-funovits-phd-cfa-a8215016" class="external-link">Bernd Funovits</a>.</p>
</div>

<div class="pkgdown-footer-right">
  <p></p><p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

    </footer></div>

  

  

  </body></html>

